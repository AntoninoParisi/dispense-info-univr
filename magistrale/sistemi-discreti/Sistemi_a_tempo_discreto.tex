\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{color}
\usepackage{latexsym}
\usepackage{lstautogobble}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[margin=3cm]{geometry}



\date{\today}

\newtheorem{definit}{Definizione}[subsection]
\newtheorem{thm}{Teorema}[subsection]

\begin{document}
 \clearpage
 \begin{titlepage}
 	\centering
 	\vspace*{\fill}
 	{\scshape\LARGE Università degli Studi di Verona \par}
 	\vspace{1.5cm}
 	\line(1,0){280} \\
 	{\huge\bfseries Sistemi ad eventi discreti\par}
 	\line(1,0){280} \\
 	\vspace{0.5cm}
 	{\scshape\Large Riassunto dei principali argomenti\par}
 	\vspace{2cm}
 	{\Large\itshape Giorgia Gulino, Davide Bianchi\par}
 	\vspace{1cm}

 	\vspace{5cm}
 	\vspace*{\fill}
 	% Bottom of the page
 	{\large \today\par}
 \end{titlepage}
 \thispagestyle{empty}
\newpage
\tableofcontents
\newpage

\section{Macchine a stati}

\begin{definit}[Macchina a stati deterministica]
Una macchina a stati deterministica esiste un solo uno stato iniziale. Inoltre per ogni stato e per ogni input esiste solo un stato successivo. Se $M_2$ è deterministica allora $M_1$ è \textbf{simulata} da $M_2$ sse è \textbf{equivalente} a $M_2$.
\end{definit}

\subsection{Output-Deterministico}
Solo uno stato iniziale e per ogni stato e ogni coppia di I/O c'è 1 solo stato successivo. Se $M_2$ è \textbf{Output-Det} allora $M_2$ \textbf{simula} $M_1$ sse $M_1$ \textbf{raffina} $M_2$.\\

\begin{center}
\emph{Deterministico} implica Output-Det, ma \textbf{non} viceversa.
\end{center}

\subsection{Non-Deterministico}
Può esserci più di uno stato iniziale e per ogni stato e ogni coppia di I/O può esserci + di uno stato successivo. Se $M_2$ è NON-DET, $M_1$ è \textbf{simulata} da $M_2$ allora $M_1$ \textbf{raffina} $M_2$, ma non viceversa.

\subsection{Non-Deterministico, Progressiva}
Progressiva significa che l'evoluzione è definita per ogni ingresso, cioè la funzione è definita come: Stati x ingressi $\rightarrow$ P(Stati x uscite)/insieme vuoto, dove P rappresenta l'insieme potenza e l'insieme vuoto impone che sia progressiva.

\subsection{Equivalenza}

\begin{itemize}
\item X Det: input[$M_1$]=input[$M_2$]; output[$M_1$]=output[$M_2$].
\item X Non-det: comportamento[$M_1$]=comportamento[$M_2$].
\item Cioè se $M_1$ \textbf{raffina} m2 e viceversa.
\item C'è equivalenza se c'è \textbf{bisimulazione}.
\end{itemize}

\subsection{Raffinamento}
$M_1$ \textbf{raffina} $M_2$ sse input[$M_1$]=input[$M_2$]; output[$M_1$]=output[$M_2$] e comportamento[$M_1$] $\subseteq$ comportamento[$M_2$].

\subsection{Bisimulazione}
Bisimulazione tra $M_1$ e $M_2$ sse l'unione delle \textbf{simulazioni} è simmetrica e c'è \textbf{isomorfismo} tra minimize($M_1$) e minimize($M_2$).

\subsection{Isomorfe}
Si dicono isomorfe se hanno lo stesso numero di stati con nome uguale.

\subsection{Rel. RAFFINAMENTO/SIMULAZIONE AFSND $\rightarrow$ AFSD} Se $M_1$ è det, $M_1$ è \textbf{simulata} da $M_2$ sse $M_1$ è equivalente a $M_2$, cioè se $M_1$ raffina $M_2$ e viceversa.
\subsection{Rel. RAFFINAMENTO/SIMULAZIONE AFSND $\rightarrow$ AFSpseudo-nondet} Se $M_2$ è psuedo-non det, $M_1$ è \textbf{simulata} da $M_2$ sse $M_1$ è equivalente a $M_2$, cioè se $M_1$ \textbf{raffina} $M_2$.
\subsection{Rel. RAFFINAMENTO/SIMULAZIONE AFSND $\rightarrow$ AFSND} Se $M_2$ non è deterministica, $M_1$ è \textbf{simulata} da $M_2$ implica $M_1$ \textbf{raffina} $M_2$, ma $M_1$ raffina $M_2$ non implica $M_1$ \textbf{simula} $M_2$.
\subsection{Simulazione per Det $\rightarrow$ $M_1$ da $M_2$}
\begin{itemize}
\item $\forall$ p $\in$  PossibiliInitialState[$M_1$], $\exists$ q $\in$ PossibiliInitialState[$M_2$], (p,q) $\in$ S.
\item $\forall$ p $\in$  Stati[$M_1$], $\forall$ q $\in$ Stati[$M_2$].
\begin{itemize}
\item if (p,q) $\in$ S $\Rightarrow$ $\forall$ x $\in$ Input, $\forall$ y $\in$ Output, $\forall$ p1 $\in$  Stati[$M_1$];
\item if (p1,y) $\in$ PossibiliUpdates[$M_1$](p,x) $\Rightarrow$ $\exists$ q1 $\in$ Stati[$M_1$], (q1,y) $\in$ PossibiliUpdates[$M_2$](q,x) e (p1,q1) $\in$ S. (S contiene coppie di stati iniziali e coppie consultanti l'algoritmo).
\item $\forall$ p $\in$ Stati[$M_1$] $\exists$ q $\in$ Stati[$M_2$] per cui $\forall$ I/O possibili c'è corrispondenza tra I/O uguali di p e (p,q) $\in$ S. 
\end{itemize}
\end{itemize}
\subsection{Simulazione per Output-Det}Data M ASFND trova la macchina output-det det(M) equivalente a M.\\ SUBSET CONSTRUCTION 
\begin{itemize}
\item InitialState[det(M)] = PossibileInitialState[M]
\item States[det(M)]={InitialState[det(M)]}
\item Ripeti finché nuove transizioni possono essere aggiunte a det(M). Scegli
\begin{itemize}
\item P $\in$ States[det(M)] e (x,y) $\in$ Input x Output
\item Q = {q $\in$ States[M] | $\exists$ p $\in$ P, (q,y) $\in$ PossibleUpdates[M](p,x)}
Se Q $\ne$ 0 allora States[det(M)]= States[det(M)] $\cup$ {Q}\\
Update[det(M)](p,x)=(q,y)\\
Raggruppa tutti gli stati iniziali, $\forall$ coppia I/O raggruppa tutti gli stati per cui quest'ultima è Possibleupdate.
\end{itemize}
\end{itemize}
\subsection{Simulazione}
\begin{itemize}
\item Se p $\in$ PossibleInitialState[$M_1$] e PossibleInitialState[m2] = {q} $\Rightarrow$ (p,q) $\in$ S.
\item Se (p,q) $\in$ S e (p1,y) $\in$ PossibleUpdates[$M_1$](p,x) e PossibleUpdates[$M_2$](q,x) = {q}. 
\end{itemize}
\subsection{Bisimulazione per Det} Una relazione binaria B è una \emph{bisimulazione} sse:
\begin{itemize}
\item InitialState[$M_1$], InitialState[$M_2$] $\in$ B 
\item $\forall$ p $\in$ Stati[$M_1$], $\forall$ q $\in$ Stati[$M_2$]:
\begin{itemize}
\item if (p,q) $\in$ B $\Rightarrow$ $\forall$ x $\in$ Input[$M_1$], Output[$M_1$](p,x) = Output[$M_2$](q,x)\\
(nextState[$M_1$](p,x),nextState[$M_2$](q,x)) $\in$ B.
Stati iniziali di $M_1$ e $M_2$ sono in relazione e ogni coppia (p,q) relazionati, $\forall$ input producono lo stesso output e nextState Relazionati.
\end{itemize}
\end{itemize}

\section{LINGUAGGI}
\subsection{Il linguaggio K è \emph{controllabile}?}
Siano K e M = $\overline{M}$ linguaggi dell'alfabeto di eventi E, con E\textsubscript{uc} $\subseteq$ E. Si dice che K è controllabile rispetto a M e E\textsubscript{uc} se per tutte le stringhe s $\in$ $\overline{K}$ e per tutti gli eventi $\sigma$ $\in$ E\textsubscript{uc} si ha : \textbf{s$\sigma$ $\in$ M $\Rightarrow$ s$\sigma$ $\in$ $\overline{K}$}. (Equivalente a $\overline{K}$E\textsubscript{uc} $\cap$ M $\subseteq$ $\overline{K}$.)\\ Per la def di \emph{controllabilità} si ha che K è controllabile sse $\overline{K}$ è controllabile.
\subsection{Osservabilità}
Si considerino i linguaggi K e M = $\overline{M}$ definiti sull'alfabeto di eventi E, con E\textsubscript{c} $\subseteq$ E, E\textsubscript{c} $\subseteq$ E e P la proiezione naturale da E* $\Rightarrow$ E\textsubscript{0}*.\\ Si dice che K è osservabile rispetto a M, E\textsubscript{o},E\textsubscript{c} se per tutte le stringhe s $\in$ $\overline{K}$ e per tutti gli eventi $\sigma$ $\in$ E\textsubscript{c} abbiamo: 
\begin{center}(s$\sigma$ $\notin$ K) $\land$ (s$\sigma$ $\in$ M) $\Rightarrow$ $P^{-1}$[P(s)] $\sigma$  $\cap$ $\overline{K}$ = $\emptyset$
\end{center}
L'insieme di stringhe denotato dal termine $P^{-1}$[P(s)] $\sigma$  $\cap$ $\overline{K}$ contiene tutte le stringhe che hanno la medesiman proiezione di s e possono essere prolungate in K con il simbolo $\sigma$. SE tale insieme non è vuoto, allora K contiene due stringhe s e s' tali che P(s)=P(s') per cui s$\sigma$ $\notin$ $\overline{K}$ e s'$\sigma$ $\in$ $\overline{K}$. Tali due stringhe richiederebbero un'azione di controllo diversa rispetto a $\sigma$ (disabilitare $\sigma$ nel caso di s, abilitare $\sigma$ nel caso di s'), ma un supervisore non saprebbe distinguere tra s e s' per l'osservabilità ristretta. Non potrebbe quindi esistere un supervisore che ottiene esattamente il linguaggio $\overline{K}$.
\end{document} 
