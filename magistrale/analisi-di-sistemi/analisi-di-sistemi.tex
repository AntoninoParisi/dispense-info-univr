\documentclass[a4paper, 11pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{frontespizio}
\usepackage{hyperref}
\hypersetup{hidelinks,
	colorlinks = true,
	urlcolor = black, 
	linkcolor = black}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{stmaryrd}
\usepackage[strict]{changepage}
\usepackage{galois}
\usepackage{libertine}

\lstset{basicstyle=\ttfamily\small}

\newcommand{\parts}[1]{\mathcal{P}(#1)}
\newcommand{\galoistuple}{\langle C, \alpha, \gamma , A \rangle}

\newtheorem{definit}{Definizione}[subsection]
\newtheorem{thm}{Teorema}[subsection]


\begin{document}
	\begin{frontespizio}
		\Preambolo{\usepackage{datetime}}
		\Istituzione{Università degli Studi di Verona}
		\Divisione{Dipartimento di informatica}
		\Titolo{Analisi di Sistemi informatici}
		\Scuola{}
		\Sottotitolo{Riassunto dei principali argomenti}
		\Candidato{Davide Bianchi}
		\NCandidato{Autore}
		\Annoaccademico{2017/2018}
	\end{frontespizio}
	
	\tableofcontents
	\newpage


	\section{Preliminari matematici}
	\subsection{Ordini parziali}
	\subsection{Reticoli}
	\subsection{Teoremi di punto fisso}
	
	\section{Interpretazione astratta}
	\subsection{Introduzione}
	Lo scopo è quello di trovare un'approssimazione di una semantica $\langle P \rangle$ di $\llbracket P \rrbracket$ tale per cui valgano:
	\begin{itemize}
		\item \textit{correttezza:} $\llbracket P \rrbracket \subseteq \langle P \rangle$;
		\item \textit{decidibilità:} $\langle P \rangle \subseteq Q$ è decidibile ($Q$ è un insieme di semantiche che soddisfa la proprietà di interesse).
	\end{itemize}

	Se entrambe le proprietà sono soddisfatte, allora vale che \[ (\langle P \rangle \subseteq Q) \Rightarrow (\llbracket P \rrbracket \subseteq Q) \]
	
	La semantica è data da una coppia $\langle D, f \rangle$ dove $D$ è una coppia $\langle D, \leq_D$ rappresentante un dominio semantico e $f: D \to D$ è una funzione di trasferimento con una soluzione a punto fisso.
	
	Dato un oggetto concreto, definiamo:
	\begin{itemize}
		\item un \textbf{oggetto astratto} come una rappresentazione matematica sovra-approssimata del corrispondente concreto;
		\item un \textbf{dominio astratto} come un insieme di oggetti astratti con delle operazioni astratte, che approssimano quelle concrete;
		\item una funzione di \textbf{astrazione} $\alpha$ che mappa oggetti concreti in oggetti astratti;
		\item una funzione di \textbf{concretizzazione} $\gamma$ che mappa oggetti astratti in oggetti concreti.
	\end{itemize}
	
	La caratteristica peculiare delle astrazioni è che solo alcune proprietà vengono osservate con esattezza, le altre vengono solo approssimate. In sostanza, dato un dominio astratto $A$, gli elementi di $A$ sono osservati con esattezza, gli altri sono approssimati o l'informazione è persa del tutto.
	
	\paragraph{Proprietà.} L'insieme delle proprietà $\parts{\Sigma}$ di oggetti in $\Sigma$ è l'insieme di elementi che gode di quella proprietà. Questo insieme di proprietà costituisce un reticolo completo \[ \langle \parts{\Sigma}, \subseteq, \emptyset, \cup, \cap, \neg \rangle \] dove:
	\begin{itemize}
		\item $\subseteq$ è l'implicazione logica;
		\item $\Sigma$ è \verb|true|;
		\item $\cup$ è la disgiunzione (oggetti che godono di $P$ o di $Q$ appartengono a $P \cup Q$);
		\item $\cap$ è la congiunzione (oggetti che godono di $P$ e di $Q$ appartengono a $P \cap Q$);
		\item $\neg$ è la negazione (oggetti che non godono di $P$ stanno in $\Sigma \setminus P$).
	\end{itemize}

	\paragraph{Direzione dell'astrazione.}
	Quando si approssima una proprietà concreta $P \in \parts{\Sigma}$ usando una proprietà astratta $\overline{P}$, deve essere stabilito un criterio per definire quando $\overline{P}$ è un'approssimazione di $P$.
	
	Si distinguono quindi i seguenti casi:
	\begin{itemize}
		\item approssimazione \textit{da sopra}: $P \subseteq \overline{P}$;
		\item approssimazione \textit{da sotto}: $P \supseteq \overline{P}$.
	\end{itemize}
	
	Dato un oggetto $o$, si vuole quindi sapere se $o \in P$:
	\begin{align*}
		P \supseteq \overline{P}: \begin{cases}
			\text{"Si"} &o \in \overline{P} \\
			\text{"Non lo so"} &o \notin  \overline{P}
		\end{cases} \qquad
		P \subseteq \overline{P}: \begin{cases}
		\text{"No"} &o \notin \overline{P} \\
		\text{"Non lo so"} &o \in \overline{P}\\
		\end{cases}
	\end{align*} 
	
	\paragraph{Migliore approssimazione.}
	Definiamo come \textit{migliore approssimazione} di una proprietà $P$ in $A$ il glb delle over-approximation di $P$ in $A$, ossia: \[  \overline{P} = \bigcap \lbrace \overline{P'} \in A | P \subseteq \overline{P'} \rbrace \in A \]
	
	\subsection{Connessione di Galois}
	Imponiamo il vincolo che $\alpha$ e $\gamma$ siano monotone, allora concludiamo che: \begin{itemize}
		\item $\gamma \circ \alpha: C \to C$ è \textbf{estensiva}: $\gamma(\alpha(c)) \geq c$;
		\item $\alpha \circ \gamma : A \to A$ è \textbf{riduttiva}: $\alpha(\gamma(a)) \leq a$.
	\end{itemize}

	Le definizioni qui sopra dicono rispettivamente che:
	\begin{itemize}
		\item $\alpha$ perde informazione, e $\gamma$ non la può recuperare;
		\item $\gamma$ non perde informazione.
	\end{itemize}

	\begin{definit}[Connessione di Galois]
		Dati due poset $\langle A , \leq_A \rangle$ e $\langle C , \leq_C \rangle$, e due funzioni monotone $\alpha: C \to A$ e $\gamma: A \to C$, diciamo che $\galoistuple$ è una connessione di Galois se:
		\begin{itemize}
			\item $\forall c \in \mathcal{C}: c \leq_C \gamma(\alpha(c))$
			\item $\forall a \in \mathcal{A}: \alpha(\gamma(a)) \leq_A a$
		\end{itemize}
		
		Se inoltre vale che $\forall a \in \mathcal{A}: \alpha(\gamma(a)) = a$, allora $\galoistuple$ è un'inserzione di Galois.
	\end{definit}
	Una connessione e un'inserzione di Galois sono rappresentate rispettivamente come \[  C \galois{\alpha}{\gamma} A \qquad C \galoiS{\alpha}{\gamma} A \]
	La funzione $\alpha$ è detta \textit{aggiunta sinistra}, mentre la funzione $\gamma$ è detta \textit{aggiunta destra}.
	
	\begin{thm}
		Data una connessione di Galois $ C \galois{\alpha}{\gamma} A$, sono equivalenti:
		\begin{itemize}
			\item $C \galoiS{\alpha}{\gamma} A$;
			\item $\alpha$ è suriettiva;
			\item $\gamma$ è iniettiva.
		\end{itemize}
	\end{thm}

	Inoltre, dati due domini astratti, non esistono due coppie $(\alpha, \gamma)$ che formino una connessione di Galois; quindi la connessione di Galois tra due domini è \textbf{unica}, e le funzioni sono identificabili attraverso:
	\begin{align*}
		\alpha(c) &= \bigwedge \lbrace a \in A \vert c \leq_C \gamma(a) \rbrace \\
		\gamma(a) &= \bigvee \lbrace c \in C \vert \alpha(c) \leq_A a \rbrace
	\end{align*}
	
	\subsection{Famiglie di Moore}
	\begin{definit}[Famiglia di Moore]
		Sia $L$ un reticolo completo. $X \subseteq L$ è una famiglia di Moore di $L$ se \[ X = \mathcal{M}(X) = \Big\{ \bigwedge S\ \vert\ S \subseteq X \Big\} \] dove \[ \bigwedge \emptyset = \top \in \mathcal{M}(X) \]
	\end{definit}
	
	Da questa definizione segue che, ipotizzando che ogni proprietà concreta abbia una migliore astrazione $\overline{P} \in A$, implica che il dominio $A$ è una famiglia di Moore.
	
	\subsection{Upper closure operator}
	\begin{definit}[Upper closure operator]
		Una funzione $f:P \to P$ su un poset $\langle P, \leq_P \rangle $ è un upper closure operator (uco) se soddisfa le seguenti proprietà:\begin{itemize}
			\item estensività: $\forall x \in P: x \leq_P \rho(x)$
			\item monotonia: $\forall x,y \in P: (x \leq_P y) \Rightarrow (\rho(x) \leq_P \rho(y)$
			\item idempotenza: $\forall x \in P: \rho(x) = \rho(\rho(x))$
		\end{itemize}
	\end{definit}

	I lower closure operator sono definiti in modo duale, specificando che $\rho$ deve essere \textit{riduttiva}, ovvero che $\forall x \in P: x \geq_P \rho(x)$.
	
	\begin{thm}
		Data una connessione di Galois $C \galois{\alpha}{\gamma} A$ si ha che $\gamma \circ \alpha$ è un uco e $\alpha \circ \gamma $ è un lco.
	\end{thm}
	\begin{thm}
		$C \galoiS{\alpha}{\gamma} A$ se e solo se $A$ è isomorfo \footnote{Con isomorofismo si intendono reticoli con la stessa struttura.} ad una Moore family di $C$.
	\end{thm}
	\begin{thm}
		Sia $\rho \in uco(c)$. Allora $\forall A \simeq \rho(C)$ si ha che $\exists \alpha, \gamma : C \galoiS{\alpha}{\gamma} A$
	\end{thm}
	
	\subsection{Reticolo delle interpretazioni astratte}
	I vari domini astratti possono essere comparati sulla base della loro precisione. In generale si può dire che un dominio astratto $A_1$ è più preciso di $A_2$ (indicato attraverso $A_1 \sqsubseteq A_2$) quando \[ \forall a_2 \in A_2, \exists a_1 \in A_1 \quad \text{ tali che } \quad \gamma_1(a_1) = \gamma_2(a_2) \] ovvero quando \[ \gamma(A_2) \subseteq \gamma(A_1) \]
	
	Collegando agli uco, possiamo dire che \[ A_1 \sqsubseteq A_2 \Leftrightarrow \rho_1 \sqsubseteq \rho_2 \Leftrightarrow \rho_2(C) \subseteq \rho_1(C) \]
	
	\begin{definit}[Reticolo delle int. astratte]
		Se $C$ è un reticolo completo o un cpo, allora \[ \langle uco(C), \sqsubseteq, \sqcup, \sqcap, \lambda x.\top, \lambda x.x \rangle \] è un reticolo completo dove $\forall \rho, \eta \in uco(C), \{ \rho_i \}_{i \in I} \subseteq uco(C)$ e $x \in C$:\begin{itemize}
			\item $\rho \sqsubseteq \eta \Leftrightarrow \forall y \in C.\rho(y) \leq \eta(y) \Leftrightarrow \eta(C) \subseteq \rho(C)$
			
			\item $ \displaystyle \Big( \bigsqcap_{i \in I} \rho_i \Big)(x) = \bigwedge_{i \in I} \rho_i(x)$
			
			\item $ \displaystyle \Big( \bigsqcup_{i \in I} \rho_i \Big)(x) = x \Leftrightarrow \forall i \in I. \rho_i(x)=x$
			
			\item $\lambda x.\top, \lambda x.x$ sono rispettivamente top e bottom. 
		\end{itemize}
	\end{definit}

	\subsection{Computazioni astratte e concrete}
	\begin{definit}[Correttezza]
		Data un'inserzione di Galois $C \galoiS{\alpha}{\gamma} A$, una funzione concreta $f: C \to C$ e una funzione astratta $f^\sharp: A \to A$ diciamo che $f^\sharp$ è un'approssimazione corretta di $f$ se \[ \forall c \in C: \alpha(f(c)) \leq_A f^\sharp(\alpha(c)) \quad \text{backward} \] o equivalentemente \[ \forall a \in A: f(\gamma(a)) \leq_C \gamma(f^\sharp(a) \quad \text{forward} \]
	\end{definit}
	
	Rinforzando la definizione e imponendo uguaglianza si perde l'equivalenza delle due espressioni sopra. 
	\begin{definit}[Completezza]
		Data un'inserzione di Galois $C \galoiS{\alpha}{\gamma} A$, una funzione concreta $f: C \to C$ e una funzione astratta $f^\sharp: A \to A$ diciamo che $f^\sharp$ è: \begin{itemize}
			\item backward-completa per $f$ se  $\forall c \in C: \alpha(f(c)) = f^\sharp(\alpha(c))$
			\item forward-completa per $f$ se $\forall a \in A: f(\gamma(a)) = \gamma(f^\sharp(a)$
		\end{itemize}
	\end{definit}
	
	La definizione rappresenta una situazione ideale in cui non si ha perdita di precisione durante il calcolo astratto. Inoltre la backward-completezza lavora sull'astrazione dell'input delle operazioni, la forward-completezza sull'output.
	
	Le definizioni di completezza possono essere date anche usando gli uco: \begin{itemize}
		\item $\rho \in uco(C)$ è backward-completo per $f$ se $\rho \circ f = \rho \circ f \circ \rho$
		\item $\rho \in uco(C)$ è forward-completo per $f$ se $f \circ \rho = \rho \circ f \circ \rho$
	\end{itemize}

	Inoltre quando $\rho$ è sia backward che forward-completo allora vale che $\rho \circ f = f \circ \rho$.
	
	\begin{thm}
		Data $C \galoiS{\alpha}{\gamma} A$, una funzione concreta $f : C \to C$  e una funzione astratta $f^\sharp: A \to A$ allora  \[ \forall c \in C: \alpha(f(c)) \leq_A f^\sharp(\alpha(c)) \Leftrightarrow \alpha \circ f \circ \gamma \sqsubseteq f^\sharp \]
	\end{thm}

	\begin{definit}[Best correct approximation]
		Data $C \galoiS{\alpha}{\gamma} A$ e una funzione concreta $f : C \to C$ allora $\alpha \circ f \circ \gamma : A \to A$ è la best correct approximation di $f$ in $A$.
	\end{definit}

	\subsection{Accelerazione della convergenza}
	\subsubsection{Widening}
	Un widening \[ \nabla : P \times P \to P  \] su un poset $ \langle P, \leq_P \rangle $ è una funzione che soddisfa:
	\begin{itemize}
		\item $\forall x,y \in P : x \sqsubseteq (x \nabla y ) \wedge y \sqsubseteq (x \nabla y)$
		\item per ogni catena ascendente $x_0 \sqsubseteq x_1 \sqsubseteq ... \sqsubseteq x_n$ la catena definita come $y_0 = x_0, ..., y_{n+1} = y_n \nabla x_{n+1}$ non è strettamente crescente.
	\end{itemize}
	
	Dato che in interpretazione astratta è necessario garantire/accelerare la convergenza, viene usato il widening (che si sostituisce al least upper bound), dal momento che anche il calcolo astratto può divergere.
	Il risultato di un widening è un post-puntofisso  di $F^\nabla$, ovvero una sovra-approssimazione del punto fisso più piccolo di f $lfp^\sqsubseteq F$. 
	
	Ad esempio, il widening su intervalli funziona come segue:
	\begin{align*}
	\lbrack a, b \rbrack\ \nabla\ \lbrack c, d \rbrack = \lbrack e, f \rbrack \qquad \text{ tale che}
	\end{align*}
	
	\begin{align*}
	e = 
	\begin{cases}
	-\infty &\text{ se } c < a \\
	a &\text{ altrimenti}
	\end{cases}
	\text{ e } f = 
	\begin{cases}
	+\infty &\text{ se } b < d\\
	b &\text{ altrimenti }
	\end{cases}
	\end{align*}
	
	\subsubsection{Narrowing}
	Dato che il widening raggiunge un post-fixpoint, piuò capitare che si abbiano eccessive perdite di informazione, in questo caso viene usato il narrowing.
	
	\begin{definit}
		Il narrowing è una funzione $ \triangle : P \times P \to P$ tale che:
		\begin{itemize}
			\item $\forall x, y \in \mathcal{P}: y \leq x \implies y \leq x\ \triangle\ y \leq x$
			\item Per ogni catena discendente $x_0 \geq x_1 \geq ...$, la catena discendente $y_0=x_0, ..., y_{i+1} = y_i\ \triangle\ x_{i+1}$ non è strettamente decrescente.
		\end{itemize}
	\end{definit}

	Per gli intervalli il narrowing funziona come segue:
	\begin{align*}
	\lbrack a, b \rbrack\ \triangle\ \lbrack c, d \rbrack = \lbrack e, f \rbrack \qquad \text{ tale che}
	\end{align*}
	\begin{align*}
	e = 
	\begin{cases}
	c &\text{ se } a = -\infty \\
	a &\text{ altrimenti}
	\end{cases}
	\text{ e } f = 
	\begin{cases}
	d &\text{ se } b = +\infty\\
	b &\text{ altrimenti }
	\end{cases}
	\end{align*}
	
	\subsection{Linguaggio e semantica}
	Introduciamo in questa sezione il linguaggio che verrà usato nel resto della dispensa e la sua semantica.
	\begin{center}
			\begin{tabular}{cc}
			\hline
			\textbf{Statement} & \textbf{Codice} \\
			\hline
			\hline
			Variabili & \lstinline|x| \\
			Espressioni aritmetiche & \lstinline|e| \\
			Assegnamenti & \lstinline|x <- e| \\
			Lettura da memoria & \lstinline|x <- M[e]| \\
			Scrittura in memoria & \lstinline|M[e]|$_1$ \lstinline|<-e|$_2$ \\
			Condizionali & \lstinline|if (e) S|$_1$ \lstinline|else S|$_2$ \\
			Salto incondizionato & \lstinline|goto L|\\
			\hline
		\end{tabular}
	\end{center}

	La memoria $M$ è vista come un array arbitrariamente lungo dove i valori possono essere inseriti e letti successivamente.
	
	Ogni passo di computazione della semantica operazionale trasforma stati del programma $(\rho, \mu)$ dove $\rho: Var \to int$ e $\mu : \mathbb{N} \to int$. La funzione $\rho$ mappa variabili di programma al loro valore attuale, mentre la funzione $\mu$ mappa ogni cella dell'array al suo contenuto.

	
	
	
	
	
	
	
	
	
	
	
	
	
\end{document}