\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{libertine}
\usepackage{frontespizio}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[left=1.5cm, right=1.5cm, top=3cm]{geometry}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{booktabs}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes,positioning,calc}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{arrows.meta}
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
	hidelinks, 
	colorlinks = true,
	linkcolor = black,
}
\usepackage{listings}
\lstset{
	language=C++,
	basicstyle=\ttfamily ,%\normalfont
	tabsize=4,
	showstringspaces=false,
	keywordstyle=\color{black}\bfseries,
	morekeywords={b_transport, sc_module, SC_CTOR, SC_METHOD,SC_THREAD,SC_CTHREAD},
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\chead{}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\usepackage{array}
\usepackage{makecell}

\theoremstyle{definition}
\newtheorem{dfn}{Definizione}[]

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}


\tikzstyle{rect} = [rectangle, 
rounded corners, minimum width=1cm, minimum height=1cm,text centered, draw=black]

\tikzset{
	recta/.style={%
		draw,%  
		line width=.4pt,
		rounded corners,                 
		rectangle split,
		rectangle split parts=2,
		rectangle split,
		rectangle split part fill={#1,none},
		every text node part/.style={font=\bfseries},
	} 
}

\newcommand{\tabb}[4]{
	\node[recta=#2, align=left] (#3) at (#1) {\rotatebox{360}{#3}\nodepart{two}#4};
	\begin{pgfonlayer}{background}
		\fill[#2!30, rounded corners] (a.south west) rectangle (a.north east);
	\end{pgfonlayer}
}

\title{Progettazione di Sistemi Embedded}
\date{}

\begin{document}
	\begin{frontespizio}
		\Universita{Verona}
		\Dipartimento{Informatica}
		\Scuola{Laurea Magistrale in Ingegneria e Scienze Informatiche}
		\Titoletto{}
		\Titolo{PSE}
		\Sottotitolo{Progettazione di Sistemi Embedded\\
			riassunto dei principali argomenti}
		\Candidato[VR424987]{Danzi Matteo}
		\Annoaccademico{2017/2018}
		\NCandidato{Autore}
	\end{frontespizio}

	\tableofcontents
	
	\newpage
	
	\section{Sistemi Embedded - Introduzione}
		\textbf{Definizione:} Sistema di Elaborazione specializzato, integrato in un dispositivo fisico in modo tale da controllarne le funzioni tramite un apposito programma SW dedicato.

	\subsection{Storia}
		\begin{itemize}
			\item \textbf{Computer ('60 - '80)}: sistemi general purpose.
			\item \textbf{Sistemi di controllo digitale ('80 - '90)}: dedicati al controllo e automazione.
			\item \textbf{Sistemi distribuiti ('90 - '00)}: sistemi general purpose e/o dedicati che cooperano attraverso la rete.
			\item \textbf{Sistemi Embedded ('00 -)}: sistemi distribuiti integrati in oggetti non computazionali e nell'ambiente fisico.
			\item \textbf{Sistemi Ciber-fisici ('10 -)}: sistemi embedded integrati con processi fisici.
		\end{itemize}
	
	\subsection{Smart System}
		\textbf{Definizione:} Sistema Embedded, integrato in una componente nel silicio, che controlla il mondo fisico. Uno smart system ha le seguenti caratteristiche:
		\begin{itemize}
			\item Miniaturizzato - Autosufficiente (autonomo dal p.d.v. energetico)
			\item Incorpora funzioni di sensore, attuatore, controllore
			\item Descrive, analizza situazioni, prende decisioni in base ai dati raccolti.
			\item Ha un comportamento predittivo e attuativo.
		\end{itemize}
		
		\noindent
		\textbf{Pretective Maintenance:} consiste nel riempire la catena di produzione con sensori che controllano e monitorano, cercando di prevenire e predirre guasti in base ai dati rilevati.
		
	\section{Come progettare}
		Per progettare un S.E. non si seguono le stesse direttive e gli stessi principi con cui si progettano sistemi distribuiti general purpose. Ad esempio per quest'ultimi si tende a costruire CPU sempre più veloci, mentre nei sistemi embedded la CPU esiste come mezzo di implementazione di algoritmi di controllo che comunicano con sensori e attuatori. 
		
	\subsection{Vincoli di progettazione}
		Durante la progettazione di S.E. ci sono i seguenti vincoli:
		\begin{itemize}
			\item Dimensioni: hand-held electronics (alla portata di mano).
			\item Peso, potenza: utilizzo di batterie anziché corrente. 
			\item Budget.
			\item Resistenza del sistema alle condizioni avverse in cui deve operare.
		\end{itemize}
		Nella progettazione sono da unire le proprietà di \textbf{Calcolo, Controllo, Comunicazione}.
		
	\section{Modellazione di Sistemi Embedded}
		I sistemi elettronici consistono di:
		\begin{itemize}
			\item Piattaforma HW: board di sviluppo;
			\item Strati di applicazioni SW: in nessun contesto posso permettermi di progettare software da zero, devo riusare parti di software progettate da altri possibilmente opensource;
			\item Interfacce;
			\item Componenti analogiche: hano fatto la differenza tra la potenza di calcolo di smartphone della vecchia generazione e quelli di adesso che sono equipaggiati con componenti come accelerometro, riconoscimento impronte, giroscopio ecc.;
			\item Sensori e trasduttori.
		\end{itemize}
		
		\noindent
		Principalmente si tende a spostare tutta l'elaborazione da analogica a digitale, inoltre si vuole una più ampia integrazione a livello di sistema per supportare l'approccio System-On-a-Chip (SOC). Questo approccio consiste nell'integrare in un chip tutto ciò che normalmente si vede in una board di un componente hardware. Il downside di questo approccio è rappresentato dal fatto che una volta effettuata l'integrazione sul chip non si può più cambiare il componente.
		 
	
	\subsection{Sfide nella progettazione di sistemi embedded}
		\begin{itemize}
			\item Aumentare la complessità delle applicazioni anche in prodotti standard e di grandi dimensioni
			\item Aumentare la complessità dei sistemi target
		\end{itemize}
		
	\section{Co-design di Hardware/Software }
		Consiste nella progettazione combinata della parte hardware e della parte software.
		Gli obiettivi principali del codesign sono:
		\begin{itemize}
			\item Ottimizzazione del processo di progettazione: aumento della produttività
			\item Ottimizzazione del design: aumento della qualità del prodotto
		\end{itemize}
		
		\begin{center}
			\begin{tikzpicture}
				\node(a) at (0,0) {\textbf{co-design}};
				\node(b) at (-.5,-2) {\textbf{HW}};  \node(c) at (.5,-2) {\textbf{SW}};
				\draw (a.south) -- (0,-1.5) -- (b.north);  
				\draw (0,-1.5) -- (c.north); 
				\node(a1) at (3,0) {\textbf{classic design}};
				\node(b1) at (2.5,-2) {\textbf{HW}};  \node(c1) at (3.5,-2) {\textbf{SW}};
				\draw (a1.south) -- (2.5,-.5) -- (b1.north);  
				\draw (a1.south) -- (3.5,-.5) -- (c1.north);
			\end{tikzpicture}
		\end{center}
		\bigskip
		
		\noindent
		I compiti del co-design sono:
		\begin{itemize}
			\item co-specification e co-modeling
			\item co-verification
			\item co-design process integration e ottimizzazione
			\item design optimization e co-synthesis
		\end{itemize}
	
	\subsection{Vantaggi del co-design}
		\begin{itemize}
			\item Permette di esplorare diverse alternative di progettazione nello spazio di progettazione architetturale.
			\item Permette di adattare l'Hardware al Software e viceversa.
			\item Riduce il tempo di progettazione del sistema.
			\item Supporta una coerente specifica del progetto a livello del sistema.
			\item Facilita il riuso delle parti HW e SW.
			\item Permette di provvedere di un ambiente integrate per la sintesi e la validazione delle componenti HW e SW.
		\end{itemize}
		
	\subsection{Co-design di sistemi embedded}
		Co-progettazione, realizzare un sistema embedded portando avanti il più possibile in contemporanea la sua progettazione hw e sw.
		
		\noindent
		Abbiamo un minor spreco di tempo, è più semplice passare da una descrizione hw a una sw (più facile scegliere cosa diventerà hw e cosa sw), rende più agevolato il riuso di parti sw e hw e rende possibile la co-validazione e la co-simulazione.
		
		\noindent
		Progettazione dedicata di parti HW può comprendere:
		\begin{itemize}
			\item Diversi stili di progettazione: co-processori, embedded core, Application Specific Instruction Processor (ASIP).
			\item Una scala di progettazione ampiamente variabile.
		\end{itemize}
		
		\noindent
		Progettazione dedicata di parti SW può comprendere:
		\begin{itemize}
			\item Sistemi operativi specializzati (special-purpose).
			\item Dirver di dispositivi periferici.
		\end{itemize}
		
		\begin{center}
			\begin{tikzpicture}[scale=2, >=latex]
				\draw (0,0) rectangle (4,-4);
				\draw (2,-2) circle (2cm);
				\node[anchor=south west] at (0,-4) {\textbf{Environment}};
				\node at (2,-0.3) {\textbf{Embedded System}};
				\node[rect, align=center] (a) at (2,-2.5) {\textbf{Hardwired Unit}\\\small Application-specific logic\\ Timers\\A/D and D/A Converters};
				\node[rect, rotate=90] (b) at (0.5,-2) {\textbf{Sensors}};
				\node[rect] (c) at (1.5,-1.25) {\textbf{Memory}};
				\node[rect] (d) at (2.5,-1.25) {\textbf{ISP}};
				\node[rect, rotate=90] (e) at (3.5,-2) {\textbf{Actuators}};
				
				\draw[->] ($ (a.east) +(0,-0.25) $) -- +(0.25,0)  -- (e.west); 
				\draw[->] (b.west) -- ($ (b.west) +(0,-0.25) $) -- ($ (a.west) +(0,-0.15) $);
				\draw[->] ($ (a.north) +(-0.35,0) $) -- ($ (c.south) +(.1,0) $);
				\draw[->] ($ (c.south) +(-0.15,0) $) -- ($ (a.north) +(-0.65,0) $);
				\draw[->] ($ (a.north) +(0.65,0) $) -- ($ (d.south) +(.1,0) $);
				\draw[->] ($ (d.south) +(-0.1,0) $) -- ($ (a.north) +(0.45,0) $);
				\draw[->] ($ (c.east) +(0,0.15) $) -- ($ (d.west) +(0,0.15) $);
				\draw[->] ($ (d.west) +(0,-0.15) $) -- ($ (c.east) +(0,-0.15) $);
				\draw[->] (0,-2) -- (b.north);
				\draw[->] (e.south) -- (4,-2);
			\end{tikzpicture}
		\end{center}
		
	\subsection{Array-based design (design basto su array)}
		ci sono due tipi di dispositivi che si possono progettare con questa tecnica di progettazione:
		\begin{itemize}
			\item \textbf{MPGA}: Pre-Diffused Array o più comunemente Mask Programmable Gate Array.
			\item \textbf{FPGA}: Pre-wired Array o più comunemente Field Programmable Gate Array. Sono dispositivi HW (circuito integrato digitale) generici che possono essere programmati con SW dedicato/specifico.
		\end{itemize}
		
	\subsection{Flusso di co-progettazione}
		\begin{enumerate}
			\item Modellazione, validazione e sintesi: simulazione a livello di sistema.
			\item Modellazione omogenea:
			\begin{enumerate}
				\item Partizionamento HW/SW
				\item Spostamento HW/SW o SW/HW
			\end{enumerate}
			\item Modellazione eterogenea: implementazione diretta e reindirizzamento
			\item Co-sintesi
			\begin{enumerate}[resume]
				\item Sintesi HW e dell'interfaccia
				\item Compilazione del SW e generazione del codice
			\end{enumerate}
			\item Co-simulazione
		\end{enumerate}
		
		\begin{center}
			\begin{tikzpicture}[>=latex]
				\node[rect] (a) at (0,0) {Definizione dei requisiti};
				\node[rect] (b) at (0,-1.5) {Specifica};
				\node[rect] (c) at (0,-3) {Sviluppo dell'architettura del sistema};
				\node[rect,align=left] (d) at (-6,-6) {\textbf{Sviluppo SW}\\applicaz. SW\\compilatori\\sist. operativo};
				\node[rect,align=left] (e) at (0,-6) {\textbf{Progettaz interfaccia}\\Drivers SW del disp.\\sintesi dell'interfaccia HW};
				\node[rect,align=left] (f) at (6.5,-6) {\textbf{Progettaz HW}\\Progettaz. arch. HW\\sintesi HW\\progettaz. fisica};
				\node[rect] (g) at (0,-8) {Integrazione e testing};
				\node (A) [cylinder, shape border rotate=90, draw,minimum height=1cm,minimum width=.7cm] at (6.5,-9)
				{};
				\node[yshift=-.5cm] at (A.south) {reused components};
				
				\draw[->] (a.south) -- (b.north); \draw[->] (b.south) -- (c.north);
				\draw[->] (c.south) -- (d.north); \draw[->] (c.south) -- (e.north);
				\draw[->] (c.south) -- (f.north); \draw[->] (d.south) -- (g.west);
				\draw[->] (e.south) -- (g.north); \draw[->] (f.south) -- (g.east);
				\draw[->] (g.south) -- +(0,-.5) -- (A.west);
				\draw[->] ($ (A.north) +(0.,.4) $) -- +(0,.4); \draw[->] ($ (A.north) +(-.4,.2) $) -- +(-.4,.4);
			\end{tikzpicture}
		\end{center}
		
	\section{Requisiti per un sistema embedded}
	Un sistema embedded deve essere:
	\begin{itemize}
		\item \textbf{REATTIVO}: Non fermarsi mai ed essere sempre pronto a rispondere a segnali provenienti dall'ambiente esterno.
		\item \textbf{REAL TIME}: Rispettare vincoli temporali (HRT, SRT, FRT).
	\end{itemize}
	
	
	\section{Time to market}
		Tempo che intercorre da quando un prodotto viene ideato a quando viene commercializzato, messo sul mercato per la prima volta.


	\section{Platform-based design (Progettazione basata sulla piattaforma)}
		La filosofia platform-based consiste nel progettare architetture HW (piattaforme) stabili, basate su microprocessore, che possano essere facilmente espanse a livello di componenti HW e che sono configurabili a livello SW; quindi sono piattaforme che nonostante abbiano componenti hw ben definite rimangono "a scopo generico" per la loro facile espansibilità, sia HW che SW.

		
		\begin{itemize}
			\item Dispositivi con gradi di configurabilità (? SW ?)
			\item Posso usare lo stesso oggetto per più applicazioni 
			\item ASIC
			\item FPGA 
		\end{itemize}
	
	Concetti principali a Livello di Sistema:
	
	Concorrenza, Gerarchia dei moduli, Comunicazione tra sottosistemi, Sincronizzazione.
	
	\section{SystemC}
		SystemC è una libreria che estende il linguaggio di programmazione C++, linguaggio strettamente SW.
		\bigskip
		
		\noindent
		Permette di fornire una descrizione del sistema a diversi livelli di astrazione: un livello più vicino all'HW, in cui si definiscono i dettagli implementativi come porte, segnali e interfacce (RTL) e un livello in cui si definisce uno standard per la comunicazione tra i moduli e ci si concentra sulla funzionalità (TLM).
		\bigskip
		
		\noindent
		Tali astrazioni rendono possibile fare co-design, cioè una co-progettazione del sistema in cui si cerca di portare avanti il più possibile in parallelo la progettazione hw e quella sw; il co-design diminuisce il tempo di progettazione, rende più facile il passaggio da una componente hw a una sw (quindi la scelta di quale componente implementare come hw e quale come sw) e permette una co-simulazione e una co-validazione.
	\begin{itemize}
		\item Permette di fare co-design.
		\item Diversi livelli di astrazione (RTL-TLM).
		\item Linguaggio di definizione dell'hardware (HDL).
		\item Fornisce una descrizione hw a livello RT (RTL), dove ho un controllo sui segnali, sui registri e sugli operatori utilizzati. Descrivo un sistema con una FSMD.
		\item Le sue caratteristiche permettono di gestire gli aspetti più importanti per un sistema embedded -> gerarchizzazione dei moduli, concorrenza (processi sync/async), comunicazione (porte/segnali), timing (clock/fasi/tempo), reattività (eventi), tipi di dato hw (oltre ai tipi c++), kernel di simulazione, debug (c++).
		\item Ha introdotto una standardizzazione del modello transazionale (modo in cui si definiscono le transazioni tra moduli) attraverso il livello di astrazione TLM.
		\item Riuso di moduli/componenti già pronti messi in comunicazione grazie allo standard per le transazioni definito da SystemC.
	\end{itemize}
	
	\section{SystemC RTL}
		Con SystemC RTL (Register Transfer Level) è possibile descrivere il funzionamento di un circuito digitale in termini di segnali, elementi di memoria dei segnali (registri) e di operazioni logiche tra segnali.
		
		\subsection{Moduli}
			I moduli sono i blocchi di costruzione di base per partizionare un design. Sono classi C++, permettono di partizionare sistemi complessi in componenti più piccole. Nascondono la rappresentazione dei dati interni, utilizzano interfacce. Contengono porte, segnali, dati locali, altri moduli, processi, costruttori e distruttori. Segue un esempio:
		
			\begin{lstlisting}[mathescape, frame=tb, caption={module}]
sc_module(module_name)
{
	// dichiarazione di porte
	// dichiarazione di segnali
	// costruttore del modulo: SC_CTOR
	//		SC_METHOD
	// creazione di sottomoduli e sensitivity list
	// inizializzazione dei segnali
}
			\end{lstlisting}
	
		\noindent
		Il costruttore del modulo:
		\begin{itemize}
			\item Inizializza e dichiara tutti i processi contenuti nel modulo e le regole per attivarli
			\item Inizializza le variabili ai valori di default oppure a valori definiti dall'utente.
		\end{itemize}
		
		\begin{lstlisting}[mathescape, frame=tb, caption={full adder constructor}]
SC_CTOR( FullAdder )
{
	SC_METHOD( doIt );
		sensitive << A;
		sensitive << B;
}
		\end{lstlisting}
		
		\subsection{Processi}
			I processi sono funzioni he sono identificate dal kernel di SystemC:
			\begin{itemize}
				\item I processi sono molto simili a funzioni C++ o metodi
				\item I processi implementano le funzionalità dei moduli
				\item Sono chiamate se un segnale della sensitivity list cambia il suo valore.
			\end{itemize}
			
			\noindent
			I processi possono essere \textbf{Metodi}, \textbf{Threads} o \textbf{CThreads (deprecated)}.
			
			\begin{multicols}{2}
				\begin{itemize}
				\item \textbf{Metodi}: 
				\begin{itemize}
					\item Quando attivati, vengono eseguiti e ritornano. 
					\item \lstinline|SC_METHOD(process_name)|.
				\end{itemize}
				\item \textbf{Threads}: 
				\begin{itemize}
					\item Possono essere sospese a riattivate. 
					\item La funzione \lstinline|wait()| sospende.
					\item Un evento sulla sensitivity list riattiva.
					\item \lstinline|SC_THREAD(process_name)|
				\end{itemize}
				\columnbreak
				\item \textbf{CThreads (DEPRECATED)}:
				\begin{itemize}
					\item Sono attivate all'incremento del clock
					\item \lstinline[basicstyle=\small\ttfamily]|SC_CTHREAD(process_name, clock_value)|
				\end{itemize}
			\end{itemize}
			\end{multicols}
			
			\begin{table}
				\begin{tabular}{cccc}
					\toprule
					\textbf{type} & \lstinline|SC_METHOD| & \lstinline|SC_THREAD| & \lstinline|SC_CHTREAD| \\
					\midrule
					Attivaz. all'exec. & Evento & Evento & Incremento clock \\
					Sosp. dall'exec. & No & Sì & Sì \\
					Loop infinito & No & Sì & Sì\\
					sosp/riattiv da & n.d. & \lstinline|wait()| &  \lstinline|wait()| o \lstinline|until()| \\
					\makecell{Costruttore e\\ sensitivity def} & \makecell{\lstinline|SC_METHOD(call_back);|\\
						\lstinline|sensitive(signals);|\\
						\lstinline|sensitive_pos(signals);|\\
						\lstinline|sensitive_neg(signals);|} &
						\makecell{\lstinline|SC_THREAD(call_back);|\\
							\lstinline|sensitive(signals);|\\
							\lstinline|sensitive_pos(signals);|\\
							\lstinline|sensitive_neg(signals);|} & \lstinline|SC_CTHREAD(...)| \\
					\bottomrule
				\end{tabular}
				\caption{Tabella riassuntiva}
			\end{table}
			
	
	\section{SystemC TLM}
		SystemC TLM (Transaction Level Modeling) è una libreria del C++ che permette di rappresentare i principali componenti architetturali di piattaforme hardware. 
		
		È uno standard per la comunicazione tra i moduli (sia HW che SW) di un sistema, attraverso transazioni con caratteristiche ben definite. L'aver definito uno standard per il modo in cui si interfacciano diverse componenti ha facilitato il riuso dei componenti, cioè la possibilità di integrare facilmente nel proprio sistema moduli provenienti da fonti esterne e di interfacciarli tra loro semplicemente conoscendo le specifiche del protocollo di comunicazione.
		
		Il riuso dei componenti porta a grandi vantaggi anche nel cercare di diminuire il TTM, infatti posso risparmiare del tempo utilizzando componenti già implementate, di cui conosco le prestazioni e sono sicuro del loro funzionamento, piuttosto che ricrearle da zero e cercare di interfacciarle col mio sistema ad un livello più basso di astrazione.
		
		(Con TLM è inoltre possibile fornire velocemente una descrizione SW del comportamento, in modo da poter proporre ad un eventuale cliente un primo prototipo del sistema con tempistiche brevi.)
		
		\begin{itemize}
			\item Permette una esplorazione architetturale e modellazione delle performance.
			\item Consente l'esecuzione su modelli virtuali di piattaforme hardware.
			\item È disponibile prima dell'RTL.
			\item Viene simulato più velocemente dell'RTL.
			\item Consente di modellare sistemi a livello transazionale.
		\end{itemize}
		
		\subsection{Transazione TLM}
			TLM si basa sul concetto di \textbf{transazione} cioè il trasferimento di dati tra moduli che comprende operazioni di scrittura/lettura. 
			
			\noindent
			La transazione è rappresentata da un oggetto \textbf{payload}: viene scambiato con chiamate primitive, contiene sia dati che informazioni di controllo.
			
			\noindent
			Gli attori della transazione sono:
			\begin{itemize}
				\item \textbf{Initiator}: fa partire la transazione tramite socket
				\begin{itemize}
					\item Crea un oggetto transazione.
					\item Chiama o si connette con il metodo target per inviare il payload.
				\end{itemize}
				\item \textbf{Target}: agisce come destinazione finale della transazione. Elabora il payload.
			\end{itemize}
	
			\noindent
			È un tipico comportamento master/slave:
			\bigskip
			
			\begin{center}
				\begin{tikzpicture}[>=latex]
					\node[rect] (a) {Initiator};
					\node[rect] (b) at (4,0) {Target};
					\draw[<->] (a.east) -- (b.west) node[midway, below] {payload};
					\draw[->, ultra thick] ($ (a.east) +(.5,.5) $) -- ($ (b.west) +(-.5,.5) $);
				\end{tikzpicture}
			\end{center}
			
		\subsection{Cammini di transazione}
			Il payload può seguire due diversi path:
			\begin{itemize}
				\item \textbf{Forward Path}: percorso di chiamata dall'initiator nella direzione del target. Il master chiama lo slave.
				\item \textbf{Backward Path}: percorso di chiamata attraverso cui il target ritorna indietro il payload nella direzione dell'initiator. Lo slave risponde al master.
			\end{itemize}
		
			\begin{center}
				\begin{tikzpicture}[>=latex]
				\node[rect] (a) {Initiator};
				\node[rect] (b) at (4,0) {Target};
				\draw[->, ultra thick] ($ (a.east) +(.2,0) $) -- +(0,.5) -- node[above] {forward path} ($ (b.west) +(-.2,.5) $)   -- ($ (b.west) -(.2,0) $);
				\draw[->, ultra thick] ($ (b.west) -(.2,0) $) -- ($ (b.west) +(-.2,-.5) $) -- node[below] {backward path} ($ (a.east) +(.2,-.5) $) -- +(0,.5);
				\end{tikzpicture}
			\end{center}
			
		\subsection{Stili di programmazione TLM}
			In TLM 2.0 non ci sono livelli di astrazione standardizzati, come avveniva in TLM 1.0:
			\begin{itemize}
				\item Program View (PV)
				\item Program View with Time (PVT)
				\item Cycle Accurate (CA)
			\end{itemize}
			Questi livelli possono essere usati per esprimere diverse astrazioni dello stesso sistema.
			
			\noindent
			In TLM 2.0 si è deeciso di standardizzare come il tempo e i dati sono collegati:
			\begin{itemize}
				\item \textbf{Untimed (UT)}: senza tempo. 
					\begin{itemize}
						\item Interfaccia bloccante. 
						\item Punti di sincronizzazione predefiniti.
					\end{itemize}
				\item \textbf{Loosely Timed (LT)}:
					\begin{itemize}
						\item Interfaccia bloccante.
						\item Due punti di sincronizzazione (invocazione e return).
						\item Temporal Decoupling
					\end{itemize}
				\item \textbf{Approximately Timed (AT4)}: si dettaglia maggiormente il sincronismo tra Initiator e Target
					\begin{itemize}
						\item Interfaccia transport non bloccante
						\item Annotazione del tempo e fasi multiple durante il tempo di vita della transazione.
						\item Protocollo 4-handshaking: inizio/fine richiesta, inizio/fine risposta.
					\end{itemize}
			\end{itemize}
			
			\textbf{UT} è il livello più alto, \textbf{AT} è il livello più basso. 
			
			La comunicazione tra master e slave può essere \textit{bloccante} (master rimane in attesa finché lo slave non ha finito i calcoli) o \textit{non bloccante} (il master passa i dati allo slave ma può andare comunque avanti), in questo modo si può decidere il livello di parallelismo del software. Possono esserci componenti di interconnessione tra initiator e target, e servono per modellare bus astratti.
			
			\noindent
			Se aumento i punti di sincronizzazione (arrivando a sincronizzare ogni ciclo di clock) posso arrivare ad avere una sincronizzazione cycle accurate. 
			
		\subsection*{Temporal decoupling}
		Initiator e target quando si sono de-sincronizzati possono andare avanti con tempi diversi e sono poi riallineati nel momento in cui si sincronizzano (comunicazioni non bloccanti), il più veloce aspetterà il più lento e si sincronizza.  Il T.D. permette ai due moduli di evolvere insieme senza sincronizzarsi, rendendo più veloce la simulazione.
		
		\subsection{Interfaccia bloccante}
			Questa interfaccia è supportata da UT e LT. L'initiator completa la transazione con il target in una chiamata a funzione. Ci sono 2 punti di sincronizzazione: l'invocazione e il return. Utilizza solamente il \textbf{forward path}.
			
			\begin{center}
				\begin{tikzpicture}[>=latex]
					\draw (-1.5,0) rectangle (8,-6);
					\node[anchor=south east] at (8,0) {Initiator};
					\draw (10,0) rectangle (16,-6);
					\node[anchor=south west] at (10,0) {Target};
					
					\tabb{3.5,-2.5}{white}{true}{Impostazione dei dati da inviare:\\ payload e tempo;\\\lstinline|b_transport(payload, time);|};
					\tabb{3.5,-4.5}{white}{socket-event}{elaborazione dati ricevuti;};
					
					\node[rect] (b) at (13,-3) {
						\begin{lstlisting}[basicstyle=\small\ttfamily]
b_transport(payload, time) {
	riceve payload;
	setta il tempo;
	esegue funz;
	setta il payload
	per ritornare i dati;
}
						\end{lstlisting}};
					\node[draw, circle] (A) at (-.5,-2) {A};
					\node[draw, circle] (B) at (7.5,-4) {B};
					\node[draw, circle] (C) at (-.5,-4.5) {C};
					
					\draw[<->, ultra thick] (true.east) -- (b.west) node[midway, above] {socket};
					\draw[->, bend left] (A.east) to (true.west);
					\draw[->, bend left] (true.east) to (B.north);
					\draw[->, bend left] (B.south) to (socket-event.east);
					\draw[->] (socket-event.west) -- (C.east);
				\end{tikzpicture}
			\end{center}
			
	\subsection{Interfaccia non bloccante}
		Questa interfaccia è supportata da AT4. Permette di dettagliare la sequenza di interazioni tra l'initiator e il target. È formata da due fasi:
		\begin{enumerate}
			\item Inizio/fine richiesta
			\item Inizio/fine risposta.
		\end{enumerate}
		Utilizza sia il forward che il backward path. Utilizza il classico protocollo di handshaking a 4 fasi.
			
	\subsection{Transactor TLM: (transattore)}
	
	\begin{itemize}
		\item Modulo systemC che permette di far comunicare modelli a diversi livelli di astrazione (Es. RTL-TLM).
		\item Utile perché posso raffinare singolarmente prima i componenti e poi farli comunicare col transattore.
		\item Diversi livelli di astrazione: PV, PVT, AC.
		\item In PVT nel momento in cui devo temporizzare (non rispettando precisamente i cicli di clock) la comunicazione devo passare attraverso un bus (sia per moduli HW che SW) come AMBA (adottato da ARM).
		\item In PVT posso già decidere cosa far diventare HW (moduli che impiegano più tempo per essere calcolati) e cosa SW, e analizzare il traffico sul bus per unire per esempio moduli che hanno un alto traffico tra loro. 
		\item In CA ho sempre bisogno di un bus ma che rispetti esattamente i cicli di clock.
	\end{itemize}
	
	
	\subsection{Standard TLM 2.0}
	
	\begin{itemize}
		\item Non ha senso standardizzare i livelli di astrazione. Si è passati da livelli di astrazione diversi a stili di codifica (LT e AT), lasciando al progettista la possibilità di decidere che tipo di flusso di progettazione seguire.
		\item La comunicazione avviene con un campo (payload) ben definito e standardizzato.
		\item TLM standardizza la comunicazione e non la funzionalità.
		\item \textbf{Initiator} fa partire la transazione, \textbf{Target} riceve la transazione (tramite socket)
		\item I cammini di transazione sono forward path e backward path
		\item Coding style NON sono specifici livelli di astrazione.
		\item Si possono definire coding style propri, ma potrei non riuscire a far comunicare moduli.
		\item In ogni transazione LT ci sono 2 punti di sincronizzazione (inizio e fine) e non ci sono molte informazioni sugli aspetti temporali.
		\item I processi hanno assegnati dei quanti di simulazione.
		\item Si spezza la sincronizzazione in più fasi, avendo più punti di sincronismo
		\item Per avere un modello UT prendo un modello LT e metto il tempo a 0.
		\item Per LT e AT4 si definiscono delle interfacce: bloccante (UT e LT) e non bloccante (AT4).
		\item Un altra interfaccia è la \textbf{DMI} usata per accedere ad aree di memoria condivisa tra Initiator e Target e modificarne i dati permette di far comunicare codici SystemC con codici di altri linguaggi (co-simulazione).
	\end{itemize}

	\section{SystemC AMS}
		È una estensione del SystemC, permette la modellazione System-lever per sistemi con segnali analogici misti (Analog Mixed-Signal Systems). 
		
		\noindent
		Metodologie e casi d'uso per sistemi con segnali mixed:
		\begin{itemize}
			\item Specifiche eseguibili: verificare la correttezza dei requisiti del sistema utilizzando la simulazione.
			\item Prototipizzazione virtuale: modello ad alto livello (untimed/timed) dell'architettura hardware.
			\item Esplorazione di architetture: valutazione del mapping tra il comportamento e l'architettura di sistema.
			\item Validazione euristica integrata: verificare la correttezza delle componenti integrate.
		\end{itemize}
		
		\subsection{Tempo discreto} 
		Nelle descrizioni a tempo discreto:
		\begin{itemize}
			\item La funzione esiste solo in punti ben precisi nel tempo, negli altri non esiste e non posso valutarla
			è come se scrivessi una procedura. I segnali e le quantità fisiche sono definiti in punti di tempo discreti. Si assumono costanti in mezzo a questi punti.
			\item Vengono usate per rappresentare approssimazioni di rappresentazioni a tempo continuo, 
			signal processing: rappresentazione di funzioni di elaborazioni di segnali ( tipo filtri )
		\end{itemize}
		
		
		\subsection{Tempo continuo}
		Nelle descrizioni a tempo continuo:
		\begin{itemize}
			\item La grandezza fisica che descrivo esiste in qualsiasi punto nel tempo
			come una equazione differenziale. I segnali e le quantità fisiche sono descritti nel come funzioni nei reali. Il tempo è considerato come un valore continuo.
			\item Si comportano come equazioni differenziali algebriche (DAE) o equazioni differenziali ordinarie (ODE). Vengono risolte da un solver lineare o non-lineare.
			\item Adatto per descrivere comportamenti fisici di sistemi dinamici,
		\end{itemize}
		
		\subsection{Descrizioni conservative}
		Nelle descrizioni conservative:
		\begin{itemize}
			\item Il comportamento 
			\item È tutto implementato in blocchetti di base che noi colleghiamo e che garantiscono in modo automatico che le leggi di conservazione di Kirchhoff vengano rispettate.
			\item ho vincoli sulla conservazione dell'energia
			le correnti d'entrata uguali a quelle di uscita
			\item Ci sono grandi quantità equazioni da risolvere, è molto dispendioso dal p.d.v. computazionale.
		\end{itemize}
		
		\subsection{Descrizioni non conservative}
		Nelle descrizioni conservative:
		\begin{itemize}
			\item Il comportamento è espresso con flussi di segnali di tempo continuo o variabili. Vengono applicate funzioni di processing (filtering e integrazione).
			\item Può essere descritta la dinamica non lineare
			\item Non è supportata l'interazione tra componenti AMS.
			\item Le relazioni tra quantità non rispettano le leggi di conservazione dell'energia di Kirkhhoff.
		\end{itemize}
		
		
		\subsection{Formalismi di modellazione}
			In SystemC AMS ci sono i seguenti formalismi di modellazione:
			\begin{itemize}
				\item \textbf{Time Data Flow (TDF)}: modelli a eventi discreti.
				\begin{itemize}
					\item Tempo discreto, modellazione non conservativa
					\item Scheduler statico, basato su dataflow
				\end{itemize}
				\item \textbf{Linear Signal Flow (LSF)}: modelli a eventi continui.
				\begin{itemize}
					\item Tempo continuo, modellazione non conservativa
					\item Basato su DAE e ODE, rappresentate da connessioni di primitive per segnali reali nel dominio del tempo.
				\end{itemize}
				\item \textbf{Electric Linear Network (ELN)}: per modellazione di reti elettriche.
				\begin{itemize}
					\item Tempo continuo, modellazione conservativa
					\item Primitive per reti lineari (resistenze, condensatori)
					\item Relazioni continue tra voltaggio e corrente.
				\end{itemize}
			\end{itemize}
			
			\begin{table}[h]
				\begin{tabular}{ccc}
					\toprule
									 & Discreto (Scheduler Statico) & Continuo (Scheduler Dinamico)\\
					\midrule 
					Conservativo 	 & $ \emptyset $ & \textbf{ELN}\\ 
					Non-Conservativo & \textbf{TDF} & \textbf{LSF} \\
					\bottomrule
				\end{tabular}
			\end{table}
			
		\subsection{Time Data Flow (TDF)}
			Formalismo basato su Synchronous Data Flow (SDF), senza tempo, modello a eventi discreti in tempo discreto. Ogni modulo del modello a eventi discreti contiene un metodo C++:
			\begin{itemize}
				\item Elabora una funzione matematica, a seconda degli input. Può dipendere anche dai suoi stati interni.
				\item Composizione di moduli
			\end{itemize}
			
			\noindent
			Esempio di composizione di funzioni: $ f_C ( f_B (f_A) ) $
			
			\bigskip
			
			\begin{center}
				\begin{tikzpicture}[>=latex]
				\draw (-1,1) rectangle (7,-1);
				\node[anchor=south west] at (-1,1) {Cluster TDF};
				\node[rect] (A) {A};
				\node[rect] (B) at (3,0) {B};
				\node[rect] (C) at (6,0) {C};
				\draw[->, ultra thick] (A.east) -- (B.west);
				\draw[->, ultra thick] (B.east) -- (C.west);
				\filldraw[fill=black, draw=black] ($ (A.east) +(-.1,.1) $) rectangle ($ (A.east) +(.1,-.1) $);
				\filldraw[fill=black, draw=black] ($ (B.east) +(-.1,.1) $) rectangle ($ (B.east) +(.1,-.1) $);
				\filldraw[fill=black, draw=black] ($ (B.west) +(-.1,.1) $) rectangle ($ (B.west) +(.1,-.1) $);
				\filldraw[fill=black, draw=black] ($ (C.west) +(-.1,.1) $) rectangle ($ (C.west) +(.1,-.1) $);
				
				\node[yshift=-1cm] (mod) at (A.south) {Modulo TDF};
				\node[yshift=-1cm] (sig) at (B.south) {Segnale TDF};
				\node[xshift=-.4cm,yshift=-1cm] (port) at (C.south) {Porta TDF};
				
				\draw (mod.north) -- (A.south);
				\draw (sig.north) -- ($ (B.west) +(2,0) $);
				\draw (port.north) -- (C.west);
				
			\end{tikzpicture}
			\end{center}
			
			Data una funzione, questa viene eseguita se e solo se ci sono abbastanza sample disponibili nella porta di input. C'è un numero fissato di sample consumati e prodotti. Ogni sample ha il suo time stamp. L'intervallo fissato è chiamato time step.
			
			\begin{itemize}
				\item Time step (modulo) 
				\hspace{1cm}
				\begin{tikzpicture}[baseline=-0.5]
					\node[rect, minimum width=1.25cm] (A) {A};
					\node at (0,-.35) {\tiny Tm:$ 20\mu$s };
					\filldraw[fill=black, draw=black] ($ (A.east) +(-.1,.1) $) rectangle ($ (A.east) +(.1,-.1) $);
					\filldraw[fill=black, draw=black] ($ (A.west) +(-.1,.1) $) rectangle ($ (A.west) +(.1,-.1) $);
				\end{tikzpicture}
				\item Time step (porta)
				\hspace{1cm}
				\begin{tikzpicture}[baseline=-0.5]
					\node[rect, minimum width=1.25cm] (B) {B};
					\node[align=left, font=\tiny] at (-.05,.25) {Tp:$ 10\mu$s \\ R:2 };
					\filldraw[fill=black, draw=black] ($ (B.east) +(-.1,.1) $) rectangle ($ (B.east) +(.1,-.1) $);
					\filldraw[fill=black, draw=black] ($ (B.west) +(-.1,.1) $) rectangle ($ (B.west) +(.1,-.1) $);
				\end{tikzpicture}
				\item Rate (porta)
				\item Delay (porta)
				\hspace{1cm}
				\begin{tikzpicture}[baseline=-0.5]
				\node[rect, minimum width=1.25cm] (C) {C};
				\node[align=left, font=\tiny] at (.35,0) {D:1};
				\filldraw[fill=black, draw=black] ($ (C.east) +(-.1,.1) $) rectangle ($ (C.east) +(.1,-.1) $);
				\filldraw[fill=black, draw=black] ($ (C.west) +(-.1,.1) $) rectangle ($ (C.west) +(.1,-.1) $);
				\end{tikzpicture}
				\item Time offset (porta specializzata)
				\hspace{1cm}
				\begin{tikzpicture}[baseline=-0.5]
				\node[rect, minimum width=1.25cm] (D) {D};
				\node[align=left, font=\tiny] at (-.1,.35) {Tpf:$ 1\mu$s};
				\filldraw[fill=black, draw=black] ($ (D.east) +(-.1,.1) $) rectangle ($ (D.east) +(.1,-.1) $);
				\filldraw[fill=black, draw=black] ($ (D.west) +(0,.1) $) rectangle ($ (D.west) +(.1,-.1) $);
				\filldraw[fill=white, draw=black] ($ (D.west) +(-.1,.1) $) rectangle ($ (D.west) +(0,-.1) $);
				\end{tikzpicture}
			\end{itemize}
			
		\subsection{Scheduling}
			Discrete Event Models Cluster: insieme di moduli di modelli di eventi discreti connessi che appartengono allo stesso scheduler statico:
			\begin{itemize}
				\item I parametri devono essere compatibili
				\item Definisce una sequenza in cui i moduli di modelli di eventi discreti vengono eseguiti
			\end{itemize}
			
			Nello scheduling i cicli possono essere fonte di problemi. Ogni loop deve presentare minimo una porta di delay. Le porte di delay possono portare all'inconsistenza, quindi bisogna specificare un valore iniziale.
			
			\textbf{TDF non supporta la gerarchia}
			
			\textbf{Consistenza:}
			\[
				T_m = T_{p_{\text{input}}}\cdot R_{\text{input}} = T_{p_{\text{output}}}\cdot R_{\text{output}}
			\]
			
			\newpage
			
	\section{Sintesi di Software Embedded}
		La sintesi di un software embedded è legata alla piattaforma target che deve avere un organizzazione semplice:
		\begin{itemize}
			\item Insieme di unità HW dedicate
			\item Porte programmabili
			\item Processore
			\item Memoria
		\end{itemize}
		Il software dovrà anche riuscire ad attivare l'esecuzione sui vari dispositivi hardware e ottenere risultati di tali parti.
		Gli algoritmi non sono mappati come processi ma come hardware, come avviene nei circuiti integrati ASIC (Application Specific Integrated Circuit).
		
		\subsection{Hardware Dependent Software}
			Possiamo considerare un software embedded come un \textbf{firmware} (metà tra hw e sw). Con questo termine in realtà si definiva il software che permetteva di realizzare microistruzioni all'interno dei processori negli anni '70 (microprogrammazione).\\
			Il termine corretto non è firmware ma \textbf{HDS}: Hardware Dependent Software. Il software è hardware independent grazie ad uno strato hardware dependent. Questo strato generalmente viene fornito dal sistema operativo.
			
			\begin{figure}[h]
				\centering
				\begin{tikzpicture}
				\draw[rounded corners] (0,0) rectangle (9,7);
				\draw (0,6) -- (9,6); \draw (0,6) -- (9,6); \draw (0,5) -- (9,5); \draw (0,4) -- (9,4); \draw (0,2.5) -- (9,2.5);
				\draw (0,1) -- (9,1);
				\draw (4.5,5) -- (4.5,1); \draw (2.25,4) -- (2.25,1); \draw (6.75,5) -- (6.75,2.5);
				\node at (4.5,6.5) {Application SW}; \node at (7.5,6.75) {Embedded SW};\node at (4.5,5.5) {Middleware};
				\node[align=center] at (5.65,4.5) {Test support\\ Library};
				\node[align=center] at (7.75,4.5) {Online test\\ segment};
				\node[align=center] at (5.65,3.25) {Offline test\\ segments};
				\node[align=center] at (3.45,3.25) {Device\\ drivers};
				\node[align=center] at (3.45,1.75) {HW\\ abstraction\\ layer (HAL)};
				\node[align=center] at (1.15,3.25) {Boot\\ \& Load};
				\node[align=center] at (1.15,1.75) {HW init}; \node[align=center] at (6.75,1.75) {BSP};
				\node at (4.5,0.5) {Communication HW};
				\draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=4pt},yshift=0pt]
				(9.25,0) -- (9.25,1) node [black,midway,xshift=1.5cm,align=center] {HW\\ space};
				\draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
				(9.25,1) -- (9.25,4) node [black,midway,xshift=1.5cm,align=center] {Kernel\\ space};
				\draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
				(9.25,4) -- (9.25,7) node [black,midway,xshift=1.5cm,align=center] {User\\ space};
				\draw [decorate,decoration={brace,amplitude=10pt,raise=4pt},yshift=0pt]
				(-.25,1) -- (-.25,5) node [black,midway,xshift=-1.25cm,align=center] {HdS};
			\end{tikzpicture}
			\end{figure}
			
			Non è detto che un sistema embedded abbia a disposizione un sistema operativo. In molti sistemi embedded infatti non c'è, se il software è realizzabile come un unico processo non mi serve un sistema operativo. Se invece ho più processi o librerie esterne devo averlo per implementare uno scheduler. Spesso nelle board ho solo una parte del kernel di linux. Se non c'è o.s., l'HDS deve comunque fare qualcosa:
			\begin{itemize}
				\item \textbf{HAL} (Hardware Abstraction Layer): contiene informazioni su dove i dispositivi hw sono mappati in memoria: mappa di indirizzi a cui non corrisponde RAM, bensì Hardware. Parte principale che permette di interfacciarmi con l'hw.
				\item \textbf{Device Drivers}: Se ho interrupt allora devo alzarmi nel livello di astrazione e avere a disposizione un device driver e primitive che si interfacciano con un dato dispositivo leggendo e utilizzando gli indirizzi a cui sono associati gli hw.
				Le primitive sono:
				\begin{itemize}
					\item \lstinline|OPEN|
					\item \lstinline|READ| : è solo una lettura su un indirizzo di memoria
					\item \lstinline|WRITE|
					\item \lstinline|CLOSE| (chiude la comunicazione)
					\item \lstinline|GENERIC IO| : fasi specifiche del dispositivo hw (usata solo in casi particolari)
				\end{itemize}
			\end{itemize}
			Scrivere un device driver significa scrivere le sopracitate funzioni.\\
			La difficoltà di un device driver non risiede quindi sulla complessità delle primitive ma sulle scelte progettuali:
			\begin{itemize}
				\item bloccante o non bloccante
				\item Come gestire sincronismo per evitare che i dati di uno non finiscano nell'altro?
			\end{itemize}
			Il sistema operativo mette a disposizione una serie di funzionalità che facilitano tutto ciò. Se non ho un sistema operativo generalmente ho solo processi. 
			\begin{itemize}
				\item \textbf{Boot and Load}: ogni processore ha una propria strategia di boot. Devo caricare in memoria il codice specifico per un dato processore ( questa componente è generalmente venduta con il processore: non si deve scrivere).\\
				Il compilatore produce software sapendo qual è la mappa di memoria che si aspetta il processore per funzionare.
				Il linguaggio usato di riferimento è il C o C++. Posso scrivere programmi in linguaggio ad alto livello ma ho bisogno del compilatore specifico e di un o.s. ( la complessità aumenta).
				\item \textbf{Middleware}: libreria specifica che mette a disposizione funzionalità per una particolare classe di problemi.
			\end{itemize}
			Le porte di HDS e software applicativo comunicano tra loro. Linux è il software embedded più utilizzato perché non ha licenze ed è aperto. È adattabile a tutte le piattaforme.\\
			Linux inoltre è composto da tante parti. Posso prendere parti che mi servono. Esistono configuratori che capiscono quali sono le componenti che vengono effettivamente usate dalla mia piattaforma. Questi configuratori permettono di riapplicare la stessa ricetta anche per versioni di linux successive.
			
		\subsection{Flusso di co-sintesi a livello di sistema}
			In questa fase avviene la partizione tra \textit{unità dedicate} e \textit{unità programmabili}.
			\begin{itemize}
				\item \textbf{Sintesi Hardware} delle \textit{unità dedicate} basata sulla ricerca o su tool commerciali per la sintesi standard.
				\item \textbf{Sintesi Software} delle \textit{unità programmabili} basata su tecniche di compilazione specializzata.
				\item \textbf{Sintesi delle interfacce} in cui vengono definite le interfacce HW e SW e avviene la sincronizzazione.
			\end{itemize}
			
		\subsection{Compilatori re-targetable}
			Si tratta di compilatori progettati in modo tale che risultino facili da modificare a fronte di generazione di codice per diversi instruction set di CPU. 
			\begin{itemize}
				\item Risultano utili ad esempio per architetture ASIP (Application Specific Instruction-set Processor) le quali hanno un set di istruzioni specifico.
				\item La qualità del codice (e.g. velocità di esecuzione) è molto importante, lo è meno il tempo di compilazione.
				\item Sono compilatori portabili.
				\item Sono compilatori indipendenti dalla macchina, applicabili a diverse architetture.
			\end{itemize}
			
			 
		
		\subsection{Linux RT}
			\textbf{Linux RT}: versioni \textit{real time} di linux. Le funzionalità sono corrette quando producono risultati corretti all'interno della finestra temporale che desideriamo.
			
			Esempio: airbag di un automobile ha requisiti real time:
	
			\begin{tikzpicture}[scale=0.5, >=latex, font=\footnotesize]
				\draw [<->, thin] (0,5) node [left,rotate=90,yshift=.25cm,xshift=.5cm] {correttezza} -- (0,0) -- (7,0) node [below] {tempo};
				\draw[ultra thick] node[below] {0} (0,0) -- (2,0) node[below] {4$ ms $} -- (2,2) -- (5,2) -- (5,0) node[below] {10$ ms $} -- (7,0);
				\node[left] at (0,2) {1}; \node at (1,1) {NO};\node at (6,1) {NO};
				
				\node at (17,2) {{\normalsize \textit{Hard real time}: precisione massima}};
			\end{tikzpicture}
			
			\begin{tikzpicture}[scale=0.5, >=latex, font=\footnotesize]
				\draw [<->, thin] (0,5) node [left,rotate=90,yshift=.25cm,xshift=.5cm] {correttezza} -- (0,0) -- (7,0) node [below] {tempo};
				\draw node[below] {0} (0,0) -- (2,0) node[below] {4$ ms $} -- (2,2) -- (5,2) -- (5,0) node[below] {10$ ms $} -- (7,0);
				\draw[ultra thick] (0,0) to [out=0, in=-110] (2,2) to [out=45, in=180] (3.5,2.5)	to [out=0, in=135] (5,2) to [out=-80, in=180] (7,0);
				\node[left] at (0,2) {1};
				\node at (17,2) {{\normalsize \textit{Soft real time}: sopporta un po' di ritardo}};
			\end{tikzpicture}
	
			Nell'hard real time posso garantire che il sistema risponda in certi intervalli di tempo.
			Se ho un unico processo che però deve reagire a interrupt il tempo di esecuzione reale aumenta sensibilmente e si rischia di violare i tempi prefissati (non determinismo). Se voglio determinismo tolgo gli interrupt e metto polling (sebbene sia profondamente inefficiente). Ho comunque non determinismo legato alla presenza in cache del dato oppure no.
			
			Se ho sistemi operativo con più processi il non determinismo è ancora più evidente. In sistemi operativi avanzati posso dare vincoli di real time ai processi che vengono usati dallo scheduler per capire quale processo ha priorità maggiore.
			
			\textbf{Difetti} di Linux RT: è una versione obsoleta rispetto a versioni di linux più recenti. Spesso non viene usato ma si usa questa strategia: considero sempre il caso pessimo. Se non soddisfo questo requisito alzo la frequenza del processore.
			
		\subsection{Sintesi SW dal SystemC}
		
			\begin{itemize}
				\item Le funzioni software vengono identificate da thread, poiché un singolo processore necessita della serializzazione di thread o interleaving di azioni originariamente concorrenti.
			
				\item Avviene quindi lo scheduling delle thread e delle istruzioni in modo da soddisfare i vincoli dettati dalle performance.
				
				\item C'è uno scheduler run-time a livello di sistema che sincronizza le funzioni SW e HW.
			
				\item I processi software vengono isolati dalla descrizione del sistema globale.
				
				\item Vengono generate le interfacce tra la parte HW e SW.
				
				\item Prima di andare verso l'hardware devo depurare il tutto dalle keyword di systemC: modifico il codice trasformandolo in thread che vengono fornite dal sistema operativo.
				
				\item Avvengono le misurazioni per le performance del software limitate dai vincoli hardware.
			\end{itemize}
			
			Flusso generale: TLM$\ \rightarrow\ $ generazione software $\ \begin{cases}
				\text{cache} \\
				\text{HdS}
			\end{cases} $ $\ \rightarrow\ $ Cross-compilazione.
			
			\noindent
			Devo decidere cosa va in software e cosa va in hardware sulla base delle prestazioni richieste:
			\[
				1000 ms
				\begin{cases}
					\text{componente 1}\ \rightarrow\ \text{90\% del tempo di esecuzione}\\
					\text{componente 2}\ \rightarrow\ \text{10\% del tempo di esecuzione}
				\end{cases}
			\]
			Se la componente 2 viene ottimizzata di 10 volte il tempo passa da $ 1000 $ a $ 910 $. Se avessi ottimizzato di 2 volte il tempo della componente 1 lo speed up sarebbe stato notevolmente maggiore con sforzo minimo.
			
		\subsection{Misurazione delle performance Software}
			Uno dei tool utilizzati per la misurazione delle performance è \textbf{\lstinline|gprof|}: si utilizza compilando da gcc con flag \lstinline|-P|. 
			\begin{itemize}
				\item Permette di calcolare quanto tempo spendo in ogni componente/sottoprogramma del sistema. 
				\item Posso realizzare le \textit{componenti più lente in hardware} al fine di migliorare le prestazioni. 
				\item Per sapere quante volte è chiamata la funzione devo controllare il software ad una frequenza di campionamento maggiore. 
				\item Occhio però perché se la frequenza è troppo alta interrompo spesso l'esecuzione e deterioro un po' i risultati.
			\end{itemize}
			
		\subsection{Definizione dei testbench}
			L'esecuzione del programma in termini di tempi dipende fortemente dal testbench utilizzato. Il testbench è buono se rispetta alcuni vincoli di copertura:
			\begin{itemize}
				\item \textit{Branch coverage}: percentuale di cammini che sono riuscito ad attivare
				\item \textit{Statement coverage}: alcune operazioni hanno un minimo e un massimo termine di esecuzione a seconda dell'input(esempio: potenze o radici quadrate).
				\item \textit{Path coverage}: i cammini di esecuzione crescono in maniera esponenziale, nel caso in cui ho processi. È necessario quindi fare delle approssimazioni. Devo cercare di individuare il cammino più lento se sono interessato al caso pessimo.
			\end{itemize}
			
		\subsection{Difficoltà di test per SW Embedded}
			La piattaforma di esecuzione (hardware) è spesso progettata in parallelo al software embedded:
			\begin{itemize}
				\item È necessario un modello hardware.
				\item Non c'è una esecuzione del software easy. E quindi neanche easy testing.
			\end{itemize}
			Il software embedded è spesso software hardware dependent (HdS):
			\begin{itemize}
				\item La correttezza dipende dalle tempistiche
				\item Il comportamento del software dipende dagli eventi asincroni hardware
				\item È richiesta una piattaforma reale o un modello hardware complesso: no easy testing.
			\end{itemize}
			
			\noindent
			\textbf{Una possibile soluzione approssimata:}
			\begin{itemize}
				\item \textbf{Test basato su test pattern funzionali}: è un approccio comune, ma non è esaustivo, alcuni bug rimangono nascosti e non verificati.
			\end{itemize}
			Per migliorare l'efficienza dei test pattern:
			\begin{itemize}
				\item ATPG (generazione automatica di vettori di collaudo) funzionale: è necessario un modello di guasti hw/sw
				\item Restrizione dei test funzionali: è necessario un modello di guasti hw/sw
				\item Copertura dei cambiamenti(mutation coverage): test basato su piccole modifiche del programma, in cui ogni versione viene chiamata mutante.
			\end{itemize}
			
			\noindent
			\textbf{Una possibile soluzione esatta:}
			\begin{itemize}
				\item \textbf{Test basato sulle proprietà}: difficile da utilizzare, è esaustivo se l'insieme delle proprietà è completo.
			\end{itemize}
			Per migliorare l'efficienza:
			\begin{itemize}
				\item Generazione automatica delle proprietà: è necessario un modello di specifica hw/sw.
				\item Model checking: model checking di hw/sw è ancora un area di ricerca.
				\item Classificazione delle proprietà: la copertura dei cambiamenti può essere utile.
			\end{itemize}
			
			\noindent
			\textbf{La soluzione ideale:}\\
			\textbf{Generazione di software embedded che si corregge nel processo di costruzione}:
			\begin{itemize}
				\item Il software viene raffinato da un modello hw/sw: è necessario un modello di specifica hw/sw.
				\item HdS viene generato automaticamente: il modello hardware guida la generazione del software.
				\item Le primitive del modello di specifica hw/sw vengono mappate automaticamente sulle primitive del sistema operativo del sistema embedded: modelli astratti di sistemi operativi.
				\item Non è necessario nessun test del software embedded!
			\end{itemize}
			
			
	\section{Model Based Design e UML}
		Model based design si pone a un livello intermedio; si passa all'implementazione del sottosistema mediante tool automatici. Nell'approccio tradizionale scrivo software per una particolare board. Se lavoro a livello di modello sono indipendente dall'architettura.
		
		Il software embdedded è uno specific-purpose software: è strettamente integrato con la piattaforma di esecuzione sottostante che reagisce costantemente ad eventi e unisce flusso di controllo e flusso dati.\\
		Il suo ruolo principale non è quello di trasformare i dati, ma quello di interazione con il mondo fisico: viene eseguito su macchine che non sono solo computer, ma sono automobili, aerei, telefoni, strumenti medici, giocattoli...
		
		\subsection{Caratteristiche principali di Software Embedded}
			\begin{itemize}
				\item \textbf{Tempestività} (\textit{Timeliness}): i processi fisici evolvono lungo il tempo. Una computazione in tardiva ("late computation") non è solo in ritardo, ma è incorretta!
				\item \textbf{Concorrenza} (\textit{Concurrency}): i segnali possono arrivare dall'ambiente contemporaneamente, potrebbero accadere attività disgiunte ma in parallelo che necessitano il monitoraggio.
				\item \textbf{Liveness}: nella visione di computazione di Turing, tutti i programmi che non terminano sono programmi difettosi. Nella computazione embedded, tutti i programmi che \textit{terminano} sono difettosi!
				\item \textbf{Reattività} (\textit{Reactivity}): E.S. sono sistemi vincolati in tempo reale e safety critical che reagiscono in modo continuo con l'ambiente che li circonda.
				\item \textbf{Eterogeneità} : E.S. mescolano stili di computazione con tecnologie di implementazione.
			\end{itemize}
			
			Il software embedded (ESW) deve quindi essere:
			\begin{itemize}
				\item Sviluppato rapidamente;
				\item Rapidamente modificabile ed estendibile;
				\item Conforme alle specifiche del cliente;
				\item Facilmente portabile tra le piattaforme di Sistemi Embedded.
			\end{itemize} 
		
		\subsection{ESW: vincoli di progettazione}
			La progettazione di software embedded implica vincoli di progettazione che vanno in conflitto tra loro:
			\begin{itemize}
				\item Efficiente, efficace, basso costo computazionale, basso utilizzo di memoria $\ \rightarrow\ $ stretta integrazione con la piattaforma ES;
				\item Riusabile, sviluppabile velocemente, mantenibile nel tempo, portabile  $\ \rightarrow\ $ astratto e indipendente dalla piattaforma ES.
			\end{itemize}
			 Per risolvere il conflitto di progettazione:
			 \textbf{Model Based Design (MBD)}  $\ \rightarrow\ $ progettazione basata su modelli astratti, generazione automatica di codice dai modelli astratti.
		
		\subsection{MBD: soluzioni sul mercato}
		
			\textbf{Matlab} permette lo sviluppo di agoritmi usando componenti già pronte assemblabili tra loro e quindi indipendentemente dal software. Saranno poi i plug-in di Matlab a fare sintesi sulla board specifica. L'unico \textit{difetto} di Matlab è quello che la specifica scritta in Matlab non è portabile in altri ambienti.
			
			\noindent
			\textbf{Modelica}: simile a Matlab ma open source. Utilizzato in progettazione di sistemi tecnici e.g.: sistemi meccanici, elettrici, termici, idraulici... La specifica del comportamento dinamico è descritta con equazioni differenziali, algebriche e discrete. \textit{Difetto}: scarsa manutenzione, supporta principalmente specifica funzionale/comportamentale.
			
			\noindent
			\textbf{Simulink}: progettazione di sistemi dinamici e di controllo. Descrizione dei sistemi tramite una libreeria di blocchi grafici o di equazioni differenziali, algebriche e discrete.\textit{Difetto}: supporta principalmente specifica funzionale/comportamentale, supporta in parte la partizione strutturale del sistema.
		
			Il mercato cerca qualcosa di standard: \textbf{UML}
			\begin{itemize}
				\item Specifica strutturale: componenti
				\item Specifica funzionale
				\item Specifica use case
			\end{itemize}
			Vantaggi: linguaggio aperto e flessibile. Le specifiche grafiche sono facilmente interpretabili. Permette la specifica a diversi livelli di astrazione:
			\begin{itemize}
				\item Livello use case
				\item Livello di sistema (structural view)
				\item Livello di integrazione (subsystems interaction view)
				\item Livello di unità (\textit{Unit Level} - subsystem functional view)
			\end{itemize} 
		
		\subsection{Unified Modeling Language (UML)}
			È un linguaggio standard per:
			\begin{multicols}{2}
				\begin{itemize}
				\item Specificare
				\item Visualizzare
				\item Costruire
				\item Documentare
				\item Modellare il business
				\item Comunicazioni
				\end{itemize}
			\end{multicols}
			Ci permette di visualizzare secondo 3 punti di vista diversi: \textit{Utente}, \textit{Designer} e \textit{Analizzatore}.
			
			UML mette a disposizione diversi \textbf{diagrammi} per la rappresentazione dei sistemi:
			\begin{itemize}
				\item \textit{Use Case diagram}: sono diagrammi dedicati alla descrizione delle funzioni o servizi offerti da un sistema, così come sono percepiti e utilizzati dagli attori che interagiscono col sistema stesso.\\
				Usati nei E.S. solamente all'inizio con il cliente, in modo da definire un'idea astratta.
				\item \textit{Class diagram}: si definiscono le classi con attributi e relazioni del sistema includendo ereditarietà, aggregazione, associazione e le operazioni e gli attributi delle classi.\\
				Non molto utili nei E.S. perchè troppo ad alto livello per le strutture dati dei ESW.
				\item \textit{Sequence Diagram}: diagramma di interazione che spiega in dettaglio come le operazioni vengono portate avanti nel tempo. Quali messaggi vengono inviati e quando in base al tempo di vita del sistema.\\
				Usati nei E.S. per ritrarre le relazioni nel tempo, anche se è difficile scrivere codice in modo automatico.
				\item \textit{Activities Diagram}: si permettono di definire stati e transazioni per descrivere cosa avviene nel tempo.\\
				Non usati nei E.S.: troppo distanti dal codice effettivo.
				\item \textit{\textbf{State Machine Diagram}}: mostrano i possibili stati degli oggetti e le transizioni che provocano un cambiamento dello stato degli oggetti.\\
				Usati nei E.S. e rappresentano un trade off perfetto tra l'astrazione e la verosimiglianza con il codice effettivo. Permettono di fare una rappresentazione astratta del ESW, pur mantenendo il contatto con il codice generato.
			\end{itemize}
			Vantaggi: trade-off tra astrazione e codice finale. Permette di rappresentare cosa effettivamente viene fatto.
			
			Esistono tool che permettono di convertire modelli UML in codice. Effettivamente usati su embedded (IAR azienda che produce questi tool.)	
	
	\section{A Software Cloud Architecture (IoT)}
		Devo mettere insieme il cloud con gli oggetti embedded. Per cloud si intende archivio che risiede in remoto.
		
		\textbf{IoT}(Internet of Things): un sistema di device interconnessi, dispositivi digitali e meccanici, oggetti con identificatori univoci e con la possibilità di trasferire dati sulla rete senza che sia richiesto l'intervento umano. 
		
		
		\subsection{Scenari di applicazione}
			Vengono elencati di seguito i possibili scenari di applicazione di IoT.
			\begin{enumerate}
				\item Prodotti IoT per la salute (smart healthcare): questi prodotti permettono di misurare battiti cardiaci, sudore, movimento, numero di passi, pressione del sangue, attività cerebrale, tutto in tempo reale e salvato in modo sicuro nel cloud.
				\item Prodotti IoT per la casa (Smart Home): per controllare l'umidità, luci, serrature...
				\item Prodotti IoT per la mobilità (Smart Mobility): dispositivi per l'industria del settore automobilistico come il controllo della pressione delle gomme o concetti più grandi tipo auto connesse per le misure di sicurezza sulla strada, sensori di parcheggio, sensori nelle strade e nei parcheggi..
				\item Prodotti IoT per l'energia (Smart grid / energy): dai contatori smart a vere e proprie griglie smart.
				\item Prodotti IoT per l'agricoltura : per ottimizzare i processi di manodopera, diminuire lo spreco e aumentare la qualità
				\item Prodotti IoT per la città (Smart cities)
				\item Prodotti IoT per l'industria (IIoT): per migliorare l'efficienza, aumentare la produzione.
			\end{enumerate}
			
		\subsection{Ingredienti per una soluzione IoT}
			Una soluzione IoT è composta da molti strati:
			\begin{itemize}
				\item \textbf{Strati di device} (\textit{device layers}): sono le \textit{things} dell IoT, cioè dispositivi embedded che sono equipaggiati per leggere, elaborare e inviare informazioni all'interno di internet. Solitamente un dispositivo è un micro-controllore equipaggiato di un chip di memoria, processore integrato, porte di I/O e di rete e un piccolo sistema operativo (Linux Yocto, Windows 10 IoT...). La capacità di controllare il dispositivo e di farlo comunicare con la rete è uno degli aspetti chiave di IoT.
				\begin{itemize}
					\item \textbf{Sensori}: giocano un ruolo importante nelle soluzioni IoT. Un sensore può essere programmato per catturare i parametri dell'ambiente richiesti che necessitano di essere monitorati e successivamente questi vengono convertiti in dati utili. Difficilmente hanno un'interfaccia. Sono i più diffusi.\\
					Non hanno controlli di input e output o funzioni, l'informazione può essere visualizzata in una console connessa con un altro dispositivo.\\
					Sono low powered device, e spesso sono equipaggiati con una piccola batteria a lunga vita che dura mesi o anche anni.
					\item \textbf{Attuatori}: dispositivi che interagiscono con il mondo fisico e in base all'input che ricevono svolgono l'azione richiesta. E.g.: movimento, luci, emissione di suoni, controllo di potenza ecc..
					\item \textit{RFID} (Radio Frequency Identification): tessera/ codice a barre smart che funge da chiave e identifica un device o un prodotto e lavora in connessione con il lettore RFID per tracciare l'informazione del prodotto e inviarla alla rete.
					\item \textit{NFC} (near field communication): funzionano su corte frequenze radio. Funzionano come gli RFID, ma il dispositivo con protocollo NFC può agire sia come lettore che come tag per una comunicazione a due vie. Sono utili per i pagamenti contactless.
					\item \textit{Beacons}: altra forma di dispositivi tag che trasmettono segnali o condividono in broadcast le proprie informazioni sulla posizione utilizzando bluetooth low energy(LE).
				\end{itemize}
				\item \textbf{Strati di comunicazione} (communication layer): la strategia di comunicazione è basata sulle capacità dei rete di ogni dispositivo. Un dispositivo può essere in grado di connettersi direttamente ad internet con wifi o con la rete telefonica. Al contrario un altro dispositivo può non essere in grado di connettersi direttamente ad internet e magari deve fare uso di un gateway o di un hub.
				\begin{itemize}
					\item \textbf{Device Gateway}: un dispositivo che connette reti o protocolli incompatibili tra loro e fornisce un mezzo per connettere dispositivi ad internet. Il gateway tradurrà i dati in arrivo in dati IP che possono essere poi instradati nella rete.
					\item \textbf{Smart gateway} (o edge gateway): sono device gateway dotati di archiviazione locale e applicazioni embedded che possono fare analisi sui dati che vengono trasmessi direttamente dai dispositivi. Permettono di abbattere la complessità dei nodi. Un gateway può avere capacità computazionale. Facendo così aumentano l'efficienza facendo computazione in tempo reale. un esempio è \textit{Kura}, un progetto open source provvisto di una piattaforma per costruire IoT edge gateways.
					\item \textbf{Smartphone}: un sensore o attuatore può comunicare con uno smartphone attraverso il protocollo Bluetooth, lo smartpone può a sua volta utilizzare wifi o rete telefonica per inviare i dati. Lo smartphone non automatizza il processo di comunicazione da solo, è necessario un intervento manuale per impostare il processo.
				\end{itemize}
				\item \textbf{Protocolli di comunicazione}: responsabili della connettività della rete. Alcuni forniscono una connettività diretta con internet (Wifi, Ethernet, rete telefonica tipo 2G, 3G, 4G, LTE...). \\
				Altri protocolli richiedono un gateway per tradurre comandi specifici nei corrispondenti comandi IP (Bluetooth LE, RFID, NFC, Zigbee/Z-wave per dispositivi con vincoli ambientali).
				\item \textbf{Protocolli di Applicazione}: sono in cima allo strato TCP. Utilizzano tCP come strato di trasporto per comunicare con messaggi di applicazione specifici.
				\begin{itemize}
					\item \textbf{MQTT} (Message Queue Telemetry Transport): protocollo di connettività machine-to-machine (M2M). È un protocollo di trasporto di messaggi di tipo publish/subscribe molto leggero.\\
					Utile per comunicazioni di piccoli dati, dispositivi con vincoli di risorse, reti con banda ristretta e alta latenza. Ha un payload binario ristretto.\\
					I dispositivi IoT sono client che si connettono all'MQTT broker, il quale supporta connessioni multiple concorrenti che coinvolgono un grande numero di dispositivi. Il dispositivo client inizia la connessione al broker MQTT. 
					\item \textbf{AMQP} (Advanced Message Queuing Protocol): un altro famoso middleware orientato ai messaggi che opera con il trasporto TCP. Questo protocollo supporta sia il modello a code di messaggi che il modello publish/subscribe. Assicura un'affidabile consegna dei messaggi.
				\end{itemize}
				\item \textbf{Protocolli di industria}: protocolli progettati per implementare soluzioni connesse specifiche per le industrie. Sono protocolli proprietari e permettono l'automazione industriale (SCADA, Modbus...).
				\item \textbf{Piattaforma core}: fornisce un insieme di possibilità per la connessione, il controllo e il monitoraggio di milioni di dispositivi. Composta da:
				\begin{itemize}
					\item \textit{Protocollo Gateway}: usata per il supporto della gestione di più protocolli. Permette la conversione tra protocolli. Può agire come interfaccia per supportare diversi protocolli e convertire diversi protocolli.
					\item \textit{IoT Messagging Middleware}: è un software che permette ai publishers e ai subscribers di distribuire messaggi senza che questi siano connessi fisicamente tra loro. È molto scalabile e pò gestire un vasto numero di dispositivi connessi assicurando alte prestazioni e tolleranza ai guasti.
					\item \textit{Data Storage}: archiviazione di un flusso continuo di dati proveniente dai dispositivi. C'è bisogno di un servizio di archiviazione molto scalabile. I dati devono essere replicati attraverso i server per assicurare un'alta disponibilità e per evitare errori.\\
					Tipicamente vengono usati database NoSQL: database Time Series in cui i dati sono rappresentati con una sequenza di vaolri per uno specifico attributo per un certo periodo di tempo. (MongoDB, Cassandra, Hbase, CouchDB...).
					\item \textit{Aggregazione di dati e filtraggio}: l'aggregazione dei dati permette di contestualizzare i dati del dispositivo con più informazioni.
				\end{itemize}
				\item \textbf{Strato di piattaforme di analisi} (Analytics Platform Layer): permettono di analizzare grandi quantità di informazioni, derivare approfondimenti. Formato da:
				\begin{itemize}
					\item \textit{Stream processing}: interagiscce con il componente di Messaging Middleware di IoT ascoltando i topics specificati. Fa real time stream processing, cioè analizza flussi di dati di dispositivi in tempo reale. 
					\item \textit{Machine Learning}: in che modo le macchine imparano dai dati utilizzando diversi algoritmi senza programmarle in modo specifico, in modo tale che ritornino il risultato richiesto. Viene classificato in tre categorie:
					\begin{enumerate}
						\item \textit{Supervised Learning}: forniamo dati etichettati come input e output desiderato e alleniamo il sistema ad imparare dai dati e a predirre i risultati.
						\item \textit{Unsupervised learning}: non vengono forniti i dati etichettati ma viene lasciato agli algoritmi il compito di trovare una struttura nascosta nei dati non etichettati.
						\item \textit{Reinforcement learning}: i sistemi imparano attraverso l'interazione con l'ambiente.
					\end{enumerate}
					\item \textit{Events and Reporting}: insieme di servizi che rendono più semplice l'invocazione delle azioni richieste in base ai dati analizzati. Le azioni posso essere: l'innesco di eventi, la chiamata a servizi esterni, l'aggiornamento dei report in tempo reale.
				\end{itemize}
			\end{itemize}
			IoT dovrebbe inoltre organizzare la sicurezza e il controllo delle applicazioni IoT.
		
		Per lavorare su IoT devo gestire il dispositivo, i protocolli di comunicazione e il cloud. È fondamentale per la sicurezza per evitare che i pacchetti vengano intercettati. Dovremmo avere un meccanismo di crittografia che parte dal sensore. Devo infatti spesso interfacciarmi con software di terze parti.
	
 		
	
	\section{Verification and Testing}
		\begin{figure}[h]
			\centering
			\begin{tikzpicture}[>=latex]
			\node[rect] (a) at(0,0) {Validazione}; \node[rect] (b) at (3,0) {Verifica};  \node[rect,align=center] (c) at (6,0) {Manufacturing\\Test};
			\draw[->] (a) -- (b);\draw[->] (b) -- (c);
			\end{tikzpicture}
			\caption{Flusso di Verification and testing}
		\end{figure}
	
	
		Solitamente i requisiti iniziali vengono scritti in un testo semi-strutturato; la descrizione non è formale. Dobbiamo quindi passare da questi requisiti a delle specifiche formali. Questo passaggio è scarsamente automatizzabile. Seguono alcune definizioni.
		
		\begin{dfn}[Validazione]
			Processo in cui verifico se la specifica formale è coerente con la specifica informale
			Confronto tra la parte informale e quella formale. Ci sono pochi strumenti automatici in grado di fare ciò. Dalle specifiche ottengo quindi un modello simulabile; riesco a dire così se le specifiche sono conformi. Per questa fase si richiede quindi un intervento umano.
		\end{dfn}
		
		\begin{dfn}[Verifica]
			Confronto tra specifica formale e realizzazione. (esempio: il modello RTL è conforme con quello di partenza?). Una specifica formale viene sintetizzata in una realizzazione. Quando ottengo una specifica formale raffino il progetto in un livello di sintesi sottostante. La verifica è un processo automatizzabile perché basato sul confronto tra due linguaggi formali.
		\end{dfn}
		Se avessi solo software allora mi basterebbero solamente Validazione e Verifica.
	
		\subsection{Test di fabbricazione (Manufacturing test)}
			Nei sistemi embedded abbiamo sia hw che sw. L'hardware deve essere realizzato (esempio: una FPGA deve essere fabbricata). Il test di fabbricazione viene fatto dopo la fabbricazione dell'oggetto fisico. Passo quindi dal mondo simulato della progettazione al mondo fisico. \\
			È complicato vedere se un transistor è difettoso (i transistor in un chip sono milioni). L'osservabilità e la controllabilità sono molto difficili da valutare.
			Il costo del test non deve superare il costo a cui il prodotto è venduto. Spesso il test non viene nemmeno fatto.
		
		Esempio:
		\begin{itemize}
			\item Eseguo un test su un chip, costo: 1€. Il test non è accurato ma viene comunque messo in vendita. Il chip viene quindi montato su una board.
			\item Viene eseguito un test sulla board, costo: 10€. La board risulta difettosa perché il chip è difettoso. La board viene comunque messa insieme ad altre board.
			\item Questo insieme di board viene testato, costo: 100€. L'insieme delle board risulta essere difettoso.
		\end{itemize}
		Ad ogni livello di integrazione il costo del test per sapere se funziona decuplica.
		Il 40 o 50\% dei costi di sviluppo sono dovuti a validazione, verifica e test. Spesso si arriva anche al 70\%. 
		
		\textbf{Test:} metodi che mi permettono di capire se un sistema ha o non ha guasti. Se un chip non funziona lo butto via, non posso ripararlo (GO/ NO GO).
		
		\textbf{Fault Diagnosis}: se il chip non funziona, devo identificare la posizione del guasto. Permette alla fonderia di silicio di capire quale fase della produzione ha dato problemi.\\
		La fase di test si divide in due parti:
		\begin{enumerate}
			\item \textbf{Generazione del test}: produco gli stimoli di test che faccio sui modelli systemC o Verilog.
			\item \textbf{Test application}: applico i test per ogni oggetto prodotto.
		\end{enumerate}
		
		Il test dell'hardware è incredibilmente più complesso perché errori possono avvenire anche in fase di produzione (non è così nel software).
		
		\textbf{Functional Test}: Verifica la correttezza del progetto. Un generatore automatico di testbench fa esattamente lo stesso della verifica. Il functional test fa da tramite tra i due mondi. 
		Utilizza tecniche di test pattern per generare test per fare validazione/verifica. 
		Un test pattern deve essere in grado di evidenziare il guasto se questo è presente. Dovrei orientare il test ai difetti ma i difetti possibili sono moltissimi. Il livello di difettosità (DL) è misurato in parti per miliardo
		
		Il test deve essere inserito nella fase di progetto. Ottengo un chip più grande, che consuma di più o più lento, ma che è testabile. Modifico il progetto al fine di poter generare più velocemente il test. 
		Il sistema deve avere delle risorse hardware aggiuntive che permettono di avere un sistema \textit{fault-tollerant}.
		
		Il problema principale è: quali sono tutti i guasti per i dispositivi hardware? Tutt'ora non si conosce il modo di generare test pattern per ogni tipo di guasto.
		
\end{document}