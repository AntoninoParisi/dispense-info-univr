\documentclass[a4paper, 11pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{frontespizio}
\usepackage{hyperref}
\hypersetup{hidelinks,
	colorlinks = true,
	urlcolor = black, 
	linkcolor = black}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{stmaryrd}
\usepackage{semantic}
\usepackage[strict]{changepage}
\usepackage{libertine}
\usepackage{xfrac}

\lstset{
	basicstyle=\ttfamily\small
}


\newtheorem{thm}{Teorema}[section]
\newtheorem{definit}{Definizione}[section]

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\type}{\Gamma \vdash}
\newcommand{\code}[1]{\textup{\lstinline|#1|}}
\newcommand{\subs}[3]{#1 \lbrace \sfrac{#2}{#3} \rbrace}

\begin{document}
	\begin{frontespizio}
		\Preambolo{\usepackage{datetime}}
		\Istituzione{Università degli Studi di Verona}
		\Divisione{Dipartimento di informatica}
		\Titolo{Linguaggi di programmazione}
		\Scuola{}
		\Sottotitolo{Riassunto dei principali argomenti}
		\Candidato{Davide Bianchi}
		\NCandidato{Autore}
		\Annoaccademico{2017/2018}
	\end{frontespizio}
	
	\tableofcontents
	\newpage
	\pagestyle{fancy}
	
	\section{Introduzione}
	Un linguaggio di programmazione è composto da: \begin{itemize}
		\item \textit{Sintassi:} insieme di regole di scrittura del linguaggio;
		\item \textit{Semantica:} descrizione del comportamento del programma a tempo di esecuzione;
		\item \textit{Pragmatica:} descrizione delle caratteristiche del linguaggio, delle sue funzionalità ecc.
	\end{itemize}

	Gli stili per dare la semantica di un linguaggio sono 3:
	\begin{itemize}
		\item \textit{Operazionale}: la semantica è data con sistemi di transizione, fornendo i passi della computazione passo passo;
		\item \textit{Denotazionale}: il significato di un programma è dato dalla struttura di un insieme;
		\item \textit{Assiomatica}: il significato è dato attraverso regole assiomatiche o qualche tipo di logica.
	\end{itemize}

	\section{Esempio di linguaggio basilare}
	La semantica operazionale di un linguaggio è data attraverso un sistema di regole di inferenza, date come segue: \begin{align*}
	(Assioma)\ \frac{-}{(Conclusione)} \qquad (Regola)\ \frac{(Hyp_1)\ (Hyp_2)\ ...\ (Hyp_n)}{(Conclusione)}
	\end{align*}  
	
	Introduciamo la sintassi di un linguaggio basato solo su espressioni aritmetiche:
	\begin{align*}
		E :=\ n\ |\ E\ |\ E+E\ |\ E*E\ ...
	\end{align*}
	
	La valutazione di programmi generati con questa sintassi può procedere in due modi:
	\begin{itemize}
		\item \textit{Small step:} la semantica fornisce il sistema per procedere nell'esecuzione, passo dopo passo;
		\item \textit{Big step:} la semantica va subito al risultato finale.
	\end{itemize}

	\subsection{Semantica big-step}
	Forniamo la semantica big-step per il linguaggio dato sopra:
	\begin{align*}
		\inference[B-Num]{-}{n \Downarrow n} \qquad \inference[B-Add]{E_1 \Downarrow n_1\ E_2 \Downarrow n_2}{E_1 + E_2 \Downarrow n_3}\ n_3 = add(n_1, n_2)
	\end{align*}
	La semantica big-step fornisce immediatamente il risultato, dando subito il valore finale dell'espressione che si sta valutando.
	\subsubsection{Esempio}
	\begin{align*}
		\inference[B-Add]{\inference[B-Num]{-}{3 \Downarrow 3} & \inference[B-Add]{\inference[B-Num]{-}{2 \Downarrow 2} & \inference[B-Num]{-}{1 \Downarrow 1}} {2 + 1 \Downarrow 3}}{3 + (2 + 1) \Downarrow 6}
	\end{align*}
	
	\begin{thm}[Determinatezza per semantica big-step] $E \Downarrow m$ e $E \Downarrow n$ implica $m=n$.
		
	\end{thm}
	
	\subsection{Semantica small-step}
	Indichiamo con $E_1 \rightarrowtriangle E_2$ lo svolgimento di un solo passo di semantica.
	\begin{align*} 
	&\inference[S-Left]{E_1 \rightarrowtriangle E_1'}{E_1 + E_2 \rightarrowtriangle E_1' + E_2} \\
	&\inference[S-N.Right]{E_2 \rightarrowtriangle E_2'}{n_1 + E_2 \rightarrowtriangle n_1 + E_2'} \\
	&\inference[S-Add]{-}{n_1 + n_2 \rightarrowtriangle n_3} n_3 = add(n_1, n_2)
	\end{align*}
	Con queste regole l'ordine di valutazione degli statement è fisso, procede sempre da sinistra verso destra.
	Diamo un'alternativa:
	\begin{align*}
		&\inference[S-Left]{E_1 \rightarrowtriangle_{ch} E_2}{E_1 + E_2 \rightarrowtriangle_{ch} E_1' + E_2} \\
		&\inference[S-Right]{E_2 \rightarrowtriangle_{ch} E_2'}{E_1 + E_2 \rightarrowtriangle_{ch} E_1 + E_2'} \\
		&\inference[S-Add]{-}{n_1 + n_2 \rightarrowtriangle_{ch} n_3} n_3 = add(n_1, n_2)
	\end{align*}
	In questo caso l'ordine di valutazione è arbitrario.
	La notazione utilizzata in generale è la seguente:
	\begin{itemize}
		\item la relazione $\rightarrowtriangle^k$, con $k \in \mathbb{N}$, indica una sequenza di n passi applicando la semantica small-step;
		\item la relazione $\rightarrowtriangle^\ast$, indica una sequenza di derivazione lunga un certo numero di passi. Questa relazione è riflessiva ed è la chiusura transitiva di $\rightarrowtriangle$.
	\end{itemize}
	
	\begin{thm}[Determinatezza per semantica small-step] Definiamo:
		\begin{itemize}
			\item \textbf{strong determinacy:} $E \rightarrowtriangle F$ e $E \rightarrowtriangle G$ implica $F=G$;
			\item \textbf{weak determinacy:} $E \rightarrowtriangle^\ast m$ e $E \rightarrowtriangle^\ast n$ implica $m=n$;
		\end{itemize}
	\end{thm}

\section{Linguaggio imperativo} \label{imp}
Definiamo la sintassi di un semplice linguaggio imperativo:
\begin{align*}
	b &:= true\ |\ false \\
	n &:= \lbrace ... -1, 0, 1, 2, ...\rbrace\\
	l &:= \lbrace l_0, l_1, ... \rbrace \\
	op &:= +\ |\ \geq \\
	e &:= n\ |\ b\ |\ e\ op\ e\ |\ \text{if } e \text{ then } e \text{ else } e\ |\ l:=e\ |\ !l\ |\ skip\ |\ e;e\ |\ \text{while } e \text{ do }\ e
\end{align*}

\textbf{Nota:} lo statement $!l$ indica l'intero memorizzato al momento alla locazione $l$. Inoltre il linguaggio non è tipato, quindi sono ammesse le sintassi come $2 \geq\ true$.

\subsection{Memoria}
La memoria è necessaria per poter valutare gli statement di lettura da una locazione. In particolare definiamo \begin{align*}
 dom(f) &= \lbrace a \in A\ |\ \exists b \in B\ s.t.\ f(a)=b \rbrace  \\
 ran(f) &= \lbrace b \in B\ |\ \exists a \in A\ s.t.\ f(a)=b \rbrace
 \end{align*}
 
 Lo store del linguaggio imperativo in questione è un insieme di funzioni parziali che vanno dalle locazioni di memoria nei numeri interi: \[ s: \mathbb{L} \to \mathbb{Z} \]
 
 L'aggiornamento della memoria funziona come segue: \[ s \lbrack l \rightarrow n \rbrack (l') = \begin{cases}
 n &\text{if } l=l' \\
 s(l') &\text{altrimenti}
 \end{cases} \]
 
 \subsection{Sistemi di transizione}
 Le semantiche operazionali sono date attraverso sistemi di transizione, ovvero strutture composte da: \begin{itemize}
 	\item un insieme $Config$ di configurazioni;
 	\item una relazione binaria $\rightarrowtriangle\ \subseteq Config \times Config$;
 \end{itemize}

Per indicare un generale passo di semantica si usa la notazione \[ \langle e, s \rangle \rightarrowtriangle \langle e', s' \rangle \]
che rappresenta una trasformazione di un programma $e$ con una memoria $s$ in un programma $e'$ con memoria associata $s'$.
I singoli passi di computazione sono singole applicazioni di regole della semantica.

\subsection{Semantica small-step su un linguaggio imperativo} \label{rules}
\begin{adjustwidth}{-1.3cm}{}
\begin{align*}
	&\inference[(op+)]{-}{\langle n_1 + n_2, s \rangle \rightarrowtriangle \langle n, s \rangle}\ n = add(n_1, n_2)
	&\inference[(op-geq \footnotemark)]{-}{\langle n_1 \geq n_2, s \rangle \rightarrowtriangle \langle b, s \rangle}\ b = geq(n_1, n_2) \\
		& &\\
	&\inference[(op1)]{\langle e_1, s \rangle \rightarrowtriangle \langle e_1', s' \rangle}{\langle e_1 \text{ op } e_2, s \rangle \rightarrowtriangle \langle e_1' \text{ op } e_2, s' \rangle}  &\inference[(op2)]{\langle e_2, s \rangle \rightarrowtriangle \langle e_2', s' \rangle}{ \langle v \text{ op } e_2, s \rangle \rightarrowtriangle \langle v \text{ op } e_2', s' \rangle} \\
		& &\\
	&\inference[(deref)]{-}{\langle !l, s \rangle \rightarrowtriangle \langle n,s \rangle}\text{ if } l \in dom(s) \text{ and } s(l)=n &\inference[(assign1)]{-}{\langle l:=n,s \rangle \rightarrowtriangle \langle skip, s\lbrack l \to n\rbrack \rangle}\ \text{if } l \in dom(s) \\
		& &\\ 
	&\inference[(assign2)]{\langle e, s \rangle \rightarrowtriangle \langle e', s' \rangle}{\langle l:=e,s \rangle \rightarrowtriangle \langle l := e', s' \rangle} &\inference[(if-tt)]{-}{\langle \text{if true then } e_1 \text{ else } e_2, s \rangle \rightarrowtriangle \langle e_1, s \rangle} \\
	& & \\
	&\inference[(if-ff)]{-}{\langle \text{if false then } e_1 \text{ else } e_2, s \rangle \rightarrowtriangle \langle e_2, s \rangle} &\inference[(if)]{\langle e, s \rangle \rightarrowtriangle \langle e', s' \rangle}{\langle \text{if } e \text{ then } e_1 \text{ else } e_2, s \rangle \rightarrowtriangle \langle \text{if } e' \text{ then } e_1 \text{ else } e_2, s' \rangle} \\
	& & \\
	&\inference[(seq)]{\langle e_1, s \rangle \rightarrowtriangle \langle e_1', s' \rangle}{\langle e_1;e_2, s \rangle \rightarrowtriangle \langle e_1';e_2, s' \rangle} & \inference[(seq.skip)]{-}{\langle skip; e_2, s \rangle \rightarrowtriangle \langle e_2,s \rangle} \\
	\end{align*}
	\begin{align*}
	& \inference[(while)]{-}{ \langle \text{while } e \text{ do } e_1,s \rangle \rightarrowtriangle \langle \text{if } e \text{ then } (e_1; \text{while } e \text{ do } e_1) \text{ else } skip,s \rangle} \\
\end{align*}
\end{adjustwidth}
\footnotetext{Problemi con \LaTeX\ implicano l'uso di un nome diverso.}

\subsection{Esecuzione di programmi e proprietà}
L'esecuzione di programmi con questa semantica consiste nel trovare una memoria $s'$ tale per cui valga che \[ \langle P, s \rangle \rightarrowtriangle^\ast \langle v, s' \rangle \] ovvero che si raggiunga una configurazione terminale in un certo numero di passi.

Illustriamo inoltre due importanti proprietà:
\begin{thm}[Strong normalization]
	Per ogni memoria $s$ e ogni programma $P$  esiste una qualche memoria $s'$ tale che \[ \langle P,s \rangle \rightarrowtriangle^\ast \langle v,s' \rangle  \]
\end{thm}

\begin{thm}[Determinatezza]
	Se $\langle e,s \rangle  \rightarrowtriangle \langle e_1, s_1 \rangle $ e $\langle e,s \rangle  \rightarrowtriangle \langle e_2, s_2 \rangle $ allora $\langle e_1, s_1 \rangle = \langle e_2, s_2 \rangle$.
\end{thm}

\subsection{Funzione di valutazione della semantica}
Date le regole nella sezione \ref{rules}, possiamo dire che in generale, per valutare una porzione di programma, viene applicata la regola \[ \sem{-}: Exp \to (Store \rightharpoonup Store) \]
dove, data una generica espressione $e$, la funzione $\sem{ \cdot}$ prende una memoria e ne ritorna una aggiornata dopo la valutazione di $e$.

\[ \sem{e}(s) = \begin{cases}
s' &\text{se } \langle e,s \rangle \rightarrowtriangle \langle e',s' \rangle \\
undefined &\text{altrimenti}
\end{cases} \]

\subsection{Possibili varianti del linguaggio}
Nel linguaggio illustrato possono essere introdotte anche diverse varianti.

\subsubsection{Inversione dell'ordine di valutazione}
È possibile ad esempio introdurre un ordine di valutazione \textit{right-to-left}, ossia:
\begin{align*}
	&\inference[(op1b)]{\langle e_2,s \rangle \to \langle e_2', s' \rangle}{\langle e_1 + e_2, s \rangle \rightarrowtriangle \langle e_1 + e_2', s' \rangle}
	&\inference[(op2b)]{\langle e_1,s \rangle \to \langle e_1', s' \rangle}{\langle e_1 + v, s \rangle \rightarrowtriangle \langle e_1' + v, s' \rangle}
\end{align*}
Aggiungendo queste due regole alla semantica ovviamente salta la regola della determinatezza.

\subsubsection{Regole di assegnamento}
Una piccola variante alla regola dell'assegnamento: \begin{align*}
	&\inference[(assign1b)]{-}{\langle l:=n,s \rangle \rightarrowtriangle \langle n, s\lbrack l \to n\rbrack \rangle}\ \text{if } l \in dom(s)
	&\inference[(seq.skip.b)]{-}{\langle v;e_2, s \rangle \rightarrowtriangle \langle e_2, s \rangle}
\end{align*}

\subsubsection{Inizializzazione della memoria}
Possibili varianti a livello di inizializzazione della memoria potrebbero essere: \begin{itemize}
	\item inizializzare implicitamente tutte le locazioni a 0;
	\item permettere assegnamenti ad una locazione $l$ tale che $l \notin dom(s)$ per inizializzare quella locazione.
\end{itemize}

\subsubsection{Valori memorizzabili}
Altre estensioni relative alla memoria (qui definita staticamente, ovvero l'insieme delle locazioni possibili è fisso) possono includere: \begin{itemize}
	\item la possibilità di memorizzare anche altri tipi di dato (non solo interi come in questo caso);
	\item la possibilità di avere una memoria definita dinamicamente, quindi dare la possiblità di avere sempre nuove locazioni disponibili oltre a quelle già in uso.
\end{itemize}

\subsection{Type systems}
Un type system è una struttura i cui usi principali sono: \begin{itemize}
	\item descrivere quando i programmi sono sensati;
	\item prevenire certi tipi di errore;
	\item strutturare i programmi;
	\item dare delle linee guida per la progettazione del linguaggio;
	\item dare informazioni utili per la fase di ottimizzazione da parte del compilatore;
	\item rinforzare alcune proprietà di \emph{sicurezza} del programma.
\end{itemize}

Definiamo la funzione \[ \Gamma \vdash e : T \]
che sostanzialmente assegna il tipo $T$ all'espressione $e$, per qualche tipo $T$ del linguaggio.

Aggiungiamo al linguaggio i tipi delle espressioni $T$ e i tipi delle locazioni $T_{loc}$:
\begin{align*}
	T ::=\ & int\ \vert\ bool\ \vert\ unit \\
	T_{loc} ::=\ & intref
\end{align*}

\subsubsection{Regole di tipaggio}
\begin{align*}
	&\inference[(int)]{-}{\type n : int}\ \text{per } n \in \mathbb{Z}  &\inference[(bool)]{-}{\type b : bool}\ \text{per } b \in \lbrace true, false \rbrace \\
	& & \\
	&\inference[(op+)]{\type e_1 : int \quad \type e_2:int}{\type e_1 + e_2 : int} &\inference[(op-geq)]{\type e_1 : int \quad \type e_2:int}{\type e_1 \geq e_2 : bool} \\
	&&\\
	&\inference[(if)]{\type e_1:bool \quad \type e_2:T \quad \type e_3:T}{\type \text{if } e_1 \text{ then } e_2 \text{ else } e_3:T} &\inference[(assign)]{\type e:int}{\type l:=e:unit}\ \text{se } \Gamma(l) = intref \\
	&& \\
	&\inference[(deref)]{-}{\type !l:int}\ \text{se } \Gamma(l) = intref &\inference[(skip)]{-}{\type skip:unit} \\
	&& \\
	&\inference[(seq)]{\type e_1:unit \quad \type e_2:T}{\type e_1;e_2:T} &\inference[(while)]{\type e_1:bool \quad \type e_2:unit}{\type \text{while } e_1 \text{ do } e_2:unit}
	&& \\
\end{align*}
\textbf{Nota:} le regole di tipaggio sono \textit{syntax-directed}, ovvero per ogni regola della sintassi astratta si ha una regola di tipaggio.

\subsubsection{Proprietà di tipaggio}
\begin{thm}[Progress]
	Se $\type e:T$ e $dom(\Gamma) \subseteq dom(s)$ allora $e$ è un valore oppure esiste una coppia $\langle e',s' \rangle$ tale che \[ \langle e,s \rangle \rightarrowtriangle \langle e',s' \rangle \]
\end{thm}

\begin{thm}[Type preservation]
	Se $\type e:T$ e $dom(\Gamma) \subseteq dom(s)$ e $\langle e,s \rangle \rightarrowtriangle \langle e',s' \rangle$ allora si ha che $ \type e':T$ e $dom(\Gamma) \subseteq dom(s') $
\end{thm}

Mettendo insieme le due proprietà sopra, si ottiene una nuova proprietà, esplicativa del fatto che programmi ben tipati non vanno mai in deadlock.

\begin{thm}[Safety]
	Se $\type e:T$, $dom(\Gamma) \subseteq dom(s)$ e $\langle e,s \rangle \rightarrowtriangle^\ast \langle e',s' \rangle$ allora $e'$ è un valore oppure esiste una coppia $\langle e'', s'' \rangle$ tale che $\langle e',s' \rangle \rightarrowtriangle \langle e'',s'' \rangle$
\end{thm}

\begin{thm}[Type inference]
	Dati $\Gamma$, $e$, può essere trovato il tipo $T$ tale che $\type e:T$ oppure può essere provato che $T$ non esiste.
\end{thm}

\begin{thm}[Decidibilità del type-checking]
	Dati $\Gamma$, $e$, $T$, è decidibile $\type e:T$
\end{thm}

\begin{thm}[Unicità del tipaggio]
	Se vale che $\type e:T$ e $\type e:T'$ allora $T=T'$.
\end{thm}

\section{Forme di induzione}
L'induzione è una tecnica formale che consente di provare delle proprietà su determinate categorie di oggetti, sfruttando la natura di questi oggetti.
Esistono 3 tipi di induzione:
\begin{itemize}
	\item matematica;
	\item strutturale;
	\item rule induction\footnote{Appena avrò una traduzione valida la metterò.}.
\end{itemize}

\subsection{Induzione matematica}
È la forma di induzione più semplice, consiste infatti nel dimostrare una proprietà $P(-)$ su numeri naturali procedendo nel modo seguente:
\begin{enumerate}
\item \textbf{Caso base:} provare che $P(0)$ è vera, usando qualche procedimento matematico;
\item \textbf{Caso induttivo:}\begin{enumerate}
	\item assumere che l'ipotesi induttiva valga, ovvero che valga $P(k)$;
	\item dall'ipotesi induttiva dimmostrare che vale $P(k+1)$, usando qualche procedimento matematico.
\end{enumerate}
\end{enumerate}
Se i punti precedenti sono veri, allora $P(n)$ è vera per ogni numero naturale.

\subsection{Induzione strutturale}
\subsubsection{Induzione strutturale su numeri naturali}
Per dimostrare una proprietà $P$ su numeri naturali basta applicare il seguente metodo: \begin{itemize}
	\item \textbf{Caso base:} dimostrare che vale $P(0)$;
	\item \textbf{Caso induttivo:} dimostrare che è vera $P(succ(K))$ assumendo come ipotesi induttiva che valga $P(K)$ per qualche $K \in \mathbb{N}$.
\end{itemize}

L'induzione strutturale consiste quindi nell'assumere che l'ipotesi induttiva valga per la \textit{sottostruttura} di $succ(K)$.

\subsubsection{Induzione strutturale su strutture complesse}
Prendiamo come esempio la costruzione di alberi binari. Diamo la seguente grammatica per costruire gli alberi: \[ T::= leaf\ |\ tree(T,T) \]

In tal caso partiamo col presupposto che: \begin{itemize}
		\item \textbf{Caso base:} una foglia sia un albero binario;
		\item \textbf{Caso induttivo:} se $L$ e $R$ sono alberi binari, allora lo è anche $tree(L,R)$.
\end{itemize}

\subsection{Rule induction}
L'idea di base della rule induction consiste nell'ignorare la struttura di ciò che si deriva per fare induzione sulla dimensione dell'albero di derivazione.

Per provare formalmente una proprietà $P(D)$ su una derivazione $D$, si procede come segue: \begin{enumerate}
	\item \textbf{Caso base:} dimostrare che $P(A)$ è vera, per ogni assioma $A$;
	\item \textbf{Caso induttivo:} per ogni regola della forma \[ \inference[(regola)]{h_1\ h_2\ ...\ h_n}{c} \] si dimostra che ogni derivazione che termina con l'utilizzo di questa regola soddisfa la proprietà. Questa derivazione ha sottoderivazioni $D_1, D_2,...,D_n$ che terminano con le ipotesi $h_1, h_2,...,h_n$. Per ipotesi induttiva si assume che valga $P(D_i)$ con $1\leq i \leq n$.
	
\end{enumerate}

\section{Aspetti funzionali}
Estendiamo la sintassi data in \ref{imp} con:	 \begin{align*}
	\text{Variabili } &x \in \mathbb{X}, \text{con } x = \lbrace x,y,z,...\rbrace \\
	\text{Espressioni }&e::=\ ...\ |\ \text{fn }x:T \Rightarrow e\ |\ ee\ |\ x
\end{align*}
e i tipi con: \begin{align*}
	T\ ::=\ ...\ |\ T \to T
\end{align*}

Assumiamo che: \begin{itemize}
	\item l'applicazione di funzioni $ee$ è associativa a sinistra;
	\item i tipi delle funzioni sono associativi a destra;
	\item il corpo di $fn$ si estende a sinistra quanto più è possibile;
	\item $fn\ x:unit \Rightarrow fn\ y:int \Rightarrow x;y$ è di tipo $unit \to int \to int$.
\end{itemize}

\subsection{Variabili free e bound}
Intuitivamente, diciamo che una variabile è \textit{free} in $e$ se $x$ non occorre in nessun termine della forma \lstinline|fn x:T| $\Rightarrow$ ...

Più formalmente definiamo le variabili free come una funzione: \[ fv(): Exp \to 2^\mathbb{X} \] dove $\mathbb{X}$ è l'insieme delle variabili. La funzione $fv$ è definita come: \begin{align*}
	fv(x) &\triangleq \lbrace x \rbrace \\
	fv(\code{fn x:T} \Rightarrow e) &\triangleq fv(e) \setminus \lbrace x \rbrace \\
	fv(e_1 e_2)= fv (e_1;e_2) &\triangleq fv(e_1) \cup fv(e_2) \\
	fv(n)=fv(b)=fv(!l)=fv(\code{skip}) &\triangleq \emptyset \\
	fv(e_1 \code{op} e_2) = fv(\ \code{while}\ e_1\ \code{do}\ e_2) &\triangleq fv(e_1) \cup fv(e_2) \\
	fv(l \code{:=} e) &\triangleq fv(e) \\
	fv(\code{if}\ e_1\ \code{then}\ e_2\ \code{else}\ e_3) &\triangleq fv(e_1) \cup fv(e_2) \cup fv(e_3)
\end{align*}

\begin{definit}
	Un'espressione $e$ si dice \textbf{chiusa} se $fv(e) = \emptyset$.
\end{definit}

\subsection{Alpha conversion}
Nell'espressione \lstinline|fn x : T| $\Rightarrow e$ la variabile $x$ è \textit{bound} in $e$. Diciamo che: \begin{itemize}
	\item $x$ è il parametro formale della funzione, quindi ogni occorrenza di $x$ che non è in una funzione annidata alla funzione attuale indica la stessa cosa;
	\item al di fuori della definizione della funzione, la variabile $x$ non ha significato;
\end{itemize}

Basandoci su quanto detto nei due punti precedenti, possiamo concludere che il nome del parametro formale nella funzione \textbf{non modifica} il comportamento della funzione. Assumiamo quindi di poter \textit{rimpiazzare il vincolo su $x$ e tutte le occorrenze di $x$ in una certa espressione $e$ con una variabile \textbf{fresh} che non occorra da nessun'altra parte}.

\subsection{Sostituzioni}
\subsubsection{Sostituzioni singole}
Un perno della semantica delle funzioni è dato dalle sostituzioni, ovvero il rimpiazzo a runtime di un parametro attuale con un parametro formale. Una sostituzione è indicata con \[ \subs{e_2}{e_1}{x}  \] e indica la sostituzione di $x$  con $e_2$ nell'espressione $e_1$, per tutte le occorrenze libere di $x$. Le sostituzioni funzionano come segue: \begin{align*}
	\subs{n}{e}{x} &\triangleq n \\
	\subs{b}{e}{x} &\triangleq b \\
	\subs{\code{skip}}{e}{x} &\triangleq \code{skip} \\
	\subs{x}{e}{x} &\triangleq e \\
	\subs{y}{e}{x} &\triangleq y \\
	\subs{\code{(fn x:T} \Rightarrow e_1 \code{)}}{e}{z} &\triangleq \code{(fn x:T} \Rightarrow \subs{e_1}{e}{z}\code{)} \text{se } x \notin fv(e) \\
	\subs{\code{(fn x:T} \Rightarrow e_1 \code{)}}{e}{z} &\triangleq \code{(fn x:T} \Rightarrow (\subs{e_1}{e}{z})\lbrace \sfrac{e}{z} \rbrace \code{)} \text{se } x \in fv(e) \wedge y \text{ è fresh}\footnotemark \\
	\subs{\code{(fn x:T} \Rightarrow e_1 \code{)}}{e}{x} &\triangleq \code{(fn x:T} \Rightarrow e_1 \code{)} \\
	\subs{\code{(e}_1; \code{e}_2 \code{)}}{e}{x} &\triangleq (\subs{e_1}{e}{x}\subs{e_2}{e}{x})
\end{align*}
\footnotetext{Operando con alpha-conversion.}
Le altre espressioni dopo una sostituzione rimangono invariate per il semplice motivo che non sono funzioni, quindi non va sostituito alcun parametro.

\subsubsection{Sostituzioni simultanee}
Le sostituzioni possono essere implementate in modo da poter essere anche simultanee, ovvero con lo scopo di poter sostituire più variabili contemporaneamente. In generale, una sostituzione simultanea è una funzione parziale $\sigma: \mathbb{X} \to Exp$.

Sintatticamente viene indicato con $e \sigma$ l'espressione risultante dalla sostituzione simultanea di ogni $x \in dom(\sigma)$ con la corrispondente espressione $\sigma(x)$. La sostituzione dei parametri viene indicata con \[ \lbrace \sfrac{e_1}{x_1}, ..., \sfrac{e_k}{x_k} \rbrace \]

\subsection{Lambda calcolo}
Il lambda calcolo è un linguaggio dove: \begin{itemize}
	\item ogni termine è una funzione;
	\item ogni termine può essere applicato ad un altro termine;
	\item le funzioni del linguaggio \lstinline|fn x:T| $\Rightarrow e$ diventano funzioni del tipo $\lambda x:T.e$.
\end{itemize}

La sintassi del lambda-calcolo non tipato è: \[ M \in Lambda ::=\ x\ |\ \lambda x.M\ |\ MM \]

\subsection{Applicazione di funzioni}
Intuitivamente, nell'espressione $M_1M_2$, per applicare $M_2$ a $M_1$ si procede prima risolvendo $M_1$ ad un termine del tipo $\lambda x.M$, poi si procede in base a una delle strategie di valutazione possibili: \begin{itemize}
\item \textit{call-by-value:} si valuta $M_2$ ad un valore $v$, poi si valuta $\subs{M}{v}{x}$;
\item \textit{call-by-name:} si valuta direttamente $\subs{M}{M_2}{x}$.
\end{itemize}

\subsubsection{Semantica dell'applicazione di funzioni}
Estendiamo l'insieme dei valori con \[ \text{Values } v::= b\ |\ n\ |\ skip\ |\ fn\ x:T \Rightarrow e \]
La semantica funziona come di seguito:
\[ \inference[App]{M_1 \rightarrowtriangle M_1'}{M_1M_2 \rightarrowtriangle M_1'M_2} \]
Inoltre, in modalità call-by-value: \begin{adjustwidth}{-1.3cm}{}
\begin{align*}
	\inference[CBV-app1]{\langle e_1, s \rangle \rightarrowtriangle \langle e_1', s' \rangle}{\langle e_1e_2,s \rangle \rightarrowtriangle \langle e_1'e_2, s' \rangle}\quad  \inference[CBV-app2]{\langle e_2,s \rangle \rightarrowtriangle \langle e_2',s' \rangle}{\langle ve_2,s \rangle \rightarrowtriangle \langle ve_2',s' \rangle} \quad
	\inference[CBV-fn]{-}{\langle (\text{fn }x:T \Rightarrow e)v, s \rangle \rightarrowtriangle \langle \subs{e}{v}{x},s \rangle}
\end{align*}
\end{adjustwidth}
mentre in modalità call-by-name: \begin{align*}
\inference[CBN-app]{\langle e_1, s \rangle \rightarrowtriangle \langle e_1', s' \rangle}{\langle e_1e_2,s \rangle \rightarrowtriangle \langle e_1'e_2, s' \rangle} \quad \inference[CBN-fn]{-}{\langle (\text{fn }x:T \Rightarrow e)e_2, s \rangle \rightarrowtriangle \langle \subs{e}{e_2}{x},s \rangle}
\end{align*}

Introduciamo inoltre una nuova semantica che raccoglie le due precedenti: \begin{align*}
	\inference[BETA-app1]{\langle e_1, s \rangle \rightarrowtriangle \langle e_1', s' \rangle}{\langle e_1e_2,s \rangle \rightarrowtriangle \langle e_1'e_2, s' \rangle} \quad &\inference[BETA-app2]{\langle e_2,s \rangle \rightarrowtriangle \langle e_2',s' \rangle}{\langle e_1e_2,s \rangle \rightarrowtriangle \langle e_1e_2',s' \rangle} \\
	\inference[BETA-fn1]{-}{\langle (\text{fn }x:T \Rightarrow e)e_2, s \rangle \rightarrowtriangle \langle \subs{e}{e_2}{x},s \rangle} \quad &\inference[BETA-fn2]{-}{\langle \text{fn }x:T \Rightarrow e, s \rangle \rightarrowtriangle \langle \text{fn }x:T \Rightarrow e', s \rangle}
\end{align*}

\subsection{Tipaggio di funzioni}
Estendiamo l'insieme dei tipi come segue: \[ TypeEnv = \mathbb{L} \cup \mathbb{X} \rightharpoonup T_{loc} \cup T \] tale che: \begin{itemize}
	\item $\forall l \in dom(\Gamma). \Gamma(l) \in T_{loc}$
	\item $\forall x \in dim(\Gamma). \Gamma(x) \in T$
\end{itemize}

Definiamo le regole di tipaggio: \begin{align*}
	\inference[var]{-}{\type x:T} \text{se } \Gamma(x) = T \quad 
	\inference[fn]{\Gamma, x :T \vdash e:T'}{\type \text{fn } x :T \Rightarrow e:T \to T'} \quad
	\inference[app]{\type e_1:T \to T' \quad \type e_2:T}{\type e_1e_2:T'}
\end{align*}

Qui di seguito definiamo alcune proprietà del tipaggio:
\begin{thm}[Progress]
	Se $e$ è chiusa, $\type e:T$ e $dom(\Gamma) \subseteq dom(s)$ allora $e$ è un valore oppure esiste una configurazione $\langle e',s' \rangle$ tale $\langle e,s \rangle \rightarrowtriangle \langle e',s' \rangle$.
\end{thm}

\begin{thm}[Type preservation]
	Se $e$ è chiusa, $\type e:T$, $dom(\Gamma) \subseteq dom(s)$ e $\langle e,s \rangle \rightarrowtriangle \langle e',s' \rangle$ allora vale che $\type e:T'$, $e'$ è chiusa e $dom(\Gamma) \in dom(s')$.
\end{thm}














\section{Dati e memoria variabile}

\section{Sotto-tipaggio}

\section{Equivalenze semantiche}

\section{Concorrenza}

\end{document}