\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\renewcommand{\mkbegdispquote}[2]{\itshape}
\usepackage{palatino}
\usepackage{frontespizio}
\usepackage{mathtools, nccmath}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs,caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{epigraph}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage{textcomp}
\usetikzlibrary{shapes,arrows,positioning,calc}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{lipsum}
\lstset{language = C,
	basicstyle=\ttfamily\linespread{5} ,
	tabsize = 4,
	morekeywords={VerifyHamCycle},
	escapechar=",
	showstringspaces=false}

\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\chead{}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\newtheorem{thm}{Teorema}[subsection]
\theoremstyle{definition}
\newtheorem{esempio}{Esempio}[subsection]
\newtheorem{definit}{Definizione}[subsection]
\newtheorem{prop}{Proposizione}[subsection]

\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
	hidelinks, 
	colorlinks = true,
	linkcolor = black,
}
\usepackage[OT1]{eulervm}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\p}{\mathbf{P}}
\newcommand{\tim}{\mathbf{Time(n)}}
\newcommand{\np}{\mathbf{NP}}
\newcommand{\prob}[1]{\mathbb{#1}}
\newcommand{\instance}[1]{\mathcal{I}(\prob{#1})}
\newcommand{\alg}[1]{\mathcal{#1}}
\newcommand{\compl}[2]{T_\alg{#1}( \vert #2 \vert)}
\newcommand{\compld}[3]{T_\alg{#1}( \vert #2 \vert + \vert #3 \vert)}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture,baseline=(#1.base)]
	\node (#1) {\strut};}

\begin{document}
 \clearpage
 \begin{titlepage}
 	\centering
 	\vspace*{\fill}
 	{\scshape\LARGE Università degli Studi di Verona \par}
 	\vspace{1.5cm}
 	\line(1,0){145} \\
 	{\huge\bfseries Complessità\par}
 	\line(1,0){145} \\
 	\vspace{0.5cm}
 	{\scshape\Large Riassunto dei principali argomenti\par}
 	\vspace{2cm}
 	{\Large\itshape Matteo Danzi, Davide Bianchi\par}
 	\vspace{1cm}
 	
 	\vspace{5cm}
 	\vspace*{\fill}
 	% Bottom of the page
 	{\large \today\par}
 \end{titlepage}
  \thispagestyle{empty}
  \newpage
	
	\tableofcontents
	
	\newpage

	\section{Introduzione}
	
	\subsection{Cos'è la complessità computazionale}
		Nella teoria della complessità ci si pone la seguente domanda:
		
		\begin{displayquote}
		Come scalano le risorse necessarie per risolvere un problema all'aumentare delle dimensioni del problema?
		\end{displayquote} 

		La teoria della \textit{complessità computazionale} è una parte dell’informatica teorica che si
		occupa principalmente di classificare i problemi in base alla quantità di \textit{risorse computazionali} (come il tempo di calcolo e lo spazio di memoria) che essi richiedono per
		essere risolti. Tale quantità è detta anche \textit{costo computazionale} del problema.
		
	\subsection{Problemi \textit{facili} e \textit{difficili}}
		Vediamo quattro esempi di problemi che classificheremo come facili o difficili:
		\begin{enumerate}
			\item (\textbf{Eulerian Cycle}) Esiste un modo per attraversare ogni arco di un grafo una e una sola volta?
			
			\begin{itemize}
				\item Il problema si può vedere anche nella forma più piccola del problema dei \textit{sette ponti di Königsberg}:
			
				A Königsberg ci sono 7 ponti, esiste un percorso che attraversa tutti i ponti una e una sola volta per poi tornare al punto di partenza?
			
				Se avessi $ n $ ponti e su ogni riva partissero 2 ponti avrei $ 2^n $ possibili percorsi.
			
				\item La \textbf{soluzione di Eulero} dice che un grafo connesso non orientato ha un percorso che parte e inizia esattamente nello stesso vertice e attraversa ogni arco esattamente una volta se e solo se ogni vertice ha grado dispari (grado = numero di archi uscenti).
				
				Se ci sono esattamente due vertici $ v $ e $ u $, di grado dispari, allora esiste un percorso che parte da $ u $ e attraversa ogni arco esattamente una volta e finisce in $ v $.
				
				\item Seguendo quindi la soluzione di Eulero, \textit{quanto costa decidere} se un grafo G ha un tour Euleriano?
				\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
odd-vertex-num = 0;
For each vertex v of G
	if (deg(v) is odd)
		increment odd_vertex-num
If(odd-vertex-num is neither 0 nor 2)
	output no Eulerian tour
output Eulerian	
				\end{lstlisting}
				Questo algoritmo ha complessità: $ O(|E| + |V|) $
				
				Il costo e l'algoritmo sono gli stessi se vogliamo \textit{provare} che $ G $ \textit{non} ha un tour Euleriano.
				
			\end{itemize}
			
			\item (\textbf{Hamiltonian Cycle}) Esiste un modo per attraversare ogni nodo di un grafo una e una sola volta? 
			
			Esistono diverse soluzioni:
			\begin{itemize}
				\item Provo tutte le possibilità ogni volta, costo: $ O(2^n) $
				\item Provo tutte le possibili permutazioni, costo: $ O(n!) $
				\item La soluzione migliore ad oggi è: $ O(1.657^n) $
			\end{itemize}
			Alla domanda: \textit{Quanto costa decidere se un grafo ha un tour hamiltoniano?} Non sappiamo rispondere. Non sappiamo dire se il problema ha una soluzione non esponenziale. Per quanto ne sappiamo meglio di $ O(1.657^n) $ non sappiamo fare.
			
			Non sappiamo nemmeno dire se Hamiltonian Cycle è più difficile di Eulerian Cycle.
			\item N è un numero primo?
			
			Il migliore algoritmo conosciuto per decidere se N è un numero primo impiega $ O((\log N)^{6 + \epsilon}) $
			\item Quali sono i fattori primi di un numero?
			
			Ad oggi non conosciamo una procedure per fattorizzare un numero molto grande nei suoi divisori, che non sia provare tutte le possibilità.
		\end{enumerate}
		
		\subsection{Risolvere vs Verificare}
			La seguente tabella riassume in modo generico quanto detto nella sezione precedente riguardo alla difficoltà di risolvere problemi e verificare tali problemi su un istanza.
			
			\begin{table}[h]
				\centering
				\caption{Risolvere vs Verificare}
				\label{tab:intro}
				\begin{tabular}{lcc}
					\toprule
					\textbf{Problema} & \textbf{Risolvere} & \textbf{Verificare} \\
					\midrule
					Eulerian Cycle & \textit{facile} & \textit{facile} \\
					Hamiltonian Cycle & \textit{difficile?} & \textit{facile} \\
					N è primo? & \textit{facile} & \textit{facile} \\
					N ha un numero piccolo di fattori? & \textit{difficile?} & \textit{facile} \\
					\bottomrule
				\end{tabular}
			\end{table}
		
	\section{Problema computazionale}
		Un problema computazionale è una semplice relazione $ p $ che mappa l'insieme \textit{infinito} di possibili input (domande o istanze) con un insieme \textit{finito} (non vuoto) di output, cioè di risposte o soluzioni alle istanze.
		\[
			p\ \colon\ \text{istanze infinite}\ \mapsto\ \text{soluzioni finite alle istanze} 
		\]
		Un problema computazionale non è una singola domanda, ma è una \textbf{famiglia di domande}:
		\begin{itemize}
			\item Una domanda per ogni possibile istanza
			\item Ogni domanda è dello stesso tipo (appartiene alla stessa classe)
		\end{itemize}
		
		\begin{esempio}
			Il seguente esempio è un problema computazionale:
			\begin{itemize}
				\item Input: Qualsiasi grafo G
				\item Domanda: Il grafo G contiene un ciclo Euleriano?
			\end{itemize}
		\end{esempio}
		\begin{esempio}
			Il seguente esempio \textit{non} è un problema computazionale:
			\begin{itemize}
				\item Domanda: È vero che il bianco vince sempre a scacchi, sotto l'ipotesi della giocata perfetta?
			\end{itemize}
			Non è un problema computazionale perché non ho un insieme infinito di possibili partite in input.
		\end{esempio}
		
		\subsection{Risolvere un problema computazionale}
			Risolvere un problema computazionale significa trovare un \textbf{algoritmo}, cioè una procedura che risolve il problema matematico in un numero finito di passi (di computazione elementare), che solitamente include la ripetizione di un operazione. È un procedimento deterministico che mappa l'input sull'output.
			\epigraph{
				Un algoritmo è una procedura \textit{finita}, \textit{definita}, \textit{efficace} e con un input e un output.}{\textit{Donald Knuth -- The Art of Computer Programming }}
			
		\subsection{Complessità di un problema computazionale}
		\paragraph{Misura della complessità.}
			Come misuro la complessità di un problema computazionale? Come faccio a dire quanto è facile rispetto ad altri problemi?
			\begin{itemize}
				\item Do un \textbf{upper bound}: trovo un algoritmo qualsiasi che risolve il problema in modo da calcolare qual è il suo costo.
				\item Do un \textbf{lower bound}: trovo la minima quantità di risorse che ogni algoritmo utilizza per risolvere il problema. Tutti gli algoritmi sono \textit{al minimo} complessi come il limite inferiore che abbiamo stabilito. Nessuno può fare di meglio.
			\end{itemize}
			
			\begin{figure}[h]
				\centering
				\begin{tikzpicture}
					\draw (0,0) -- (0,-3);
					\node[right, xshift=.1cm] at (0,-.5) {$ O(n^2) $};
					\node[right, xshift=.1cm] at (0,-2.5) {$ \Omega (n) $};
					\draw[ultra thick] (0,-.5) -- (0,-2.5);
					\draw (-.15,-.5) -- (.15,-.5); \draw (-.15,-2.5) -- (.15,-2.5);
				\end{tikzpicture}
			\end{figure}
			
			\subsection{Trattabilità di un problema.} La crescita della complessità di un problema è riducibile a 2 categorie fondamentali.
			
			\paragraph{Crescita polinomiale.} Un problema ha crescita polinomiale quando le risorse necessarie alla sua risoluzione sono limitate ad $n^k$, per qualche $k$. Se la taglia del problema aumenta, la sua complessità aumenta di un qualche fattore costante. Infatti, se la taglia dell'input va da $n$ a $2n$ allora la complessità del problema si modifica in $(2n)^k = 2^kn^k$, ovvero aumenta di un fattore $2^k$ (costante). Raggruppiamo nella classe $\p$ i problemi di questo tipo.
			
			\paragraph{Crescita esponenziale.} Un problema ha crescita esponenziale la necessità di risorse necessarie alla sua risoluzione è proporzionale a $c^n$, per qualche costante $c > 1$. Se la taglia dell'input va da $n$ a  $2n$ $c^n$ allora la richiesta di risorse si diventa $c^{2n} = c^n * c^n$, aumentando quindi di un fattore che cresce con l'aumentare di $n$. Raggruppiamo nella classe $\Exp$ i problemi di questo tipo.
			
			\section{Le classi di problemi computazionali}
			\paragraph{Notazione e idee di base.}
			Formalmente definiamo un problema come un elemento $ \prob{A} $ di una relazione 
			\[ 
				\mathcal{R} \subseteq \instance{A} \times Sol 
			\] 
			dove: 
			\begin{itemize}
				\item $\instance{A}$ è l'insieme delle istanze del problema $\prob{A}$
				\item $Sol$ è l'insieme delle soluzioni delle istanze di $\prob{A}$
			\end{itemize}
			Si può quindi dire che 
			\[ 
				\forall x \in \instance{A},\ Sol(x) = \lbrace \text{Soluzioni di } x \rbrace 
			\]
			
			Non è restrittivo restringersi ai \textbf{problemi di tipo decisionale}, ovvero quei problemi che hanno come soluzione una risposta del tipo \textit{si} o \textit{no}, quindi i problemi del tipo \[ \prob{A} : \instance{A} \to \lbrace yes, no \rbrace \]
			
			
			L'algoritmo $\alg{A}$ per un problema $\prob{A}$ è un algoritmo che dato il problema, $\forall x \in \instance{A},\ \alg{A}(x) = \prob{A}(x)$. Inoltre, dato un algoritmo $ \alg{A} $, definiamo $\compl{A}{x}$ la sua \textbf{complessità}, cioè il \textit{tempo che impiega} $\alg{A}$ sull'istanza di taglia $\vert x \vert$. Notare che $\vert x \vert$ è la taglia dell'istanza $x$.
			
			\subsection{Classe P} 
			Intuitivamente la classe $\p$ è definita come la classe di problemi di \textbf{complessità polinomiale}. Introduciamo qui la definizione formale.
			
			\begin{definit}[Classe P]
				Definiamo la classe di problemi $\p$ come l'insieme dei problemi di complessità polinomiale, ovvero 
				\[ 
					\p = \big\lbrace \prob{A}\ \vert\ \exists \alg{A}\ t.c.\ \exists c \text{ costante e }\ \forall x \in \instance{A},\ \ \alg{A}(x) = \prob{A}(x)\ \text{ e }\ \compl{A}{x} \leq \vert x \vert ^ c \big\rbrace 
				\]
			\end{definit}
			
			\begin{esempio}[Eulerian Cycle]
				Un semplice esempio di problema appartenente alla classe $\p$ è il problema del tour euleriano. Per questo problema infatti abbiamo che è un problema computazionale di decisione:
				\begin{itemize}
					\item Input: grafo $ G $
					\item Output: $ yes \Leftrightarrow \exists $ Eulerian Cycle in $ G $.
				\end{itemize}
				Come abbiamo già visto quindi:
				\[
					\exists \alg{A}\ t.c.\ \compl{A}{G} = O(\vert E\vert + \vert V\vert) = O(\vert G\vert) 
				\] 
				Eulerian Cycle $ \in \p\ $ perché $\ \exists \alg{A}\ $ che impiega un tempo che è nell'ordine della taglia di $ G $, in particolare $ \ \exists c \text{ costante } $ dove $ c=1 $.
			\end{esempio}
			
			
			\begin{esempio}[Hamiltonian Cycle]
				Ci chiediamo allora se anche Hamiltonian Cycle $ \in \p\ $ ? La risposta è che non lo sappiamo dire. Quello che sappiamo per questo problema è che:
				\[
					\exists \alg{A}\ t.c.\ \compl{A}{G} = O(a^{\vert G \vert})
				\]
				dove $ a $ è costante.
			\end{esempio}
			
			\subsection{Classe Exp}
			Dal momento che non sappiamo se alcuni problemi stiano oppure no nella classe $\p$ (dal momento che non si conosce un algoritmo che li risolva in tempo polinomiale), si definisce la classe $\Exp$, che racchiude tutte le istanze di questa tipologia di problemi di \textbf{complessità esponenziale}.
			
			\begin{definit}[Classe Exp]
				Definiamo la classe di problemi $\Exp$ come la classe di problemi di complessità esponenziale, ovvero 
				\[ 
					\Exp = \big\lbrace \prob{A}\ \vert\ \exists \alg{A}\ t.c.\ \forall x \in \instance{A},\ \alg{A}(x) = \prob{A}(x)\ \text{ e }\ \compl{A}{x} \leq 2^{\vert x \vert ^ c} \big\rbrace 
				\]
			\end{definit}
			
			\begin{esempio}[Hamiltonian Cycle]
				Ci chiediamo se Hamiltonian Cycle $ \in \Exp$ ? Se prendiamo l'algoritmo che prova tutte le combinazioni di archi cioè $ \binom{\vert E \vert}{n} $ per vedere se formano un ciclo hamiltoniano. La complessità di quest'algoritmo è al massimo $\ 2^{\vert E \vert^2} $. 
				
				Se invece prendiamo l'algoritmo che considera tutte le possibili permutazioni dei vertici del grafo abbiamo che la complessità è $ n! $. Quindi il problema Hamiltonian Cycle $ \notin \Exp $
			\end{esempio}
			
			\paragraph{Relazione tra P ed Exp.} La domanda che sorge spontanea è $ \p \subseteq \Exp $ ?
			
			La risposta alla domanda è banalmente \textbf{si}, in quanto, dato un algoritmo $ \alg{B} $ con complessità $\compl{B}{x}$, possiamo dire che 
			\[ 
				\compl{B}{x} = O(\vert x \vert ^ c) = O(2^{\vert x \vert ^ c}) \Rightarrow \prob{A} \in \Exp 
			\]
			
			\paragraph{Problema K-Graph-Colouring.} Analizziamo ora il problema della K-colorabilità di un grafo $ G $:
			\begin{itemize}
				\item Input: $ G $ non orientato.
				\item Output: $ yes \Leftrightarrow \exists\ $ colorazione \textit{propria} dei vertici di $ G $ ovvero:
				\[
					\exists f\ \colon\ v \mapsto \{0,\dots, k-1 \}\quad t.c.\quad \forall (u,v)\in E(G)\quad f(u) \neq f(v)
				\]
			\end{itemize}
			
			\begin{figure}[h!]
				\centering
				\begin{subfigure}{.5\textwidth}
					\centering
					\begin{tikzpicture}
						\node[draw, circle] (a) at (0,0) {};
						\node[draw, circle, fill=black] (b) at (1.5,1) {};
						\node[draw, circle] (c) at (3,0) {};
						\node[draw, circle, fill=black] (d) at (1.5,-1) {};
						\draw (a) -- (b) -- (c) -- (d) -- (a) -- (c);
					\end{tikzpicture}
					\caption{Grafo con colorazione \textit{non} propria}
				\end{subfigure}%
				\begin{subfigure}{.5\textwidth}
					\centering
					\begin{tikzpicture}
						\node[draw, circle, fill=gray] (a) at (0,0) {};
						\node[draw, circle, fill=black] (b) at (1.5,1) {};
						\node[draw, circle] (c) at (3,0) {};
						\node[draw, circle, fill=black] (d) at (1.5,-1) {};
						\draw (a) -- (b) -- (c) -- (d) -- (a) -- (c);
					\end{tikzpicture}
					\caption{Grafo con colorazione propria}
				\end{subfigure}%
			\end{figure}
			
			\paragraph{Problema 2-Graph-Colouring.}
			Consiste nel trovare se esiste una 2 colorazione del grafo dato in input in modo tale che un arco non si trovi tra due vertici dello stesso colore. Questo problema corrisponde a dire se il grafo è \textbf{bipartito}, cioè se \textit{posso suddividere il grafo in due classi diverse}. \\
			Per vedere se è bipartito si effettua una \textbf{BFS}, cioè una visita in ampiezza, e si controlla se c'è un ciclo dispari. Se c'è allora non è bipartito e quindi nemmeno 2-colorabile.\\
			
			\noindent
			È 2-colorabile $ \Leftrightarrow $ è Bipartito $ \Leftrightarrow $ non contiene un ciclo dispari. La visita BFS ha una complessità pari a $ O(\vert E \vert + \vert V \vert) $, perciò il problema è risolvibile in tempo polinomiale, perciò possiamo concludere che 2-Graph-Colouring $ \in \p $.
			
			\paragraph{Problema 3-Graph Colouring}
			Il problema 3-Graph Colouring $ \in \p $? Non sappiamo rispondere a questa domanda, poiché non sappiamo se esiste un algoritmo che lo svolga in tempo polinomiale.\\
			Il problema 3-Graph Colouring $ \in \Exp $? Se consideriamo l'algoritmo che prova tutte le possibili colorazioni abbiamo che:
			\[
				3^n \text{ sono le colorazioni dei vertici, dove }\ n = \vert V(G) \vert 
			\]
			Bisogna vedere se ci sono archi monocolore e quindi la complessità diventa:
			\[
				O(3^n\cdot\vert E \vert) = O(3^{2n}) = O((2^{\log_2 3})^{2n}) = O(2^{2n\log_2 3})
			\]
			Perciò possiamo concludere che il problema 3-Graph Colouring $ \in \Exp $.
		
			\subsection{Classe Time(n)}
			
			\begin{definit}[Classe Time(n)]
				Definiamo la classe $ \tim $ come l'insieme dei problemi di complessità lineare, ovvero
				\[
					\tim = \big\lbrace \prob{A}\ \vert\ \exists \alg{B} \text{ per } \prob{A}\quad t.c.\quad
					\forall x \in \instance{A}\quad \compl{\alg{B}}{x} = O(n) = O(f(\vert x \vert))\ \big\rbrace  
				\]
			\end{definit}
			
			\begin{thm}
				$ \forall \alg{B}\quad t.c.\quad \alg{B}(x) = \prob{A}(x)\quad \compl{\alg{B}}{x} > \vert x \vert^c\quad \forall c\text{ costante} $
			\end{thm}
			
			\begin{thm}
				\label{thm:sort}
				Qualsiasi \textbf{algoritmo di ordinamento} che usa \textit{confronti} su $ n $ elementi ha tempo di esecuzione pari a
				\[
					\Omega(n\log n)
				\]
			\end{thm}
			
			\noindent
			Possiamo dire quindi che:
			\begin{itemize}
				\item \textbf{Eulerian Cycle} $ \in \tim $ perché esiste un problema che lo risolve in tempo lineare.
				\item \textbf{Sorting} $ \notin \tim $ per il teorema \ref{thm:sort}.
			\end{itemize}
			
			\begin{figure}[h]
				\centering\vspace{-.2cm}
				\begin{tikzpicture}[scale=.5,every node/.style={scale=0.8}]
					\draw (0,0) circle (3cm);
					\draw (-.5,0) circle (2cm);
					\draw (-1,0) circle (1cm);
					\node at (2.25,0) {$ \Exp $};
					\node at (.75,0) {$ \p $};
					\node at (-1,0) {$ \tim $};
				\end{tikzpicture}
			\end{figure}
			
			\newpage
			
			Possiamo riassumere quindi che:
			\begin{itemize}
				\item \textbf{Eulerian Cycle} $ \in \p $, \textbf{Eulerian Cycle} $ \in \tim $.
				\item \textbf{Hamiltonian Cycle} $ \in \Exp $
				\item \textbf{Hamiltonian Cycle} $ \in \p $ ? non lo sappiamo dire.
				\item \textbf{K-Colouring} $ \in \Exp $
				\item \textbf{K-Colouring} $ \in \p $? \\
				per $ k\geq 3 $ non lo sappiamo dire\\
				per $ k = 2 $ sì.
			\end{itemize}
			Inoltre, con la definizione della classe $ \tim $ si può dire che:
			\[
				\p = \bigcup_{k \geq 0} \mathbf{Time(n^k)}
			\]
			\[
				\Exp = \bigcup_{k\geq 0} \mathbf{Time(2^{n^k})}
			\]
			
		\subsection{Classe NP}
			La classe $ \np $ (\textit{non deterministic polinomial time}) è la classe di problemi tali che se la soluzione per un'istanza del problema è \textit{yes}, allora è facile verificarlo.
			
			\begin{definit}(Classe NP)
				\begin{align*}
					\np = \big\lbrace & \prob{A} \quad \big| \quad \exists \alg{B}(\stackrel{x}{\cdot}, \stackrel{w}{\cdot})\quad t.c.\quad 
					\compld{\alg{B}}{x}{w}= O((\vert x\vert + \vert w\vert)^c) \\
					& \forall x \in \instance{\prob{A}}\quad \prob{A}(x) = yes\ \Leftrightarrow\ \exists w\ t.c.\quad \vert w \vert = O(\vert x\vert^d)\ \text{ e }\ \alg{B}(x, w) = yes 
					\big\rbrace
				\end{align*}
					
				dove:
				\begin{itemize}
					\item $ \alg{B}(\stackrel{x}{\cdot}, \stackrel{w}{\cdot}) $ è detto \textbf{verificatore} per $ \prob{A} $. Se la risposta di $ \prob{A} $ esiste, allora $ \alg{B} $ dice \textit{yes}. Il verificatore impiega \textbf{tempo polinomiale} nella taglia dell'istanza per rispondere.
					\item $ x $ è l'istanza
					\item $ w $ è il certificato.
				\end{itemize}
				
			\end{definit}
			
			\paragraph{Hamiltonian Cycle $ \in $ NP ?} Per vedere se il problema Hamiltonian cycle appartiene alla classe $ \np $ dobbiamo costruire un verificatore $ \alg{B} $ che agisca in tempo polinomiale.
			
			\begin{lstlisting}[mathescape=true]
VerifyHamCycle(G = (V,E), C=$ x_1, \dots, x_n $)
	if r != |V|: return $ no $ "\tikzmark{a}"
	for each v$ \in $ V 
		if v non appare in C: return $ no $ "\tikzmark{c}"
	for i=1 to n-1
		if $ ( x_i, x_{i+1} )\notin $ E: return $ no $ "\tikzmark{b}"
	if $ ( x_1, x_n )\notin $ E: return $ no $ "\tikzmark{d}"
	return $ yes $
			\end{lstlisting}
			\begin{tikzpicture}[overlay, remember picture,decoration={brace,amplitude=2pt}]
				\draw[decorate,thick] ($ (a.east) +(2.7,-0.1) $) -- ($ (a.east) +(2.7,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(\vert w\vert) $};
				\draw[decorate,thick] ($ (c.east) +(0,.4) $) -- ($ (c.east) +(0,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(\vert V\vert\cdot\vert C\vert) $};
				\draw[decorate,thick] ($ (b.east) +(1.5,.4) $) -- ($ (b.east) +(1.5,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(\vert C\vert) $};
				\draw[decorate,thick] ($ (d.east) +(2.6,-0.1) $) -- ($ (d.east) +(2.6,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(1) $};
			\end{tikzpicture}
		Il tempo di esecuzione del verificatore è polinomiale e quindi posso dire che Hamiltonian Cycle $ \in \np$ .
			
		\paragraph{K-Colouring $ \in $ NP ?} Per vederlo costruisco il verificatore:
		\begin{lstlisting}[mathescape=true]
VerifyK-Colouring(G = (V,E), $ f(v_1), \dots, f(v_n) $)
	for each $ E(u,v)  $
		if $ f(u) = f(v) $: return $ no $ "\tikzmark{a}"
	for i=1 to n
		if $ f(v_i) \geq K $: return $ no $ "\tikzmark{b}"
	return $ yes $
		\end{lstlisting}
		\begin{tikzpicture}[overlay, remember picture,decoration={brace,amplitude=2pt}]
			\draw[decorate,thick] ($ (a.east) +(0,.4) $) -- ($ (a.east) +(0,-.5) $)
			node [midway,right, xshift=.2cm] {$ O(\vert E\vert) $};
			\draw[decorate,thick] ($ (b.east) +(0.2,.4) $) -- ($ (b.east) +(0.2,-.5) $)
			node [midway,right, xshift=.2cm] {$ O(\vert V\vert) $};
		\end{tikzpicture}
		Il tempo di esecuzione del verificatore è polinomiale e quindi posso dire che K-Colouring $ \in \np$ .
		
		\paragraph{P $ \subseteq $ NP ?} Vogliamo capire in che classe è $ \np $. Se include la classe $ \p $ allora significa che un problema che appartiene a quest'ultima, se lo sappiamo risolvere, lo sappiamo anche verificare. Infatti se $ \prob{A} \in \p $ dobbiamo dimostrare che esiste un verificatore. Tale verificatore per $ \prob{A} $ sarà: $\quad \alg{B}'(x,w) = \alg{B}(x)\ $ privo di certificato.
		Dobbiamo dimostrare che se l'istanza è \textit{yes} allora $ \alg{B}(x) = yes $ altrimenti $ \alg{B}(x) = no $.
		
		\paragraph{NP $ \subseteq $ Exp ? } Vogliamo capire in che classe è $ \np $
		
		Possiamo supporre che $ \p \subseteq \np \subseteq \Exp $.
		
		\begin{figure}[h!]
			\centering
			\begin{tikzpicture}
			\draw (0,0) ellipse (3.5cm and 2cm);
			\draw (-.5,0) ellipse (2.5cm and 1.5cm);
			\draw (-1,0) ellipse (1cm and 1cm);
			\node at (2.5,.5) {$ \Exp $};
			\node (np) at (.75,.5) {$ \np $};
			\node (p) at (-1,.5) {$ \p $};
			\node at ($ (p.south) +(0,-.2) $) {eulercycle};
			\node at ($ (p.south) +(0,-.5) $) {2-colouring};
			\node[rotate=20] at ($ (np.south) +(0,-.7) $) {hamcycle};
			\node[rotate=20] at ($ (np.south) +(-.5,-1.2) $) {k-colouring};
		\end{tikzpicture}
		\end{figure}
		
	\section{Riduzione alla Karp tra problemi di decisione}
		\begin{definit}[Riduzione alla Karp]
			Un problema di decisione $ \prob{A} $ si riduce alla Karp al problema $ \prob{B} $: $ \quad \prob{A} \leqslant_K \prob{B} \quad $ se esiste un algoritmo polinomiale $ \alg{A} $ tale che 
			\[
				\forall x \in \instance{A},\ \prob{B}(\alg{A}(x)) = yes \ \Leftrightarrow \ \prob{A}(x) = yes
			\]
		\end{definit}
		
		\begin{prop}
			Se $ \prob{A} \leqslant_K \prob{B} \quad\text{ e }\quad \prob{B}\in \p \quad \Rightarrow\quad \prob{A}\in\p $
		\end{prop} 
		\begin{prop}
			Se $ \prob{A} \leqslant_K \prob{B} \quad\text{ e }\quad \prob{B}\notin \p \quad \Rightarrow\quad \prob{A}\notin\p $
		\end{prop} 
		
		Come effettivamente svolgiamo le trasformazioni?
		
		\subsection{Problema SAT}
			\begin{definit}[SAT]
				Il problema di soddisfacibilità di una formula booleana è definito nel seguente modo:
				\begin{itemize}
					\item Input: formula booleana : $ \phi (x_1, \dots, x_n) = C_1 \wedge C_2 \wedge \dots \wedge C_n $\\
					Dove: \begin{itemize}
						\item $ C_i = l_{i1} \vee l_{i2} \vee \dots \vee l_{ik} $ (clausola)
						\item $ l_{ij} = x_k \text{ oppure } \bar{x}_k $ (letterale)
					\end{itemize}
					\item Output: \textit{yes} $ \Leftrightarrow\quad\exists a_1\dots a_n \in {T,F}^n\quad t.c.\quad \phi(a_1,\dots, a_n) = T $ 
				\end{itemize}
			\end{definit}
			
			\begin{esempio}
				$ \phi(x_1, x_2, x_3) = (x_1\vee \bar{x}_2\vee x_3)\wedge (\bar{x}_1\vee\bar{x}_2\vee x_3) \wedge (x_1\vee \bar{x}_3) $ \\
				Assegnamento che soddisfa la formula booleana $ \phi(x_1, x_2, x_3) $:
				\begin{align*}
					x_1 =& T\quad x_2 = F\quad x_3 = F \\
					a_1 =& T\quad a_2 = F\quad a_3 = F
				\end{align*}
			\end{esempio}
			
		\paragraph{SAT $ \in $ NP ?} Ci chiediamo se il problema SAT sta nella classe $ \np $. Vediamo dunque se esiste un certificato e un verificatore che attesta, dato una formula booleana, se essa è soddisfacibile in tempo polinomiale.
		\begin{itemize}
			\item Si può notare facilmente che il certificato è un assegnamento per la formula booleana, dunque è polinomialmente correlato alla grandezza delle variabili della formula, sarà al massimo $ n $.
			\item Il verificatore viene costruito analizzando la formula booleana, controllando ogni letterale di ciascuna clausola. Ho quindi $ m\times n \times n $ controlli, dove $ m = $ numero di clausole, $ n = $ numero di letterali. Il verificatore è quindi polinomiale.
		\end{itemize}
		Possiamo concludere che il problema SAT $ \in \np $. Questa affermazione si può tradurre con: \textit{data una formula booleana di cui sappiamo essere soddisfacibile, allora è facile (polytime) costruire un verificatore che attesta che essa è SAT.}
		
		\paragraph{Problema K-SAT:} è il problema SAT in cui l'input ha come restrizione il vincolo che ogni clausola ha esattamente $ k $ letterali.
		
		\begin{esempio}[3-SAT]
			$ \phi(x_1, x_2, x_3) = (x_1\vee x_2 \vee x_3)\wedge (\bar{x}_1\vee x_2 \vee x_3 ) \wedge (\bar{x}_1 \vee x_2\vee \bar{x}_3) $
		\end{esempio}
		  
		\subsection{Alcuni esempi di riduzioni tra problemi}
			\paragraph{K-colouring $ \leq_K $ (K+1)-colouring} Vediamo se il problema (K+1)-colouring non è più facile del problema K-colouring. Dobbiamo in sostanza dimostrare che decidere se possiamo colorare un grafo con $ k+1 $ colori non è più facile che decidere se possiamo colorare un grafo con $ k $ colori. \textbf{N.B.:} da notare che i due grafi non sono necessariamente uguali, parliamo di qualsiasi grafo che appartiene al problema.
			
			\begin{align*}
				\alg{A}\ : \quad & x\in \mathcal{I}(K-COL)\quad \mapsto\quad \alg{A}(x)\in \mathcal{I}((K+1)-COL) \\
							 & K-COL(x) = yes\quad \Leftrightarrow\quad (K+1)-COL(\alg{A}(x)) = yes   
			\end{align*}
			
			Prendiamo quindi il grafo $ G' $:
			
			\begin{center}
				\begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
					\draw (0,0) ellipse (3cm and 2cm);
					\draw (-1,-.5) circle (1cm);
					\node at (0,1.7) {$ G' = \alg{A}(x) $};
					\node at (-1,-.5) {$ G = x$};
					\node[draw, circle] (a) at (-.5,0) {}; \node[draw, circle] (b) at (-.5,-.9) {};
					\node[draw, circle] (c) at (-1.3,0) {};
					\node[draw, circle] (d) at (1,1) {};
					\draw[bend right] (d) to (c); \draw[bend left] (d) to (b); \draw (d) -- (a);
				\end{tikzpicture}
			\end{center}
			per cui
			\begin{align*}
				G &= (V, E) \\
				G'&= (V \cup \{v'\}, E \cup {(v, u')\ \vert\ v \in V})
			\end{align*}
			in tempo lineare e quindi sotto il polinomiale riesco a costruire il grafo G'.\\
			Se G è K-colorabile allora G' è (K+1)-colorabile. Mi basta assegnare a $ v' $ il colore $ k $ (il k+1-esimo colore) e mantenere la colorazione di G.\\
			Se G non è K-colorabile allora G' non è K+1-colorabile. Equivale a dire che se G' è K+1-colorabile allora G è k-colorabile. Quindi se $ v' $ ha un colore $ f(v') = x $ allora ogni $ v \in V(G) $ ha un colore $ f(v') \neq x $, al più usano k colori.
			
			Da questa dimostrazione ricaviamo anche che 2-col $ \leq_K $ 3-col $ \leq_K $ 4-col $ \leq_K $ 5-col
			
			
			\paragraph{SAT $ \leq_K $ 3-SAT} Vogliamo dimostrare che data una formula booleana $ \phi $ CNF esiste una trasformazione polytime che mi porta a una formula booleana $ \phi' $ 3CNF (ogni clausola ha esattamente 3 letterali). E inoltre che $ \phi $ è soddisfacibile se e solo se $ \phi' $ è soddisfacibile.
			
			Possiamo iniziare dicendo che $ \ (x_1 \vee x_2) \equiv (x_1 \vee x_1 \vee x_2) $. Le clausole più piccole possono essere espanse. Seguendo questa intuizione arriviamo a dire che:
			\begin{align*}
				&(l_1 \vee l_2 \vee l_3 \vee \dots \vee l_k)\quad \rightsquigarrow\quad \\
				&(l_1\vee l_2\vee z_1) \wedge (\bar{z}_1\vee l_3 \vee z_2) \wedge (\bar{z}_2 \vee l_4\vee z_3)
				\wedge (\bar{z}_3 \vee l_5 \vee z_4) \wedge \dots \wedge (\bar{z}_{k-1} \vee l_{k+1} \vee z_k)
			\end{align*}
			
			Dimostriamo che se $ \phi $ non è soddisfacibile allora non lo è neanche $ \phi' $.
			\begin{itemize}
				\item Prendiamo $ \phi = (x_1 , \dots, x_n) $. Per questa formula prendiamo un assegnamento $ a_1, \dots, a_n $ che non la rende soddisfacibile, quello in cui ogni letterale viene assegnato a F.
				\item Prendiamo dunque $ \phi' = (x_1, \dots, x_n, z_1, \dots z_r) $. Per questa formula prendiamo lo stesso assegnamento di $ \phi $ e vediamo cosa succede con i letterali $ z $:
			\[
				(\underset{F}{l_1} \vee \underset{F}{l_2}\vee \underset{V}{z_1}) 
				\wedge (\underset{F}{\bar{z}_1}\vee \underset{F}{l_3} \vee \underset{V}{z_2}) 
				\wedge (\underset{F}{\bar{z}_2}\vee \underset{F}{l_4} \vee \underset{V}{z_3}) 
				\wedge (\underset{F}{\bar{z}_3}\vee \underset{F}{l_5} \vee \underset{V}{z_4})  \wedge 
				\dots \wedge (\underset{F}{\bar{z}_{k-1}}\vee \underset{F}{l_{k+1}} \vee \underset{F}{z_{k}}) 
			\]
			risulta che l'ultimo letterale $ z_k $ è falso, e quindi $ \phi' $ non è soddisfacibile.
 			\end{itemize}
 			
 			\paragraph{K-COL $ \leq_K $ K-SAT} Vogliamo dimostrare che il problema di colorare un grafo con k colori è riducibile al problema di soddisfacibilità di una formula booleana k-CNF.
 			
 			Cerchiamo un modo per esprimere in modo logico il fatto che due nodi adiacenti non abbiano lo stesso colore.
 			Supponiamo che il nodo $ v $ abbia colore $ i $ e il nodo $ u $ abbia colore $ i $ con $ i= 0,1, \dots, k-1 $.
 			Per ogni $ v \in V $: $ \quad x_0^{(v)} \ x_1^{(v)} \ x_2^{(v)} \dots \ x_{k-1}^{(v)}  $ dove $ x_i^{(v)} = T $ se il vertice $ v $ ha colore $ i $.
 			
 			Ci chiediamo quindi quand'è che la formula è K-colorabile?
 			\[
	 			\forall v \in V
	 			\begin{cases}
		 			x_0^{(v)} \vee x_1^{(v)} \vee x_2^{(v)} \vee \dots \vee x_{k-1}^{(v)} \quad \text{ogni vertice ha un colore}\\ \\
		 			\overline{x_i^{(v)} \wedge x_j^{(v)}} = \overline{x_i^{(v)}} \vee \overline{x_j^{(v)}} \quad \forall i,j
	 			\end{cases}
 			\]
	 		\[
		 		\forall e =(u, v) \in E\ \text{ i due vertici non devono avere lo stesso colore}
	 		\]
	 		\[
		 		\forall i \quad \overline{x^{(v)}_i \wedge x_i^{(u)}} =
		 		\overline{x_i^{(v)}} \vee \overline{x_i^{(u)}}
	 		\]
	 		
	 		\begin{esempio}

	 			Prendiamo per esempio il seguente grafo:	 
	 			\begin{center}
					\begin{tikzpicture}
						\node[draw, circle] (u) at (0,0) {u};
						\node[draw, circle] (v) at (0,-1.5) {v};
						\node[draw, circle] (z) at (1.5,-.75) {z};
						\draw (u) -- (v) -- (z) -- (u);
					\end{tikzpicture}
				\end{center}
	 			La formula booleana corrispondente sarà:
	 			\begin{align*}
		 			&\tikzmark{a}(x_0^{(u)} \vee x_1^{(u)} \vee x_2^{(u)}) \wedge 
		 			\tikzmark{c}(\overline{x_0^{(u)}} \vee \overline{x_1^{(u)}}) \wedge
		 			(\overline{x_0^{(u)}} \vee \overline{x_2^{(u)}}) \wedge
		 			(\overline{x_1^{(u)}} \vee \overline{x_2^{(u)}})\tikzmark{d} \wedge \\
		 			&(x_0^{(v)} \vee x_1^{(v)} \vee x_2^{(v)}) \wedge 
		 			(\overline{x_0^{(v)}} \vee \overline{x_1^{(v)}}) \wedge
		 			(\overline{x_0^{(v)}} \vee \overline{x_2^{(v)}}) \wedge
		 			(\overline{x_1^{(v)}} \vee \overline{x_2^{(v)}}) \wedge \\
		 			&\tikzmark{b}(x_0^{(z)} \vee x_1^{(z)} \vee x_2^{(z)}) \wedge 
		 			(\overline{x_0^{(z)}} \vee \overline{x_1^{(z)}}) \wedge
		 			(\overline{x_0^{(z)}} \vee \overline{x_2^{(z)}}) \wedge
		 			(\overline{x_1^{(z)}} \vee \overline{x_2^{(z)}}) \wedge \\
		 			&\tikzmark{e}(\overline{x_0^{(v)}} \vee \overline{x_0^{(u)}}) \wedge
		 			(\overline{x_1^{(v)}} \vee \overline{x_1^{(u)}}) \wedge
		 			(\overline{x_2^{(v)}} \vee \overline{x_2^{(u)}}) \wedge \\
		 			&(\overline{x_0^{(v)}} \vee \overline{x_0^{(z)}}) \wedge
		 			(\overline{x_1^{(v)}} \vee \overline{x_1^{(z)}}) \wedge
		 			(\overline{x_2^{(v)}} \vee \overline{x_2^{(z)}}) \wedge \\
		 			&\tikzmark{f}(\overline{x_0^{(z)}} \vee \overline{x_0^{(u)}}) \wedge
		 			(\overline{x_1^{(z)}} \vee \overline{x_1^{(u)}}) \wedge
		 			(\overline{x_2^{(z)}} \vee \overline{x_2^{(u)}})
	 			\end{align*}
				
				\begin{tikzpicture}[overlay, remember picture,decoration={brace,amplitude=3pt}]
					\draw[decorate,thick] ($ (b) +(-0.3,-.2) $) -- ($ (a) +(-0.3,.2) $)
					 node[midway, left, align=left] {Ogni vertice\\ ha un colore}; 
					\draw[decorate,thick] ($ (f) +(-0.3,-.2) $) -- ($ (e) +(-0.3,.2) $)
					 node[midway, left, align=left] {Ogni arco ha\\ colori diversi}; 
					\draw[decorate,thick] ($ (c) +(0,.5) $) -- ($ (d) +(0,.5) $)
					node[midway, above, align=left] {Un vertice non\\ può avere 2 colori}; 
					
				\end{tikzpicture}
	 		\end{esempio}
	 	La trasformazione è polinomiale? La complessità della trasformazione è:
	 	\[
		 	\vert V \vert \cdot \Big(K + 2 \binom{k}{2}\Big) + \vert E \vert K\cdot 2 \quad \leq\quad
		 	(\vert E \vert + \vert V \vert) K^2
	 	\]
	 	Quindi è polinomiale.
\end{document}
