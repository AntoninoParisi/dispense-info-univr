\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\renewcommand{\mkbegdispquote}[2]{\itshape}
\usepackage{palatino}
\usepackage{frontespizio}
\usepackage{mathtools, nccmath}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs,caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{epigraph}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage{textcomp}
\usetikzlibrary{shapes,arrows,positioning,calc}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{lipsum}
\lstset{language = C,
	basicstyle=\ttfamily\linespread{5} ,
	tabsize = 4,
	morekeywords={VerifyHamCycle},
	escapechar=",
	showstringspaces=false}

\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\chead{}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\newtheorem{thm}{Teorema}[subsection]
\newtheorem{coroll}{Corollario}[subsection]
\theoremstyle{definition}
\newtheorem{esempio}{Esempio}[subsection]
\newtheorem{definit}{Definizione}[subsection]
\newtheorem{prop}{Proposizione}[subsection]
\newtheorem{obs}{Osservazione}[subsection]

\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
	hidelinks, 
	colorlinks = true,
	linkcolor = black,
}
\usepackage[OT1]{eulervm}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\p}{\mathbf{P}}
\newcommand{\tim}{\mathbf{Time(n)}}
\newcommand{\np}{\mathbf{NP}}
\newcommand{\npc}{\mathbf{NPC}}
\newcommand{\conp}{\mathbf{CO}\text{-}\mathbf{NP}}
\newcommand{\prob}[1]{\mathbb{#1}}
\newcommand{\instance}[1]{\mathcal{I}(\prob{#1})}
\newcommand{\alg}[1]{\mathcal{#1}}
\newcommand{\compl}[2]{T_\alg{#1}( \vert #2 \vert)}
\newcommand{\compld}[3]{T_\alg{#1}( \vert #2 \vert + \vert #3 \vert)}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture,baseline=(#1.base)]
	\node (#1) {\strut};}

\begin{document}
 \clearpage
 \begin{titlepage}
 	\centering
 	\vspace*{\fill}
 	{\scshape\LARGE Università degli Studi di Verona \par}
 	\vspace{1.5cm}
 	\line(1,0){145} \\
 	{\huge\bfseries Complessità\par}
 	\line(1,0){145} \\
 	\vspace{0.5cm}
 	{\scshape\Large Riassunto dei principali argomenti\par}
 	\vspace{2cm}
 	{\Large\itshape Matteo Danzi, Davide Bianchi\par}
 	\vspace{1cm}
 	
 	\vspace{5cm}
 	\vspace*{\fill}
 	% Bottom of the page
 	{\large \today\par}
 \end{titlepage}
  \thispagestyle{empty}
  \newpage
	
	\tableofcontents
	
	\newpage

	\section{Introduzione}
	
	\subsection{Cos'è la complessità computazionale}
		Nella teoria della complessità ci si pone la seguente domanda:
		
		\begin{displayquote}
		Come scalano le risorse necessarie per risolvere un problema all'aumentare delle dimensioni del problema?
		\end{displayquote} 

		La teoria della \textit{complessità computazionale} è una parte dell’informatica teorica che si
		occupa principalmente di classificare i problemi in base alla quantità di \textit{risorse computazionali} (come il tempo di calcolo e lo spazio di memoria) che essi richiedono per
		essere risolti. Tale quantità è detta anche \textit{costo computazionale} del problema.
		
	\subsection{Problemi \textit{facili} e \textit{difficili}}
		Vediamo quattro esempi di problemi che classificheremo come facili o difficili:
		\begin{enumerate}
			\item (\textbf{Eulerian Cycle}) Esiste un modo per attraversare ogni arco di un grafo una e una sola volta?
			
			\begin{itemize}
				\item Il problema si può vedere anche nella forma più piccola del problema dei \textit{sette ponti di Königsberg}:
			
				A Königsberg ci sono 7 ponti, esiste un percorso che attraversa tutti i ponti una e una sola volta per poi tornare al punto di partenza?
			
				Se avessi $ n $ ponti e su ogni riva partissero 2 ponti avrei $ 2^n $ possibili percorsi.
			
				\item La \textbf{soluzione di Eulero} dice che un grafo connesso non orientato ha un percorso che parte e inizia esattamente nello stesso vertice e attraversa ogni arco esattamente una volta se e solo se ogni vertice ha grado dispari (grado = numero di archi uscenti).
				
				Se ci sono esattamente due vertici $ v $ e $ u $, di grado dispari, allora esiste un percorso che parte da $ u $ e attraversa ogni arco esattamente una volta e finisce in $ v $.
				
				\item Seguendo quindi la soluzione di Eulero, \textit{quanto costa decidere} se un grafo G ha un tour Euleriano?
				\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
odd-vertex-num = 0;
For each vertex v of G
	if (deg(v) is odd)
		increment odd_vertex-num
If(odd-vertex-num is neither 0 nor 2)
	output no Eulerian tour
output Eulerian	
				\end{lstlisting}
				Questo algoritmo ha complessità: $ O(|E| + |V|) $
				
				Il costo e l'algoritmo sono gli stessi se vogliamo \textit{provare} che $ G $ \textit{non} ha un tour Euleriano.
				
			\end{itemize}
			
			\item (\textbf{Hamiltonian Cycle}) Esiste un modo per attraversare ogni nodo di un grafo una e una sola volta? 
			
			Esistono diverse soluzioni:
			\begin{itemize}
				\item Provo tutte le possibilità ogni volta, costo: $ O(2^n) $
				\item Provo tutte le possibili permutazioni, costo: $ O(n!) $
				\item La soluzione migliore ad oggi è: $ O(1.657^n) $
			\end{itemize}
			Alla domanda: \textit{Quanto costa decidere se un grafo ha un tour hamiltoniano?} Non sappiamo rispondere. Non sappiamo dire se il problema ha una soluzione non esponenziale. Per quanto ne sappiamo meglio di $ O(1.657^n) $ non sappiamo fare.
			
			Non sappiamo nemmeno dire se Hamiltonian Cycle è più difficile di Eulerian Cycle.
			\item N è un numero primo?
			
			Il migliore algoritmo conosciuto per decidere se N è un numero primo impiega $ O((\log N)^{6 + \epsilon}) $
			\item Quali sono i fattori primi di un numero?
			
			Ad oggi non conosciamo una procedure per fattorizzare un numero molto grande nei suoi divisori, che non sia provare tutte le possibilità.
		\end{enumerate}
		
		\subsection{Risolvere vs Verificare}
			La seguente tabella riassume in modo generico quanto detto nella sezione precedente riguardo alla difficoltà di risolvere problemi e verificare tali problemi su un istanza.
			
			\begin{table}[h]
				\centering
				\caption{Risolvere vs Verificare}
				\label{tab:intro}
				\begin{tabular}{lcc}
					\toprule
					\textbf{Problema} & \textbf{Risolvere} & \textbf{Verificare} \\
					\midrule
					Eulerian Cycle & \textit{facile} & \textit{facile} \\
					Hamiltonian Cycle & \textit{difficile?} & \textit{facile} \\
					N è primo? & \textit{facile} & \textit{facile} \\
					N ha un numero piccolo di fattori? & \textit{difficile?} & \textit{facile} \\
					\bottomrule
				\end{tabular}
			\end{table}
		
	\section{Problema computazionale}
		Un problema computazionale è una semplice relazione $ p $ che mappa l'insieme \textit{infinito} di possibili input (domande o istanze) con un insieme \textit{finito} (non vuoto) di output, cioè di risposte o soluzioni alle istanze.
		\[
			p\ \colon\ \text{istanze infinite}\ \mapsto\ \text{soluzioni finite alle istanze} 
		\]
		Un problema computazionale non è una singola domanda, ma è una \textbf{famiglia di domande}:
		\begin{itemize}
			\item Una domanda per ogni possibile istanza
			\item Ogni domanda è dello stesso tipo (appartiene alla stessa classe)
		\end{itemize}
		
		\begin{esempio}
			Il seguente esempio è un problema computazionale:
			\begin{itemize}
				\item Input: Qualsiasi grafo G
				\item Domanda: Il grafo G contiene un ciclo Euleriano?
			\end{itemize}
		\end{esempio}
		\begin{esempio}
			Il seguente esempio \textit{non} è un problema computazionale:
			\begin{itemize}
				\item Domanda: È vero che il bianco vince sempre a scacchi, sotto l'ipotesi della giocata perfetta?
			\end{itemize}
			Non è un problema computazionale perché non ho un insieme infinito di possibili partite in input.
		\end{esempio}
		
		\subsection{Risolvere un problema computazionale}
			Risolvere un problema computazionale significa trovare un \textbf{algoritmo}, cioè una procedura che risolve il problema matematico in un numero finito di passi (di computazione elementare), che solitamente include la ripetizione di un operazione. È un procedimento deterministico che mappa l'input sull'output.
			\epigraph{
				Un algoritmo è una procedura \textit{finita}, \textit{definita}, \textit{efficace} e con un input e un output.}{\textit{Donald Knuth -- The Art of Computer Programming }}
			
		\subsection{Complessità di un problema computazionale}
		\paragraph{Misura della complessità.}
			Come misuro la complessità di un problema computazionale? Come faccio a dire quanto è facile rispetto ad altri problemi?
			\begin{itemize}
				\item Do un \textbf{upper bound}: trovo un algoritmo qualsiasi che risolve il problema in modo da calcolare qual è il suo costo.
				\item Do un \textbf{lower bound}: trovo la minima quantità di risorse che ogni algoritmo utilizza per risolvere il problema. Tutti gli algoritmi sono \textit{al minimo} complessi come il limite inferiore che abbiamo stabilito. Nessuno può fare di meglio.
			\end{itemize}
			
			\begin{figure}[h]
				\centering
				\begin{tikzpicture}
					\draw (0,0) -- (0,-3);
					\node[right, xshift=.1cm] at (0,-.5) {$ O(n^2) $};
					\node[right, xshift=.1cm] at (0,-2.5) {$ \Omega (n) $};
					\draw[ultra thick] (0,-.5) -- (0,-2.5);
					\draw (-.15,-.5) -- (.15,-.5); \draw (-.15,-2.5) -- (.15,-2.5);
				\end{tikzpicture}
			\end{figure}
			
			\subsection{Trattabilità di un problema.} La crescita della complessità di un problema è riducibile a 2 categorie fondamentali.
			
			\paragraph{Crescita polinomiale.} Un problema ha crescita polinomiale quando le risorse necessarie alla sua risoluzione sono limitate ad $n^k$, per qualche $k$. Se la taglia del problema aumenta, la sua complessità aumenta di un qualche fattore costante. Infatti, se la taglia dell'input va da $n$ a $2n$ allora la complessità del problema si modifica in $(2n)^k = 2^kn^k$, ovvero aumenta di un fattore $2^k$ (costante). Raggruppiamo nella classe $\p$ i problemi di questo tipo.
			
			\paragraph{Crescita esponenziale.} Un problema ha crescita esponenziale la necessità di risorse necessarie alla sua risoluzione è proporzionale a $c^n$, per qualche costante $c > 1$. Se la taglia dell'input va da $n$ a  $2n$ $c^n$ allora la richiesta di risorse si diventa $c^{2n} = c^n * c^n$, aumentando quindi di un fattore che cresce con l'aumentare di $n$. Raggruppiamo nella classe $\Exp$ i problemi di questo tipo.
			
			\section{Le classi di problemi computazionali}
			\paragraph{Notazione e idee di base.}
			Formalmente definiamo un problema come un elemento $ \prob{A} $ di una relazione 
			\[ 
				\mathcal{R} \subseteq \instance{A} \times Sol 
			\] 
			dove: 
			\begin{itemize}
				\item $\instance{A}$ è l'insieme delle istanze del problema $\prob{A}$
				\item $Sol$ è l'insieme delle soluzioni delle istanze di $\prob{A}$
			\end{itemize}
			Si può quindi dire che 
			\[ 
				\forall x \in \instance{A},\ Sol(x) = \lbrace \text{Soluzioni di } x \rbrace 
			\]
			
			Non è restrittivo restringersi ai \textbf{problemi di tipo decisionale}, ovvero quei problemi che hanno come soluzione una risposta del tipo \textit{si} o \textit{no}, quindi i problemi del tipo \[ \prob{A} : \instance{A} \to \lbrace yes, no \rbrace \]
			
			
			L'algoritmo $\alg{A}$ per un problema $\prob{A}$ è un algoritmo che dato il problema, $\forall x \in \instance{A},\ \alg{A}(x) = \prob{A}(x)$. Inoltre, dato un algoritmo $ \alg{A} $, definiamo $\compl{A}{x}$ la sua \textbf{complessità}, cioè il \textit{tempo che impiega} $\alg{A}$ sull'istanza di taglia $\vert x \vert$. Notare che $\vert x \vert$ è la taglia dell'istanza $x$.
			
			\subsection{Classe P} 
			Intuitivamente la classe $\p$ è definita come la classe di problemi di \textbf{complessità polinomiale}. Introduciamo qui la definizione formale.
			
			\begin{definit}[Classe P]
				Definiamo la classe di problemi $\p$ come l'insieme dei problemi di complessità polinomiale, ovvero 
				\[ 
					\p = \big\lbrace \prob{A}\ \vert\ \exists \alg{A}\ t.c.\ \exists c \text{ costante e }\ \forall x \in \instance{A},\ \ \alg{A}(x) = \prob{A}(x)\ \text{ e }\ \compl{A}{x} \leq \vert x \vert ^ c \big\rbrace 
				\]
			\end{definit}
			
			\begin{esempio}[Eulerian Cycle]
				Un semplice esempio di problema appartenente alla classe $\p$ è il problema del tour euleriano. Per questo problema infatti abbiamo che è un problema computazionale di decisione:
				\begin{itemize}
					\item Input: grafo $ G $
					\item Output: $ yes \Leftrightarrow \exists $ Eulerian Cycle in $ G $.
				\end{itemize}
				Come abbiamo già visto quindi:
				\[
					\exists \alg{A}\ t.c.\ \compl{A}{G} = O(\vert E\vert + \vert V\vert) = O(\vert G\vert) 
				\] 
				Eulerian Cycle $ \in \p\ $ perché $\ \exists \alg{A}\ $ che impiega un tempo che è nell'ordine della taglia di $ G $, in particolare $ \ \exists c \text{ costante } $ dove $ c=1 $.
			\end{esempio}
			
			
			\begin{esempio}[Hamiltonian Cycle]
				Ci chiediamo allora se anche Hamiltonian Cycle $ \in \p\ $ ? La risposta è che non lo sappiamo dire. Quello che sappiamo per questo problema è che:
				\[
					\exists \alg{A}\ t.c.\ \compl{A}{G} = O(a^{\vert G \vert})
				\]
				dove $ a $ è costante.
			\end{esempio}
			
			\subsection{Classe Exp}
			Dal momento che non sappiamo se alcuni problemi stiano oppure no nella classe $\p$ (dal momento che non si conosce un algoritmo che li risolva in tempo polinomiale), si definisce la classe $\Exp$, che racchiude tutte le istanze di questa tipologia di problemi di \textbf{complessità esponenziale}.
			
			\begin{definit}[Classe Exp]
				Definiamo la classe di problemi $\Exp$ come la classe di problemi di complessità esponenziale, ovvero 
				\[ 
					\Exp = \big\lbrace \prob{A}\ \vert\ \exists \alg{A}\ t.c.\ \forall x \in \instance{A},\ \alg{A}(x) = \prob{A}(x)\ \text{ e }\ \compl{A}{x} \leq 2^{\vert x \vert ^ c} \big\rbrace 
				\]
			\end{definit}
			
			\begin{esempio}[Hamiltonian Cycle]
				Ci chiediamo se Hamiltonian Cycle $ \in \Exp$ ? Se prendiamo l'algoritmo che prova tutte le combinazioni di archi cioè $ \binom{\vert E \vert}{n} $ per vedere se formano un ciclo hamiltoniano. La complessità di quest'algoritmo è al massimo $\ 2^{\vert E \vert^2} $. 
				
				Se invece prendiamo l'algoritmo che considera tutte le possibili permutazioni dei vertici del grafo abbiamo che la complessità è $ n! $. Quindi il problema Hamiltonian Cycle $ \notin \Exp $
			\end{esempio}
			
			\paragraph{Relazione tra P ed Exp.} La domanda che sorge spontanea è $ \p \subseteq \Exp $ ?
			
			La risposta alla domanda è banalmente \textbf{si}, in quanto, dato un algoritmo $ \alg{B} $ con complessità $\compl{B}{x}$, possiamo dire che 
			\[ 
				\compl{B}{x} = O(\vert x \vert ^ c) = O(2^{\vert x \vert ^ c}) \Rightarrow \prob{A} \in \Exp 
			\]
			
			\paragraph{Problema K-Graph-Colouring.} Analizziamo ora il problema della K-colorabilità di un grafo $ G $:
			\begin{itemize}
				\item Input: $ G $ non orientato.
				\item Output: $ yes \Leftrightarrow \exists\ $ colorazione \textit{propria} dei vertici di $ G $ ovvero:
				\[
					\exists f\ \colon\ v \mapsto \{0,\dots, k-1 \}\quad t.c.\quad \forall (u,v)\in E(G)\quad f(u) \neq f(v)
				\]
			\end{itemize}
			
			\begin{figure}[h!]
				\centering
				\begin{subfigure}{.5\textwidth}
					\centering
					\begin{tikzpicture}
						\node[draw, circle] (a) at (0,0) {};
						\node[draw, circle, fill=black] (b) at (1.5,1) {};
						\node[draw, circle] (c) at (3,0) {};
						\node[draw, circle, fill=black] (d) at (1.5,-1) {};
						\draw (a) -- (b) -- (c) -- (d) -- (a) -- (c);
					\end{tikzpicture}
					\caption{Grafo con colorazione \textit{non} propria}
				\end{subfigure}%
				\begin{subfigure}{.5\textwidth}
					\centering
					\begin{tikzpicture}
						\node[draw, circle, fill=gray] (a) at (0,0) {};
						\node[draw, circle, fill=black] (b) at (1.5,1) {};
						\node[draw, circle] (c) at (3,0) {};
						\node[draw, circle, fill=black] (d) at (1.5,-1) {};
						\draw (a) -- (b) -- (c) -- (d) -- (a) -- (c);
					\end{tikzpicture}
					\caption{Grafo con colorazione propria}
				\end{subfigure}%
			\end{figure}
			
			\paragraph{Problema 2-Graph-Colouring.}
			Consiste nel trovare se esiste una 2 colorazione del grafo dato in input in modo tale che un arco non si trovi tra due vertici dello stesso colore. Questo problema corrisponde a dire se il grafo è \textbf{bipartito}, cioè se \textit{posso suddividere il grafo in due classi diverse}. \\
			Per vedere se è bipartito si effettua una \textbf{BFS}, cioè una visita in ampiezza, e si controlla se c'è un ciclo dispari. Se c'è allora non è bipartito e quindi nemmeno 2-colorabile.\\
			
			\noindent
			È 2-colorabile $ \Leftrightarrow $ è Bipartito $ \Leftrightarrow $ non contiene un ciclo dispari. La visita BFS ha una complessità pari a $ O(\vert E \vert + \vert V \vert) $, perciò il problema è risolvibile in tempo polinomiale, perciò possiamo concludere che 2-Graph-Colouring $ \in \p $.
			
			\paragraph{Problema 3-Graph Colouring}
			Il problema 3-Graph Colouring $ \in \p $? Non sappiamo rispondere a questa domanda, poiché non sappiamo se esiste un algoritmo che lo svolga in tempo polinomiale.\\
			Il problema 3-Graph Colouring $ \in \Exp $? Se consideriamo l'algoritmo che prova tutte le possibili colorazioni abbiamo che:
			\[
				3^n \text{ sono le colorazioni dei vertici, dove }\ n = \vert V(G) \vert 
			\]
			Bisogna vedere se ci sono archi monocolore e quindi la complessità diventa:
			\[
				O(3^n\cdot\vert E \vert) = O(3^{2n}) = O((2^{\log_2 3})^{2n}) = O(2^{2n\log_2 3})
			\]
			Perciò possiamo concludere che il problema 3-Graph Colouring $ \in \Exp $.
		
			\subsection{Classe Time(n)}
			
			\begin{definit}[Classe Time(n)]
				Definiamo la classe $ \tim $ come l'insieme dei problemi di complessità lineare, ovvero
				\[
					\tim = \big\lbrace \prob{A}\ \vert\ \exists \alg{B} \text{ per } \prob{A}\quad t.c.\quad
					\forall x \in \instance{A}\quad \compl{\alg{B}}{x} = O(n) = O(f(\vert x \vert))\ \big\rbrace  
				\]
			\end{definit}
			
			\begin{thm}
				$ \forall \alg{B}\quad t.c.\quad \alg{B}(x) = \prob{A}(x)\quad \compl{\alg{B}}{x} > \vert x \vert^c\quad \forall c\text{ costante} $
			\end{thm}
			
			\begin{thm}
				\label{thm:sort}
				Qualsiasi \textbf{algoritmo di ordinamento} che usa \textit{confronti} su $ n $ elementi ha tempo di esecuzione pari a
				\[
					\Omega(n\log n)
				\]
			\end{thm}
			
			\noindent
			Possiamo dire quindi che:
			\begin{itemize}
				\item \textbf{Eulerian Cycle} $ \in \tim $ perché esiste un problema che lo risolve in tempo lineare.
				\item \textbf{Sorting} $ \notin \tim $ per il teorema \ref{thm:sort}.
			\end{itemize}
			
			\begin{figure}[h]
				\centering\vspace{-.2cm}
				\begin{tikzpicture}[scale=.5,every node/.style={scale=0.8}]
					\draw (0,0) circle (3cm);
					\draw (-.5,0) circle (2cm);
					\draw (-1,0) circle (1cm);
					\node at (2.25,0) {$ \Exp $};
					\node at (.75,0) {$ \p $};
					\node at (-1,0) {$ \tim $};
				\end{tikzpicture}
			\end{figure}
			
			\newpage
			
			Possiamo riassumere quindi che:
			\begin{itemize}
				\item \textbf{Eulerian Cycle} $ \in \p $, \textbf{Eulerian Cycle} $ \in \tim $.
				\item \textbf{Hamiltonian Cycle} $ \in \Exp $
				\item \textbf{Hamiltonian Cycle} $ \in \p $ ? non lo sappiamo dire.
				\item \textbf{K-Colouring} $ \in \Exp $
				\item \textbf{K-Colouring} $ \in \p $? \\
				per $ k\geq 3 $ non lo sappiamo dire\\
				per $ k = 2 $ sì.
			\end{itemize}
			Inoltre, con la definizione della classe $ \tim $ si può dire che:
			\[
				\p = \bigcup_{k \geq 0} \mathbf{Time(n^k)}
			\]
			\[
				\Exp = \bigcup_{k\geq 0} \mathbf{Time(2^{n^k})}
			\]
			
		\subsection{Classe NP}
			La classe $ \np $ (\textit{non deterministic polinomial time}) è la classe di problemi tali che se la soluzione per un'istanza del problema è \textit{yes}, allora è facile verificarlo.
			
			\begin{definit}(Classe NP)
				\begin{align*}
					\np = \big\lbrace & \prob{A} \quad \big| \quad \exists \alg{B}(\stackrel{x}{\cdot}, \stackrel{w}{\cdot})\quad t.c.\quad 
					\compld{\alg{B}}{x}{w}= O((\vert x\vert + \vert w\vert)^c) \\
					& \forall x \in \instance{\prob{A}}\quad \prob{A}(x) = yes\ \Leftrightarrow\ \exists w\ t.c.\quad \vert w \vert = O(\vert x\vert^d)\ \text{ e }\ \alg{B}(x, w) = yes 
					\big\rbrace
				\end{align*}
					
				dove:
				\begin{itemize}
					\item $ \alg{B}(\stackrel{x}{\cdot}, \stackrel{w}{\cdot}) $ è detto \textbf{verificatore} per $ \prob{A} $. Se la risposta di $ \prob{A} $ esiste, allora $ \alg{B} $ dice \textit{yes}. Il verificatore impiega \textbf{tempo polinomiale} nella taglia dell'istanza per rispondere.
					\item $ x $ è l'istanza
					\item $ w $ è il certificato.
				\end{itemize}
				
			\end{definit}
			
			\paragraph{Hamiltonian Cycle $ \in $ NP ?} Per vedere se il problema Hamiltonian cycle appartiene alla classe $ \np $ dobbiamo costruire un verificatore $ \alg{B} $ che agisca in tempo polinomiale.
			
			\begin{lstlisting}[mathescape=true, frame=tb]
VerifyHamCycle(G = (V,E), C=$ x_1, \dots, x_n $)
	if r != |V|: return $ no $ "\tikzmark{a}"
	for each v$ \in $ V 
		if v non appare in C: return $ no $ "\tikzmark{c}"
	for i=1 to n-1
		if $ ( x_i, x_{i+1} )\notin $ E: return $ no $ "\tikzmark{b}"
	if $ ( x_1, x_n )\notin $ E: return $ no $ "\tikzmark{d}"
	return $ yes $
			\end{lstlisting}
			\begin{tikzpicture}[overlay, remember picture,decoration={brace,amplitude=2pt}]
				\draw[decorate,thick] ($ (a.east) +(2.7,-0.1) $) -- ($ (a.east) +(2.7,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(\vert w\vert) $};
				\draw[decorate,thick] ($ (c.east) +(0,.4) $) -- ($ (c.east) +(0,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(\vert V\vert\cdot\vert C\vert) $};
				\draw[decorate,thick] ($ (b.east) +(1.5,.4) $) -- ($ (b.east) +(1.5,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(\vert C\vert) $};
				\draw[decorate,thick] ($ (d.east) +(2.6,-0.1) $) -- ($ (d.east) +(2.6,-.5) $)
				node [midway,right, xshift=.2cm] {$ O(1) $};
			\end{tikzpicture}
		Il tempo di esecuzione del verificatore è polinomiale e quindi posso dire che Hamiltonian Cycle $ \in \np$ .
			
		\paragraph{K-Colouring $ \in $ NP ?} Per vederlo costruisco il verificatore:
		\begin{lstlisting}[mathescape=true, frame=tb]
VerifyK-Colouring(G = (V,E), $ f(v_1), \dots, f(v_n) $)
	for each $ E(u,v)  $
		if $ f(u) = f(v) $: return $ no $ "\tikzmark{a}"
	for i=1 to n
		if $ f(v_i) \geq K $: return $ no $ "\tikzmark{b}"
	return $ yes $
		\end{lstlisting}
		\begin{tikzpicture}[overlay, remember picture,decoration={brace,amplitude=2pt}]
			\draw[decorate,thick] ($ (a.east) +(0,.4) $) -- ($ (a.east) +(0,-.5) $)
			node [midway,right, xshift=.2cm] {$ O(\vert E\vert) $};
			\draw[decorate,thick] ($ (b.east) +(0.2,.4) $) -- ($ (b.east) +(0.2,-.5) $)
			node [midway,right, xshift=.2cm] {$ O(\vert V\vert) $};
		\end{tikzpicture}
		Il tempo di esecuzione del verificatore è polinomiale e quindi posso dire che K-Colouring $ \in \np$ .
		
		\paragraph{P $ \subseteq $ NP ?} Vogliamo capire in che classe è $ \np $. Se include la classe $ \p $ allora significa che un problema che appartiene a quest'ultima, se lo sappiamo risolvere, lo sappiamo anche verificare. Infatti se $ \prob{A} \in \p $ dobbiamo dimostrare che esiste un verificatore. Tale verificatore per $ \prob{A} $ sarà: $\quad \alg{B}'(x,w) = \alg{B}(x)\ $ privo di certificato.
		Dobbiamo dimostrare che se l'istanza è \textit{yes} allora $ \alg{B}(x) = yes $ altrimenti $ \alg{B}(x) = no $.
		
		\paragraph{NP $ \subseteq $ Exp ? } Vogliamo capire in che classe è $ \np $
		
		Possiamo supporre che $ \p \subseteq \np \subseteq \Exp $.
		
		\begin{figure}[h!]
			\centering
			\begin{tikzpicture}
			\draw (0,0) ellipse (3.5cm and 2cm);
			\draw (-.5,0) ellipse (2.5cm and 1.5cm);
			\draw (-1,0) ellipse (1cm and 1cm);
			\node at (2.5,.5) {$ \Exp $};
			\node (np) at (.75,.5) {$ \np $};
			\node (p) at (-1,.5) {$ \p $};
			\node at ($ (p.south) +(0,-.2) $) {eulercycle};
			\node at ($ (p.south) +(0,-.5) $) {2-colouring};
			\node[rotate=20] at ($ (np.south) +(0,-.7) $) {hamcycle};
			\node[rotate=20] at ($ (np.south) +(-.5,-1.2) $) {k-colouring};
		\end{tikzpicture}
		\end{figure}
		
	\section{Riduzione alla Karp tra problemi di decisione}
		\begin{definit}[Riduzione alla Karp]
			Un problema di decisione $ \prob{A} $ si riduce alla Karp al problema $ \prob{B} $: $ \quad \prob{A} \leqslant_K \prob{B} \quad $ se esiste un algoritmo polinomiale $ \alg{A} $ tale che 
			\[
				\forall x \in \instance{A},\ \prob{B}(\alg{A}(x)) = yes \ \Leftrightarrow \ \prob{A}(x) = yes
			\]
		\end{definit}
		
		\begin{prop}
			Se $ \prob{A} \leqslant_K \prob{B} \quad\text{ e }\quad \prob{B}\in \p \quad \Rightarrow\quad \prob{A}\in\p $
		\end{prop} 
		\begin{prop}
			Se $ \prob{A} \leqslant_K \prob{B} \quad\text{ e }\quad \prob{B}\notin \p \quad \Rightarrow\quad \prob{A}\notin\p $
		\end{prop} 
		
		Come effettivamente svolgiamo le trasformazioni?
		
		\subsection{Problema SAT}
			\begin{definit}[SAT]
				Il problema di soddisfacibilità di una formula booleana è definito nel seguente modo:
				\begin{itemize}
					\item Input: formula booleana : $ \phi (x_1, \dots, x_n) = C_1 \wedge C_2 \wedge \dots \wedge C_n $\\
					Dove: \begin{itemize}
						\item $ C_i = l_{i1} \vee l_{i2} \vee \dots \vee l_{ik} $ (clausola)
						\item $ l_{ij} = x_k \text{ oppure } \bar{x}_k $ (letterale)
					\end{itemize}
					\item Output: \textit{yes} $ \Leftrightarrow\quad\exists a_1\dots a_n \in {T,F}^n\quad t.c.\quad \phi(a_1,\dots, a_n) = T $ 
				\end{itemize}
			\end{definit}
			
			\begin{esempio}
				$ \phi(x_1, x_2, x_3) = (x_1\vee \bar{x}_2\vee x_3)\wedge (\bar{x}_1\vee\bar{x}_2\vee x_3) \wedge (x_1\vee \bar{x}_3) $ \\
				Assegnamento che soddisfa la formula booleana $ \phi(x_1, x_2, x_3) $:
				\begin{align*}
					x_1 =& T\quad x_2 = F\quad x_3 = F \\
					a_1 =& T\quad a_2 = F\quad a_3 = F
				\end{align*}
			\end{esempio}
			
		\paragraph{SAT $ \in $ NP ?} Ci chiediamo se il problema SAT sta nella classe $ \np $. Vediamo dunque se esiste un certificato e un verificatore che attesta, dato una formula booleana, se essa è soddisfacibile in tempo polinomiale.
		\begin{itemize}
			\item Si può notare facilmente che il certificato è un assegnamento per la formula booleana, dunque è polinomialmente correlato alla grandezza delle variabili della formula, sarà al massimo $ n $.
			\item Il verificatore viene costruito analizzando la formula booleana, controllando ogni letterale di ciascuna clausola. Ho quindi $ m\times n \times n $ controlli, dove $ m = $ numero di clausole, $ n = $ numero di letterali. Il verificatore è quindi polinomiale.
		\end{itemize}
		Possiamo concludere che il problema SAT $ \in \np $. Questa affermazione si può tradurre con: \textit{data una formula booleana di cui sappiamo essere soddisfacibile, allora è facile (polytime) costruire un verificatore che attesta che essa è SAT.}
		
		\paragraph{Problema K-SAT:} è il problema SAT in cui l'input ha come restrizione il vincolo che ogni clausola ha esattamente $ k $ letterali.
		
		\begin{esempio}[3-SAT]
			$ \phi(x_1, x_2, x_3) = (x_1\vee x_2 \vee x_3)\wedge (\bar{x}_1\vee x_2 \vee x_3 ) \wedge (\bar{x}_1 \vee x_2\vee \bar{x}_3) $
		\end{esempio}
		  
		\subsection{Alcuni esempi di riduzioni tra problemi}
			\paragraph{K-colouring $ \leq_K $ (K+1)-colouring} Vediamo se il problema (K+1)-colouring non è più facile del problema K-colouring. Dobbiamo in sostanza dimostrare che decidere se possiamo colorare un grafo con $ k+1 $ colori non è più facile che decidere se possiamo colorare un grafo con $ k $ colori. \textbf{N.B.:} da notare che i due grafi non sono necessariamente uguali, parliamo di qualsiasi grafo che appartiene al problema.
			
			\begin{align*}
				\alg{A}\ : \quad & x\in \mathcal{I}(K-COL)\quad \mapsto\quad \alg{A}(x)\in \mathcal{I}((K+1)-COL) \\
							 & K-COL(x) = yes\quad \Leftrightarrow\quad (K+1)-COL(\alg{A}(x)) = yes   
			\end{align*}
			
			Prendiamo quindi il grafo $ G' $:
			
			\begin{center}
				\begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
					\draw (0,0) ellipse (3cm and 2cm);
					\draw (-1,-.5) circle (1cm);
					\node at (0,1.7) {$ G' = \alg{A}(x) $};
					\node at (-1,-.5) {$ G = x$};
					\node[draw, circle] (a) at (-.5,0) {}; \node[draw, circle] (b) at (-.5,-.9) {};
					\node[draw, circle] (c) at (-1.3,0) {};
					\node[draw, circle] (d) at (1,1) {};
					\draw[bend right] (d) to (c); \draw[bend left] (d) to (b); \draw (d) -- (a);
				\end{tikzpicture}
			\end{center}
			per cui
			\begin{align*}
				G &= (V, E) \\
				G'&= (V \cup \{v'\}, E \cup {(v, u')\ \vert\ v \in V})
			\end{align*}
			in tempo lineare e quindi sotto il polinomiale riesco a costruire il grafo G'.\\
			Se G è K-colorabile allora G' è (K+1)-colorabile. Mi basta assegnare a $ v' $ il colore $ k $ (il k+1-esimo colore) e mantenere la colorazione di G.\\
			Se G non è K-colorabile allora G' non è K+1-colorabile. Equivale a dire che se G' è K+1-colorabile allora G è k-colorabile. Quindi se $ v' $ ha un colore $ f(v') = x $ allora ogni $ v \in V(G) $ ha un colore $ f(v') \neq x $, al più usano k colori.
			
			Da questa dimostrazione ricaviamo anche che 2-col $ \leq_K $ 3-col $ \leq_K $ 4-col $ \leq_K $ 5-col
			
			
			\paragraph{SAT $ \leq_K $ 3-SAT} Vogliamo dimostrare che data una formula booleana $ \phi $ CNF esiste una trasformazione polytime che mi porta a una formula booleana $ \phi' $ 3CNF (ogni clausola ha esattamente 3 letterali). E inoltre che $ \phi $ è soddisfacibile se e solo se $ \phi' $ è soddisfacibile.
			
			Possiamo iniziare dicendo che $ \ (x_1 \vee x_2) \equiv (x_1 \vee x_1 \vee x_2) $. Le clausole più piccole possono essere espanse. Seguendo questa intuizione arriviamo a dire che:
			\begin{align*}
				&(l_1 \vee l_2 \vee l_3 \vee \dots \vee l_k)\quad \rightsquigarrow\quad \\
				&(l_1\vee l_2\vee z_1) \wedge (\bar{z}_1\vee l_3 \vee z_2) \wedge (\bar{z}_2 \vee l_4\vee z_3)
				\wedge (\bar{z}_3 \vee l_5 \vee z_4) \wedge \dots \wedge (\bar{z}_{k-1} \vee l_{k+1} \vee z_k)
			\end{align*}
			
			Dimostriamo che se $ \phi $ non è soddisfacibile allora non lo è neanche $ \phi' $.
			\begin{itemize}
				\item Prendiamo $ \phi = (x_1 , \dots, x_n) $. Per questa formula prendiamo un assegnamento $ a_1, \dots, a_n $ che non la rende soddisfacibile, quello in cui ogni letterale viene assegnato a F.
				\item Prendiamo dunque $ \phi' = (x_1, \dots, x_n, z_1, \dots z_r) $. Per questa formula prendiamo lo stesso assegnamento di $ \phi $ e vediamo cosa succede con i letterali $ z $:
			\[
				(\underset{F}{l_1} \vee \underset{F}{l_2}\vee \underset{V}{z_1}) 
				\wedge (\underset{F}{\bar{z}_1}\vee \underset{F}{l_3} \vee \underset{V}{z_2}) 
				\wedge (\underset{F}{\bar{z}_2}\vee \underset{F}{l_4} \vee \underset{V}{z_3}) 
				\wedge (\underset{F}{\bar{z}_3}\vee \underset{F}{l_5} \vee \underset{V}{z_4})  \wedge 
				\dots \wedge (\underset{F}{\bar{z}_{k-1}}\vee \underset{F}{l_{k+1}} \vee \underset{F}{z_{k}}) 
			\]
			risulta che l'ultimo letterale $ z_k $ è falso, e quindi $ \phi' $ non è soddisfacibile.
 			\end{itemize}
 			
 			\paragraph{K-COL $ \leq_K $ K-SAT} Vogliamo dimostrare che il problema di colorare un grafo con k colori è riducibile al problema di soddisfacibilità di una formula booleana k-CNF.
 			
 			Cerchiamo un modo per esprimere in modo logico il fatto che due nodi adiacenti non abbiano lo stesso colore.
 			Supponiamo che il nodo $ v $ abbia colore $ i $ e il nodo $ u $ abbia colore $ i $ con $ i= 0,1, \dots, k-1 $.
 			Per ogni $ v \in V $: $ \quad x_0^{(v)} \ x_1^{(v)} \ x_2^{(v)} \dots \ x_{k-1}^{(v)}  $ dove $ x_i^{(v)} = T $ se il vertice $ v $ ha colore $ i $.
 			
 			Ci chiediamo quindi quand'è che la formula è K-colorabile?
 			\[
	 			\forall v \in V
	 			\begin{cases}
		 			x_0^{(v)} \vee x_1^{(v)} \vee x_2^{(v)} \vee \dots \vee x_{k-1}^{(v)} \quad \text{ogni vertice ha un colore}\\ \\
		 			\overline{x_i^{(v)} \wedge x_j^{(v)}} = \overline{x_i^{(v)}} \vee \overline{x_j^{(v)}} \quad \forall i,j
	 			\end{cases}
 			\]
	 		\[
		 		\forall e =(u, v) \in E\ \text{ i due vertici non devono avere lo stesso colore}
	 		\]
	 		\[
		 		\forall i \quad \overline{x^{(v)}_i \wedge x_i^{(u)}} =
		 		\overline{x_i^{(v)}} \vee \overline{x_i^{(u)}}
	 		\]
	 		
	 		\begin{esempio}

	 			Prendiamo per esempio il seguente grafo:	 
	 			\begin{center}
					\begin{tikzpicture}
						\node[draw, circle] (u) at (0,0) {u};
						\node[draw, circle] (v) at (0,-1.5) {v};
						\node[draw, circle] (z) at (1.5,-.75) {z};
						\draw (u) -- (v) -- (z) -- (u);
					\end{tikzpicture}
				\end{center}
	 			La formula booleana corrispondente sarà:
	 			\begin{align*}
		 			&\tikzmark{a}(x_0^{(u)} \vee x_1^{(u)} \vee x_2^{(u)}) \wedge 
		 			\tikzmark{c}(\overline{x_0^{(u)}} \vee \overline{x_1^{(u)}}) \wedge
		 			(\overline{x_0^{(u)}} \vee \overline{x_2^{(u)}}) \wedge
		 			(\overline{x_1^{(u)}} \vee \overline{x_2^{(u)}})\tikzmark{d} \wedge \\
		 			&(x_0^{(v)} \vee x_1^{(v)} \vee x_2^{(v)}) \wedge 
		 			(\overline{x_0^{(v)}} \vee \overline{x_1^{(v)}}) \wedge
		 			(\overline{x_0^{(v)}} \vee \overline{x_2^{(v)}}) \wedge
		 			(\overline{x_1^{(v)}} \vee \overline{x_2^{(v)}}) \wedge \\
		 			&\tikzmark{b}(x_0^{(z)} \vee x_1^{(z)} \vee x_2^{(z)}) \wedge 
		 			(\overline{x_0^{(z)}} \vee \overline{x_1^{(z)}}) \wedge
		 			(\overline{x_0^{(z)}} \vee \overline{x_2^{(z)}}) \wedge
		 			(\overline{x_1^{(z)}} \vee \overline{x_2^{(z)}}) \wedge \\
		 			&\tikzmark{e}(\overline{x_0^{(v)}} \vee \overline{x_0^{(u)}}) \wedge
		 			(\overline{x_1^{(v)}} \vee \overline{x_1^{(u)}}) \wedge
		 			(\overline{x_2^{(v)}} \vee \overline{x_2^{(u)}}) \wedge \\
		 			&(\overline{x_0^{(v)}} \vee \overline{x_0^{(z)}}) \wedge
		 			(\overline{x_1^{(v)}} \vee \overline{x_1^{(z)}}) \wedge
		 			(\overline{x_2^{(v)}} \vee \overline{x_2^{(z)}}) \wedge \\
		 			&\tikzmark{f}(\overline{x_0^{(z)}} \vee \overline{x_0^{(u)}}) \wedge
		 			(\overline{x_1^{(z)}} \vee \overline{x_1^{(u)}}) \wedge
		 			(\overline{x_2^{(z)}} \vee \overline{x_2^{(u)}})
	 			\end{align*}
				
				\begin{tikzpicture}[overlay, remember picture,decoration={brace,amplitude=3pt}]
					\draw[decorate,thick] ($ (b) +(-0.3,-.2) $) -- ($ (a) +(-0.3,.2) $)
					 node[midway, left, align=left] {Ogni vertice\\ ha un colore}; 
					\draw[decorate,thick] ($ (f) +(-0.3,-.2) $) -- ($ (e) +(-0.3,.2) $)
					 node[midway, left, align=left] {Ogni arco ha\\ colori diversi}; 
					\draw[decorate,thick] ($ (c) +(0,.5) $) -- ($ (d) +(0,.5) $)
					node[midway, above, align=left] {Un vertice non\\ può avere 2 colori}; 
					
				\end{tikzpicture}
	 		\end{esempio}
	 	La trasformazione è polinomiale? La complessità della trasformazione è:
	 	\[
		 	\vert V \vert \cdot \Big(K + 2 \binom{k}{2}\Big) + \vert E \vert K\cdot 2 \quad \leq\quad
		 	(\vert E \vert + \vert V \vert) K^2
	 	\]
		Quindi è polinomiale.
	 	
	 \subsection{Problema NAE-K-SAT}
		 \paragraph{NAE-K-SAT (Not All Equivalent-K-SAT):} 
		 \begin{itemize}
		 	\item Input: $ \phi $ K-CNF $ \quad \phi:\ \{T,F\}^n \mapsto \{T,F\} $
		 	\item Output: $ yes \ \Leftrightarrow \ \exists \underline{a} \in \{T,F\}^n \quad t.c.\quad \phi(\underline{a}) = T \ $ e, in ogni clausola $ \ C_i = l^{(i)}_1 \vee l^{(i)}_2 \vee \dots \vee l^{(i)}_k \ $ con $ \ \underline{a} \ $, almeno un $ \ l^{(i)}_j \ $ è vero e almeno un $ \ l^{(i)}_j \ $ è falso.
 		 \end{itemize}
 		 
 		 \begin{esempio}
 		 	\[
	 		 	\phi(x_1, x_2, x_3) = (\overline{x_1} \vee x_2 \vee x_3) \wedge (\overline{x_1} \vee \overline{x_2} \vee \overline{x_3})
 		 	\]
		 	\begin{align*}
	 		 	x_1 =& F \quad x_2 = F \quad x_3 = F \quad \text{\textit{non} è NAE-K-SAT}\\
	 		 	x_1 =& F \quad x_2 = T \quad x_3 = F \quad \text{è NAE-K-SAT}\\
			\end{align*}
		\end{esempio}
 		 
		\begin{prop}
			Se $ \ \underline{a} \ $ è un assegnamento che soddisfa $ \phi $ (è NAE), allora anche il negato $ \ \overline{\underline{a}} \ $ soddisfa  $ \phi $ (è NAE).
		\end{prop}
 		 
		\paragraph{3-SAT $ \leq_K $ NAE-4-SAT} Vogliamo dimostrare che data una qualsiasi formula $\ \phi \ $ 3-CNF la trasformo in una formula $\ \psi \ $ 4-CNF in tempo polinomiale.
		\[
	 		 \phi \ \text{3-CNF} \ \longmapsto \ \psi \ \text{4-CNF}
		\]
		\begin{align*}
			\phi &= C_1 \wedge C_2 \wedge \dots \wedge C_n \quad C_i = l^{(i)}_1 \vee l^{(i)}_2 \vee l^{(i)}_3 \quad i = 1 \dots n \\
			\psi &= C'_1 \wedge C'_2 \wedge \dots \wedge C'_n \quad C'_i = l^{(i)}_1 \vee l^{(i)}_2 \vee l^{(i)}_3 \vee z \quad i = 1 \dots n \\
		\end{align*}
		Per creare $ \psi $ espando le variabili e ne aggiungo sempre una. 
		La trasformazione da $ \phi $ a $ \psi $ è polinomiale nella taglia della formula $ \phi $, perché la scorro tutta per creare $ \psi $.\\
		Ora dobbiamo dimostrare che se $ \phi $ è soddisfacibile allora anche $ \psi $ è soddisfacibile:
		\begin{itemize}
			\item $ \phi $ è soddisfacibile $ \ \Rightarrow \ \exists \underline{a} \in \{T,F\}^n \quad t.c.\quad \phi(\underline{a}) = T $.
			\item Se prendiamo l'assegnamento $ \ \underline{b} = \underline{a} \quad z = F \quad \psi(\underline{b}) = T\ $ e ogni clausola ha un letterale a FALSE.
			\item Vogliamo dimostrare che se esiste un assegnamento $ \underline{b} $ che soddisfa $ \psi $ allora esiste un assegnamento $ \underline{a} $ che soddisfa $ \phi $.
			\item Se secondo $ \underline{b}\quad z = F\ $ allora, la parte rimanente di $ \underline{b} $ soddisfa $ \psi $
			\item Se secondo $ \underline{b}\quad z = T\ $ allora, lo nego e torno al primo caso. Perciò se $ \psi $ è nae-soddisfatta con $ \ z = F\ $ allora $ \phi $ è soddisfatta. 
		\end{itemize}
		
		\paragraph{NAE-3-SAT $ \leq_K $ 3-COL } Vogliamo dimostrare che data la formula $ \phi $ 3-CNF esiste una trasformazione polinomiale che la rende un grafo $ G $ tale che $ \phi $ è NAE-soddisfacibile se e solo se il grafo $ G $ è 3-colorabile.
			 		
 		Mappo variabili (letterali) che possono valere T o F, su vertici (elementi del grafo) che hanno colore $ 0, 1, 2 $.
 		
 		\begin{tikzpicture}
	 		\node (x) at (0,0) {$ x $}; \node (t) at ($ (x) +(.75,.5)$) {$ T $}; \node (f) at ($ (x) +(.75,-.5)$) {$ F $}; 
	 		\draw (x) -- (t); \draw (x) -- (f); 
	 		\node at ($ (x) +(2,0)$) {$ \longmapsto $};
	 		\node (r) at ($ (x) +(3,0)$) {$ r $}; \node (0) at ($ (r) +(.75,.75)$) {$ 0 $}; \node (1) at ($ (r) +(.75,0)$) {$ 1 $};\node (2) at ($ (r) +(.75,-.75)$) {$ 2 $}; 
	 		\draw (r) -- (0); \draw (r) -- (1); \draw (r) -- (2); 
 		\end{tikzpicture}
 		 
 		 Partendo dalla formula $ \ \phi(x_1, x_2, x_3) = (x_1\vee x_2\vee x_3)\wedge(\overline{x}_1\vee x_2\vee\overline{x}_3) \ $ costruiamo il grafo nel seguente modo:
 		 \begin{itemize}
 		 	\item Creo un nodo per ogni letterale e per il suo negato, poi aggiungo un vertice perché per ogni vertice $ x $ uso la stessa coppia di colori.
 		 	\item Per ogni clausola metto un triangolo che corrisponde ai letterali della clausola
 		 	\item Se ho una 3-colorazione ho un assegnamento corrispondente per la clausola che mi mette un letterale T e uno F.
 		 	\item Ora aggiungo gli archi, collego i letterali che hanno valori di verità opposti.
 		 \end{itemize}

		Se associamo $ 0\mapsto T $, $ 1\mapsto F $, e 2 libero, abbiamo il seguente risultato:
 		 
 		 \begin{figure}[h!]
 		 	\centering
 		 	\begin{tikzpicture}
	 		 	\node[draw, circle] (s) at (5,1.5) {$ 2 $};
			 	\node[draw, circle] (x1) at (0,0) {$ x_1 $}; \node[draw, circle] (nx1) at (2,0) {$ \overline{x}_1 $}; 
			 	\node[draw, circle] (x2) at (4,0) {$ x_2 $}; \node[draw, circle] (nx2) at (6,0) {$ \overline{x}_2 $}; 
			 	\node[draw, circle] (x3) at (8,0) {$ x_3 $}; \node[draw, circle] (nx3) at (10,0) {$ \overline{x}_3 $}; 
			 	\draw (s) -- (x1); \draw (s) -- (x2); \draw (s) -- (x3); \draw (s) -- (nx1); \draw (s) -- (nx2);
			 	\draw (s) -- (nx3); \draw (x1) -- (nx1); \draw (x2) -- (nx2); \draw (x3) -- (nx3); 
			 	\node[draw, circle] (c1) at (3,-1) {$ x_1 $}; \node[draw, circle] (c2) at (2,-2.5) {$ x_2 $}; 
			 	\node[draw, circle] (c3) at (4,-2.5) {$ x_3 $};
			 	\node[draw, circle] (b1) at (7,-1) {$ \overline{x}_1 $}; \node[draw, circle] (b2) at (6,-2.5) {$ x_2 $}; 
			 	\node[draw, circle] (b3) at (8,-2.5) {$ \overline{x}_3 $};
			 	\draw (c1) -- (c2); \draw (c1) -- (c3);  \draw (c2) -- (c3);
			 	\draw (b1) -- (b2); \draw (b1) -- (b3);  \draw (b2) -- (b3);
			 	\draw (c1) -- (nx1); \draw (c2) -- (nx2); \draw (c3) -- (nx3);
			 	\draw (b1) -- (x1); \draw (b2) -- (nx2); \draw (b3) -- (x3);
			 	\node at ($ (x1.north) +(0,.3) $) {0};\node at ($ (nx1.north) +(0,.3) $) {1}; 
			 	\node at ($ (x2.north) +(0,.3) $) {0};\node at ($ (nx2.north) +(0,.3) $) {1};
			 	\node at ($ (x3.north) +(0,.3) $) {1};\node at ($ (nx3.north) +(0,.3) $) {0};
			 	\node at ($ (c1.east) +(.3,0) $) {0};
			 	\node at ($ (c2.north) +(0,.3) $) {1};
			 	\node at ($ (c3.north) +(0,.3) $) {2};
			 	\node at ($ (b1.north) +(0,.3) $) {1};
			 	\node at ($ (b2.west) +(-.3,0) $) {2};
			 	\node at ($ (b3.east) +(.3,0) $) {0};
	 		\end{tikzpicture}
 		 \end{figure}
 		 
	 Perciò la trasformazione garantisce che se $ \exists \underline{a} \ \ t.c.\ \ \phi(\underline{a}) $ è nae-soddisfatta allora esiste una 3-colorazione per il grafo G che associa ai valori di verità i colori in modo tale da rendere G 3-colorabile. È facile vedere anche l'implicazione nel verso opposto.
	 
	 \subsection{Transitività della riduzione alla Karp}
		 La riduzione $ \leq_K $ è transitiva, ciò implica che:
		 \[
			 \prob{A} \leq_K \prob{B}\ \text{ e }\ \prob{B}\leq_K \prob{C} \ \Rightarrow \ \prob{A}\leq_K \prob{C}
		 \]
		 in particolare abbiamo che:
		 \begin{align*}
			 \prob{A} &\leq_K \prob{B} \quad \exists \alg{A} \text{ polytime } \ x\in \instance{A},\ \alg{A}(x)\in \instance{B}\quad \prob{A}(x) = yes \Leftrightarrow \prob{B}(\alg{A}(x)) = yes \\
			 \prob{B} &\leq_K \prob{C} \quad \exists \alg{B} \text{ polytime } \ y\in \instance{B},\ \alg{B}(y)\in \instance{C}\quad \prob{B}(y) = yes \Leftrightarrow \prob{C}(\alg{B}(y)) = yes
		 \end{align*}
		 Perciò
		 \[
			 \forall x \in \instance{A},\ \alg{B}(\alg{A}(x)) \in \instance{C} \quad \prob{A}(x) = yes \Leftrightarrow
			 \prob{C}(\alg{B}(\alg{A}(x))) = yes \quad \Rightarrow \ \ \prob{C}(x) = \alg{B}(\alg{A}(x))
		 \]

 	\subsection{Problema Reachability}
	 	\begin{itemize}
	 		\item Input: Grafo G diretto, due nodi $ s $ e $ t $.
	 		\item Output: $ yes $ $ \Leftrightarrow $ esiste un cammino che va da $ s $ a $ t $.
	 	\end{itemize}
	 	Quanto costa risolvere Reachablity?\\
	 	Una possibile soluzione potrebbe essere applicare BFS partendo da $ s $. Se si trova $ t $, allora ritorno $ yes $, altrimenti $ no $. Questo procedimento richiede $ O(\vert V\vert+\vert E\vert) $. Quindi \textit{Reachability} $ \in \p $ 
	 	
	 \section{Riduzione alla Turing tra problemi di decisione}
		 \begin{definit}[Riduzione alla Turing]
		 	$ \prob{A}\leq_T \prob{B} \ $ se esiste un algoritmo con complessità polinomiale $ \alg{A} $ che data un'istanza $ \ x \in \instance{A} \ $ utilizzando chiamate ad un \textit{oracolo} per $ \prob{B} $ che hanno costo $ O(1) $, $ \ \alg{A}(x) = \prob{A}(x) $.
		 \end{definit}
	 
	\section{Classe di problemi NP-Completi}
		\begin{definit}(Classe NPC)
			Un problema $\ \prob{A}\ $ è NP-completo (NPC) se
			\begin{itemize}
				\item $ \prob{A} \in \np $
				\item $ \prob{A}\ $ è \textit{NP-hard}, cioè se $ \ \forall \prob{B} \in \np \quad \prob{B}\leq_K \prob{A} $
			\end{itemize}
		\end{definit}
		
	\subsection{Circuito Booleano}
		\begin{definit}[Circuito Booleano]
			Un circuito booleano è un grafo aciclico orientato (DAG) $ C_n $ con $ n $ input e ha le seguenti caratteristiche:
			\begin{itemize}
				\item $ \exists n $ vertici che hanno \textit{in-degree} = 0
				\item $ \exists 1 $ vertice che ha \textit{out-degree} = 0
				\item Ogni altro vertice ha \textit{in-degree} = 1 o 2 ed è etichettato con $ and, or, not $.
				\item La taglia di $ C_n $ è il numero di vertici.
			\end{itemize}
		\end{definit}
		
		\begin{esempio}
			Per $ n = 4 $ abbiamo $ C_4(x_1, x_2, x_3, x_4) $:
			\begin{figure}[h!]
				\centering
				\begin{tikzpicture}[>=latex]
					\node[draw, circle] (a) at (0,0) {0};\node[draw, circle] (b) at (2,0) {1};
					\node[draw, circle] (c) at (4,0) {1};\node[draw, circle] (d) at (6,0) {1};
					\node[draw,circle] (out) at (3,-4) {0};
					\node[draw,rectangle] (and) at (1,-1) {and};\node[draw,rectangle] (or) at (5,-1) {or};
					\node[draw,rectangle] (not) at (4,-2) {not};\node[draw,rectangle] (and1) at (3,-3) {and};
					\draw[->] (a) -- (and);\draw[->] (and) -- (and1); \draw[->] (b) -- (and);
					\draw[->] (c) -- (or);\draw[->] (d) -- (or); \draw[->] (or) -- (not); \draw[->] (not) -- (and1); 
					\draw[->] (and1.south) -- (out);
					\node[xshift=.2cm] at (and.east) {0};\node[xshift=.2cm] at (or.east) {1};\node[xshift=.2cm] at (not.east) {0};\node[xshift=.2cm] at (and1.east) {0};
				\end{tikzpicture}
				\caption{Esempio di circuito booleano con 4 input, il nodo finale di output è detto nodo \textit{sink}.}
			\end{figure}
		\end{esempio}
		
	\subsection{Problema Circuit-SAT}
		\begin{itemize}
			\item Input: Circuito booleano $ C_n $
			\item Output: $ yes \ \Leftrightarrow \ \exists \underline{x} \ t.c. \ C(x) = 1 \ $ (il circuito booleano è soddisfacibile).
		\end{itemize}
		Definiamo una famiglia di circuiti $ C_{n\geq 0} $ (per ogni numero di input) di complessità $ T(n) $ tale che la taglia di $ C_n $ è $ O(T(n)) $.
		
		Vogliamo mappare il verificatore di ogni problema in $ \np $ in un circuito:
		\begin{align*}
			\prob{A} \qquad &\longmapsto \qquad V(\cdot, \cdot)\\ \\
			\prob{A}(x) = yes\ &\Leftrightarrow\ \exists w \ t.c.\ V(x, w) = yes
		\end{align*}
		Dove $ V(x, w) $ è un circuito che prende $ x $ in input e che mi dice se esiste un certificato $ w $ tale che rende soddisfatto il circuito.
		
		\begin{thm}
			\label{thm:circfam}
			Se $ \prob{A} \in TIME(f(n)) $ allora esiste una famiglia di circuiti $ C_{n\geq 0} $ di complessità $ T(n) = O(f(n)^2) $ tale che $ \ \forall \underline{x} \in \instance{A}\ $ e $ \ n = \vert x \vert\ $ $ C_n(x) = \prob{A}(x)\ $ e $ C_n $ è costruibile in tempo polinomiale.
		\end{thm}
		
		\begin{coroll}
			Se $ \prob{A} \in \p $ ($ f(n) $ è un polinomio in $ TIME(f(n)) $) allora esiste una famiglia di circuiti di complessità polinomiale ($ T(n) = n^k $) tale che $ \ \forall\underline{x} \in \instance{A} \ $ e $ \ n = \vert x \vert \ \ $ $ C_n(\underline{x}) = \prob{A}(x) \ $ e $ C_n $ è costruibile in tempo polinomiale in $ \vert x \vert = n $. 
		\end{coroll}
		
		\paragraph{Circuit SAT è NP-completo} Dimostriamo prima a parole che Circuit-SAT $ \in \np $. Forniamo il verificatore $ V(x,w) $ verifica se un'istanza soddisfa il problema. Il certificato $ w $ è l'assegnamento che soddisfa il circuito, mentre il verificatore scorre ogni nodo e ne valuta il valore, ritorna $ yes $ se il nodo finale (sink) è a 1, altrimenti $ no $.
		
		Ora dimostriamo che Circuit-SAT è NP-hard, ovvero che $ \ \forall \prob{A} \in \np \quad \prob{A} \leq_K \text{Circuit-SAT} $. Dobbiamo mostrare dunque che esiste tale trasformazione polinomiale:
		\[
			\underline{x} \in \instance{A} \ \longmapsto \ C\in \instance{\text{Circuit-SAT}}
		\]
		e vale anche che:
		\[
			\prob{A} = yes \ \Leftrightarrow \ \exists w \ t.c. \ C(w) = 1 (\text{C è soddisfacibile})
		\]
		Sia $ \prob{A} \in \np $ allora $ \exists V_{\prob{A}}(x, w) $ per le istanze $ x \in \instance{A} $, tale che $ V_{\prob{A}} $ ha complessità $ O(p(\vert x\vert)) = \vert w \vert $ (polinomiale). Allora per il teorema \ref{thm:circfam} sappiamo che esiste una famiglia di circuiti $ C_m $ che fa esattamente ciò che fa il verificatore $ V_{\prob{A}} $ :
		\[
			C_m = V_{\prob{A}} \quad m = \vert x \vert + p(\vert x\vert)
		\]
		perciò, se consideriamo $ C_x'(x) = C_m(x, w) $
		\[
			\prob{A}(x) = yes \ \Leftrightarrow \ \exists w\ t.c. \ V_{\prob{A}}(x, w) = yes \ \Leftrightarrow \ \exists w\ t.c. \ C_m(x, w) = 1 \ \Leftrightarrow \ \exists w\ t.c. \ C_x'(x) = 1 
		\]
		
		\paragraph{SAT è NP-completo} Vogliamo dimostrare che dato un circuito booleano soddisfacibile esiste una riduzione che lo trasforma in tempo polinomiale in una formula booleana soddisfacibile.
		\begin{align*}
			 \text{Circuit-SAT } &\leq_K \text{ SAT} \\
			\forall C \in \instance{\text{Circuit-SAT}} \ &\longmapsto \ \phi(\dots)\\
			C \text{ è soddisfacibile } &\Leftrightarrow \ \phi \text{ è soddisfacibile }
		\end{align*}
		
		\begin{obs}
			Ogni funzione di gate ($ and, or, not, \dots $) può essere espressa con una formula booleana CNF $ \phi $:
			\begin{align*}
				&c = a\ and\ b \quad \quad (\overline{c}\vee a)\wedge(\overline{c}\vee b)\wedge(c\vee \overline{a}\vee\overline{b}) \\
				&c = a\ or\ b \quad \quad (\overline{c}\vee a\vee b)\wedge(c\vee\overline{b})\wedge(c\vee\overline{a})\\
				&c = not\ a \quad \quad (\overline{c}\vee\overline{a})\wedge(c\vee a)
			\end{align*}
			Quindi un circuito booleano è soddisfatto quando ogni formula è soddisfatta e il nodo sink è soddisfatto (= 1).
		\end{obs}
		Perciò se ogni funzione di gate sottoforma di circuito booleano rappresenta ogni clausola della formula CNF $ \phi $, allora possiamo mettere in and tutte le clausole e dire che il circuito $ C $ è soddisfatto se e solo se $ \phi $ è soddisfatta.\\
		Con questo e con la dimostrazione che Circuit-SAT è NP-completo possiamo dire che
		\[
			\forall \prob{B} \in \np \quad \prob{B}\leq_K\text{Circuit-SAT}\leq_K \text{SAT}
		\]
		Perciò, per la proprietà transitiva della riduzione alla Karp tra problemi di decisione, deduciamo che SAT è NP-completo.
		
	\subsection{Relazione tra P, NP, e NP-completo}
		Distinguiamo principalmente due casi che rappresentano le relazioni tra le classi di problemi $ \p, \np $ e NP-completo:
		\begin{figure}[h!]
			\centering
			\begin{tikzpicture}[scale=0.6]
				\draw (0,0) ellipse (3cm and 2cm) node[yshift=.7cm] {$ \npc $};
				\draw (-1.3,0) circle (1cm) node {$ \p $};
				\draw (1.3,0) circle (1cm) node {$ \np $};
				\node at (4.5,0) {oppure};
				\draw (9,0) ellipse (3cm and 2cm) node {$ \npc \equiv \np \equiv \p $};
			\end{tikzpicture}
		\end{figure}
		
		\begin{thm}
			Se $\ \npc \cap \p \neq \emptyset\ $ e $\ \prob{A} \in \np \quad t.c. \ \prob{A} $ \textbf{non è banale}, ovvero 
			\begin{align*}
			&\exists x \in \instance{A} \quad t.c. \ \prob{A}(x) = yes\\ 
			&\exists y \in \instance{A} \quad t.c. \ \prob{A}(y) = no 
			\end{align*}
			Allora $ \prob{A} \in \npc $
		\end{thm}
		\begin{proof}
			Se $\ \npc \cap \p \neq \emptyset\quad \exists \prob{B}\ \text{ Np-hard }\ t.c.\ \prob{B}\in\p \wedge \forall \prob{C}\in \np \ \ \prob{C} \leq_K \prob{B} $. Perciò deduciamo che $ \prob{C}\in\p $, quindi ogni problema che è in $ \np $ è anche in $ \p $ e viceversa. Quindi $ \p \equiv \np $.
			
			Dobbiamo quindi dimostrare che ogni problema in $ \np $ si riduce polinomialmente ad $ \prob{A} $\\
			Prendiamo come esempio il seguente problema \textit{bit}:
			\begin{itemize}
				\item Input: Bit $ b $
				\item Output: $ yes \Leftrightarrow b = 1 $ 
			\end{itemize}
			Sia $ \prob{D} $ un problema $ \prob{D} \in \np $ e quindi $ \prob{D} \in \p $ (c'è un risolutore polinomiale per $ \prob{D} $). Dobbiamo trovare una trasformazione $ f(x) $ tale che riduce il problema $ \prob{D} $ al problema \textit{bit}:
			\[	
				f(x) = 
				\begin{cases}
					1 & \mbox{ se } \prob{D}(x) = yes \\
					0 & \mbox{ altrimenti}
				\end{cases}
			\]
			dove $ x \in \instance{D} $.\\
			Sappiamo quindi risolvere $ f(x) $ in tempo polinomiale perché sappiamo risolvere $ \prob{D} $ in tempo polinomiale poiché $ \prob{D} \in \np \wedge \prob{D} \in \p  $. Quindi siano $ x $ e $ y $
			\begin{align*}
				&x_{yes}\in \instance{A} \quad t.c.\ \prob{A}(x_{yes}) = yes\\
				&x_{no}\in \instance{A} \quad t.c.\ \prob{A}(x_{no}) = no
			\end{align*}
			allora la trasformazione $ f(x) $ sarà:
			\[
				f(x) = 
				\begin{cases}
					x_{yes} & \mbox{ se } \prob{D}(x) = yes \\
					x_{no}  & \mbox{ se } \prob{D}(x) = no
				\end{cases}
			\]
		\end{proof}
		
	\section{Classe di problemi $ \conp $}
		\begin{definit}(Classe $ \conp $)
			L'insieme dei problemi $ \conp $ è definito nel seguente modo:
			\[
				\conp = \{\prob{A}\ \big| \ \overline{\prob{A}} \in \np \}
			\]
			Sono quei problemi per cui è ``facile'' verificare le istanze $ no $.
		\end{definit}
		Di seguito forniamo un paio di esempi di problemi:
		\begin{esempio} Problema:
			\begin{itemize}
				\item Input: Grafo G
				\item Output: $ yes $ se G non è colorabile con 7 colori.
			\end{itemize}
			Questo problema è il complemento del problema 7-COL. Quest'ultimo appartiene alla classe $ \np $ quindi il problema in esempio è in $ \conp $.
		\end{esempio}
		
		\begin{esempio} Problema:
			\begin{itemize}
				\item Input: formula booleana $ \phi $
				\item Output: $ yes $ se $ \forall \underline{a} \ \phi(a) = T $
			\end{itemize}
			Per questo problema è facile vedere che esiste un'istanza $ no $ poiché basta che ci sia almeno una clausola con tutti i letterali a false. Quindi appartiene a $ \conp $.
		\end{esempio}
		
	\subsection{Relazione tra $ \p, \np $ e $ \conp $}
		\begin{thm}
			Se $ \exists \prob{A} \ t.c. \ \prob{A} \in \npc \cap \conp \ $ allora $ \np \equiv \conp $.   
		\end{thm}
		\begin{proof}[$ \conp \subseteq \np $]
			Supponiamo che $ \prob{A}\in \npc $ allora $ \prob{A} \in \np \ $ e $ \ \forall \prob{C}\in \np \quad \prob{C}\leq_K\prob{A} $.\\
			Se prendiamo il problema $ \prob{B}\in \conp \quad \overline{\prob{B}}\in\np $.\\
			Allora esiste una riduzione alla Karp $ \overline{\prob{B}}\leq_K \prob{A} $ che mappa le istanze $ yes $ di $ \prob{B} $ alle istanze $ no $ di $ \prob{A} $ ed esiste anche una riduzione $ \prob{B}\leq_K \overline{\prob{A}} $ che è duale alla precedente.\\
			Poiché $ \prob{A}\in \conp $ allora $ \overline{\prob{A}}\in \np $. Quindi $ \prob{B} $ si riduce polinomialmente ad un problema in $ \np $. Quindi $ \prob{B}\in\np $. Quindi per estensione $ \conp \subseteq\np $.
 		\end{proof}
 		\begin{proof}[$ \np \subseteq \conp $] 
 			Sia $ \prob{C}\in \np\quad \prob{C}\leq_K \prob{A}\quad \overline{\prob{C}}\leq_K\overline{\prob{A}} $. Poiché $ \prob{A}\in \conp $ allora $ \overline{\prob{A}}\in \np $. Quindi $ \overline{\prob{C}}\in\np \ \Rightarrow\ \prob{C}\in\conp \ \Rightarrow \ \np \subseteq \conp $.
 		\end{proof}
 		
 		\begin{figure}[h!]
 			\centering
 			\begin{tikzpicture}[scale=0.6]
	 		\draw (0,0) ellipse (3cm and 2cm) node[xshift=-.5cm] {$ \np $};
	 		\draw (3,0) ellipse (3cm and 2cm) node[xshift= .7cm] {$ \conp $};
	 		\draw (1.5,0) circle (1cm) node {$ \p $};
 		\end{tikzpicture}
 		\end{figure}
\end{document}
