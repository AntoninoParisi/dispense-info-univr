\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\renewcommand{\mkbegdispquote}[2]{\itshape}
\usepackage{palatino}
\usepackage{frontespizio}
\usepackage{mathtools, nccmath}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs,caption}
\usepackage{subcaption}
\usepackage{epigraph}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usepackage{lipsum}
\lstset{language = C,
	basicstyle=\ttfamily ,
	tabsize = 4,
	morekeywords={VerifyHamCycle},
	showstringspaces=false}

\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\chead{}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\newtheorem{thm}{Teorema}[subsection]
\theoremstyle{definition}
\newtheorem{esempio}{Esempio}[subsection]
\newtheorem{definit}{Definizione}[subsection]
\newtheorem{prop}{Proposizione}[subsection]

\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
	hidelinks, 
	colorlinks = true,
	linkcolor = black,
}
\usepackage[OT1]{eulervm}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\p}{\mathbf{P}}
\newcommand{\tim}{\mathbf{Time(n)}}
\newcommand{\np}{\mathbf{NP}}
\newcommand{\prob}[1]{\mathbb{#1}}
\newcommand{\instance}[1]{\mathcal{I}(\prob{#1})}
\newcommand{\alg}[1]{\mathcal{#1}}
\newcommand{\compl}[2]{T_\alg{#1}( \vert #2 \vert)}
\newcommand{\compld}[3]{T_\alg{#1}( \vert #2 \vert + \vert #3 \vert)}

\begin{document}
 \clearpage
 \begin{titlepage}
 	\centering
 	\vspace*{\fill}
 	{\scshape\LARGE Università degli Studi di Verona \par}
 	\vspace{1.5cm}
 	\line(1,0){145} \\
 	{\huge\bfseries Complessità\par}
 	\line(1,0){145} \\
 	\vspace{0.5cm}
 	{\scshape\Large Riassunto dei principali argomenti\par}
 	\vspace{2cm}
 	{\Large\itshape Matteo Danzi, Davide Bianchi\par}
 	\vspace{1cm}
 	
 	\vspace{5cm}
 	\vspace*{\fill}
 	% Bottom of the page
 	{\large \today\par}
 \end{titlepage}
  \thispagestyle{empty}
  \newpage
	
	\tableofcontents
	
	\newpage

	\section{Introduzione}
	
	\subsection{Cos'è la complessità computazionale}
		Nella teoria della complessità ci si pone la seguente domanda:
		
		\begin{displayquote}
		Come scalano le risorse necessarie per risolvere un problema all'aumentare delle dimensioni del problema?
		\end{displayquote} 

		La teoria della \textit{complessità computazionale} è una parte dell’informatica teorica che si
		occupa principalmente di classificare i problemi in base alla quantità di \textit{risorse computazionali} (come il tempo di calcolo e lo spazio di memoria) che essi richiedono per
		essere risolti. Tale quantità è detta anche \textit{costo computazionale} del problema.
		
	\subsection{Problemi \textit{facili} e \textit{difficili}}
		Vediamo quattro esempi di problemi che classificheremo come facili o difficili:
		\begin{enumerate}
			\item (\textbf{Eulerian Cycle}) Esiste un modo per attraversare ogni arco di un grafo una e una sola volta?
			
			\begin{itemize}
				\item Il problema si può vedere anche nella forma più piccola del problema dei \textit{sette ponti di Königsberg}:
			
				A Königsberg ci sono 7 ponti, esiste un percorso che attraversa tutti i ponti una e una sola volta per poi tornare al punto di partenza?
			
				Se avessi $ n $ ponti e su ogni riva partissero 2 ponti avrei $ 2^n $ possibili percorsi.
			
				\item La \textbf{soluzione di Eulero} dice che un grafo connesso non orientato ha un percorso che parte e inizia esattamente nello stesso vertice e attraversa ogni arco esattamente una volta se e solo se ogni vertice ha grado dispari (grado = numero di archi uscenti).
				
				Se ci sono esattamente due vertici $ v $ e $ u $, di grado dispari, allora esiste un percorso che parte da $ u $ e attraversa ogni arco esattamente una volta e finisce in $ v $.
				
				\item Seguendo quindi la soluzione di Eulero, \textit{quanto costa decidere} se un grafo G ha un tour Euleriano?
				\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
odd-vertex-num = 0;
For each vertex v of G
	if (deg(v) is odd)
		increment odd_vertex-num
If(odd-vertex-num is neither 0 nor 2)
	output no Eulerian tour
output Eulerian	
				\end{lstlisting}
				Questo algoritmo ha complessità: $ O(|E| + |V|) $
				
				Il costo e l'algoritmo sono gli stessi se vogliamo \textit{provare} che $ G $ \textit{non} ha un tour Euleriano.
				
			\end{itemize}
			
			\item (\textbf{Hamiltonian Cycle}) Esiste un modo per attraversare ogni nodo di un grafo una e una sola volta? 
			
			Esistono diverse soluzioni:
			\begin{itemize}
				\item Provo tutte le possibilità ogni volta, costo: $ O(2^n) $
				\item Provo tutte le possibili permutazioni, costo: $ O(n!) $
				\item La soluzione migliore ad oggi è: $ O(1.657^n) $
			\end{itemize}
			Alla domanda: \textit{Quanto costa decidere se un grafo ha un tour hamiltoniano?} Non sappiamo rispondere. Non sappiamo dire se il problema ha una soluzione non esponenziale. Per quanto ne sappiamo meglio di $ O(1.657^n) $ non sappiamo fare.
			
			Non sappiamo nemmeno dire se Hamiltonian Cycle è più difficile di Eulerian Cycle.
			\item N è un numero primo?
			
			Il migliore algoritmo conosciuto per decidere se N è un numero primo impiega $ O((\log N)^{6 + \epsilon}) $
			\item Quali sono i fattori primi di un numero?
			
			Ad oggi non conosciamo una procedure per fattorizzare un numero molto grande nei suoi divisori, che non sia provare tutte le possibilità.
		\end{enumerate}
		
		\subsection{Risolvere vs Verificare}
			La seguente tabella riassume in modo generico quanto detto nella sezione precedente riguardo alla difficoltà di risolvere problemi e verificare tali problemi su un istanza.
			
			\begin{table}[h]
				\centering
				\caption{Risolvere vs Verificare}
				\label{tab:intro}
				\begin{tabular}{lcc}
					\toprule
					\textbf{Problema} & \textbf{Risolvere} & \textbf{Verificare} \\
					\midrule
					Eulerian Cycle & \textit{facile} & \textit{facile} \\
					Hamiltonian Cycle & \textit{difficile?} & \textit{facile} \\
					N è primo? & \textit{facile} & \textit{facile} \\
					N ha un numero piccolo di fattori? & \textit{difficile?} & \textit{facile} \\
					\bottomrule
				\end{tabular}
			\end{table}
		
	\section{Problema computazionale}
		Un problema computazionale è una semplice relazione $ p $ che mappa l'insieme \textit{infinito} di possibili input (domande o istanze) con un insieme \textit{finito} (non vuoto) di output, cioè di risposte o soluzioni alle istanze.
		\[
			p\ \colon\ \text{istanze infinite}\ \mapsto\ \text{soluzioni finite alle istanze} 
		\]
		Un problema computazionale non è una singola domanda, ma è una \textbf{famiglia di domande}:
		\begin{itemize}
			\item Una domanda per ogni possibile istanza
			\item Ogni domanda è dello stesso tipo (appartiene alla stessa classe)
		\end{itemize}
		
		\begin{esempio}
			Il seguente esempio è un problema computazionale:
			\begin{itemize}
				\item Input: Qualsiasi grafo G
				\item Domanda: Il grafo G contiene un ciclo Euleriano?
			\end{itemize}
		\end{esempio}
		\begin{esempio}
			Il seguente esempio \textit{non} è un problema computazionale:
			\begin{itemize}
				\item Domanda: È vero che il bianco vince sempre a scacchi, sotto l'ipotesi della giocata perfetta?
			\end{itemize}
			Non è un problema computazionale perché non ho un insieme infinito di possibili partite in input.
		\end{esempio}
		
		\subsection{Risolvere un problema computazionale}
			Risolvere un problema computazionale significa trovare un \textbf{algoritmo}, cioè una procedura che risolve il problema matematico in un numero finito di passi (di computazione elementare), che solitamente include la ripetizione di un operazione. È un procedimento deterministico che mappa l'input sull'output.
			\epigraph{
				Un algoritmo è una procedura \textit{finita}, \textit{definita}, \textit{efficace} e con un input e un output.}{\textit{Donald Knuth -- The Art of Computer Programming }}
			
		\subsection{Complessità di un problema computazionale}
		\paragraph{Misura della complessità.}
			Come misuro la complessità di un problema computazionale? Come faccio a dire quanto è facile rispetto ad altri problemi?
			\begin{itemize}
				\item Do un \textbf{upper bound}: trovo un algoritmo qualsiasi che risolve il problema in modo da calcolare qual è il suo costo.
				\item Do un \textbf{lower bound}: trovo la minima quantità di risorse che ogni algoritmo utilizza per risolvere il problema. Tutti gli algoritmi sono \textit{al minimo} complessi come il limite inferiore che abbiamo stabilito. Nessuno può fare di meglio.
			\end{itemize}
			
			\begin{figure}[h]
				\centering
				\begin{tikzpicture}
					\draw (0,0) -- (0,-3);
					\node[right, xshift=.1cm] at (0,-.5) {$ O(n^2) $};
					\node[right, xshift=.1cm] at (0,-2.5) {$ \Omega (n) $};
					\draw[ultra thick] (0,-.5) -- (0,-2.5);
					\draw (-.15,-.5) -- (.15,-.5); \draw (-.15,-2.5) -- (.15,-2.5);
				\end{tikzpicture}
			\end{figure}
			
			\subsection{Trattabilità di un problema.} La crescita della complessità di un problema è riducibile a 2 categorie fondamentali.
			
			\paragraph{Crescita polinomiale.} Un problema ha crescita polinomiale quando le risorse necessarie alla sua risoluzione sono limitate ad $n^k$, per qualche $k$. Se la taglia del problema aumenta, la sua complessità aumenta di un qualche fattore costante. Infatti, se la taglia dell'input va da $n$ a $2n$ allora la complessità del problema si modifica in $(2n)^k = 2^kn^k$, ovvero aumenta di un fattore $2^k$ (costante). Raggruppiamo nella classe $\p$ i problemi di questo tipo.
			
			\paragraph{Crescita esponenziale.} Un problema ha crescita esponenziale la necessità di risorse necessarie alla sua risoluzione è proporzionale a $c^n$, per qualche costante $c > 1$. Se la taglia dell'input va da $n$ a  $2n$ $c^n$ allora la richiesta di risorse si diventa $c^{2n} = c^n * c^n$, aumentando quindi di un fattore che cresce con l'aumentare di $n$. Raggruppiamo nella classe $\Exp$ i problemi di questo tipo.
			
			\section{Le classi di problemi computazionali}
			\paragraph{Notazione e idee di base.}
			Formalmente definiamo un problema come un elemento $ \prob{A} $ di una relazione 
			\[ 
				\mathcal{R} \subseteq \instance{A} \times Sol 
			\] 
			dove: 
			\begin{itemize}
				\item $\instance{A}$ è l'insieme delle istanze del problema $\prob{A}$
				\item $Sol$ è l'insieme delle soluzioni delle istanze di $\prob{A}$
			\end{itemize}
			Si può quindi dire che 
			\[ 
				\forall x \in \instance{A},\ Sol(x) = \lbrace \text{Soluzioni di } x \rbrace 
			\]
			
			Non è restrittivo restringersi ai \textbf{problemi di tipo decisionale}, ovvero quei problemi che hanno come soluzione una risposta del tipo \textit{si} o \textit{no}, quindi i problemi del tipo \[ \prob{A} : \instance{A} \to \lbrace yes, no \rbrace \]
			
			
			L'algoritmo $\alg{A}$ per un problema $\prob{A}$ è un algoritmo che dato il problema, $\forall x \in \instance{A},\ \alg{A}(x) = \prob{A}(x)$. Inoltre, dato un algoritmo $ \alg{A} $, definiamo $\compl{A}{x}$ la sua \textbf{complessità}, cioè il \textit{tempo che impiega} $\alg{A}$ sull'istanza di taglia $\vert x \vert$. Notare che $\vert x \vert$ è la taglia dell'istanza $x$.
			
			\subsection{Classe P} 
			Intuitivamente la classe $\p$ è definita come la classe di problemi di \textbf{complessità polinomiale}. Introduciamo qui la definizione formale.
			
			\begin{definit}[Classe P]
				Definiamo la classe di problemi $\p$ come l'insieme dei problemi di complessità polinomiale, ovvero 
				\[ 
					\p = \big\lbrace \prob{A}\ \vert\ \exists \alg{A}\ t.c.\ \exists c \text{ costante e }\ \forall x \in \instance{A},\ \ \alg{A}(x) = \prob{A}(x)\ \text{ e }\ \compl{A}{x} \leq \vert x \vert ^ c \big\rbrace 
				\]
			\end{definit}
			
			\begin{esempio}[Eulerian Cycle]
				Un semplice esempio di problema appartenente alla classe $\p$ è il problema del tour euleriano. Per questo problema infatti abbiamo che è un problema computazionale di decisione:
				\begin{itemize}
					\item Input: grafo $ G $
					\item Output: $ yes \Leftrightarrow \exists $ Eulerian Cycle in $ G $.
				\end{itemize}
				Come abbiamo già visto quindi:
				\[
					\exists \alg{A}\ t.c.\ \compl{A}{G} = O(\vert E\vert + \vert V\vert) = O(\vert G\vert) 
				\] 
				Eulerian Cycle $ \in \p\ $ perché $\ \exists \alg{A}\ $ che impiega un tempo che è nell'ordine della taglia di $ G $, in particolare $ \ \exists c \text{ costante } $ dove $ c=1 $.
			\end{esempio}
			
			
			\begin{esempio}[Hamiltonian Cycle]
				Ci chiediamo allora se anche Hamiltonian Cycle $ \in \p\ $ ? La risposta è che non lo sappiamo dire. Quello che sappiamo per questo problema è che:
				\[
					\exists \alg{A}\ t.c.\ \compl{A}{G} = O(a^{\vert G \vert})
				\]
				dove $ a $ è costante.
			\end{esempio}
			
			\subsection{Classe Exp}
			Dal momento che non sappiamo se alcuni problemi stiano oppure no nella classe $\p$ (dal momento che non si conosce un algoritmo che li risolva in tempo polinomiale), si definisce la classe $\Exp$, che racchiude tutte le istanze di questa tipologia di problemi di \textbf{complessità esponenziale}.
			
			\begin{definit}[Classe Exp]
				Definiamo la classe di problemi $\Exp$ come la classe di problemi di complessità esponenziale, ovvero 
				\[ 
					\Exp = \big\lbrace \prob{A}\ \vert\ \exists \alg{A}\ t.c.\ \forall x \in \instance{A},\ \alg{A}(x) = \prob{A}(x)\ \text{ e }\ \compl{A}{x} \leq 2^{\vert x \vert ^ c} \big\rbrace 
				\]
			\end{definit}
			
			\begin{esempio}[Hamiltonian Cycle]
				Ci chiediamo se Hamiltonian Cycle $ \in \Exp$ ? Se prendiamo l'algoritmo che prova tutte le combinazioni di archi cioè $ \binom{\vert E \vert}{n} $ per vedere se formano un ciclo hamiltoniano. La complessità di quest'algoritmo è al massimo $\ 2^{\vert E \vert^2} $. 
				
				Se invece prendiamo l'algoritmo che considera tutte le possibili permutazioni dei vertici del grafo abbiamo che la complessità è $ n! $. Quindi il problema Hamiltonian Cycle $ \notin \Exp $
			\end{esempio}
			
			\paragraph{Relazione tra P ed Exp.} La domanda che sorge spontanea è $ \p \subseteq \Exp $ ?
			
			La risposta alla domanda è banalmente \textbf{si}, in quanto, dato un algoritmo $ \alg{B} $ con complessità $\compl{B}{x}$, possiamo dire che 
			\[ 
				\compl{B}{x} = O(\vert x \vert ^ c) = O(2^{\vert x \vert ^ c}) \Rightarrow \prob{A} \in \Exp 
			\]
			
			\paragraph{Problema K-Graph-Colouring.} Analizziamo ora il problema della K-colorabilità di un grafo $ G $:
			\begin{itemize}
				\item Input: $ G $ non orientato.
				\item Output: $ yes \Leftrightarrow \exists\ $ colorazione \textit{propria} dei vertici di $ G $ ovvero:
				\[
					\exists f\ \colon\ v \mapsto \{0,\dots, k-1 \}\quad t.c.\quad \forall (u,v)\in E(G)\quad f(u) \neq f(v)
				\]
			\end{itemize}
			
			\begin{figure}[h!]
				\centering
				\begin{subfigure}{.5\textwidth}
					\centering
					\begin{tikzpicture}
						\node[draw, circle] (a) at (0,0) {};
						\node[draw, circle, fill=black] (b) at (1.5,1) {};
						\node[draw, circle] (c) at (3,0) {};
						\node[draw, circle, fill=black] (d) at (1.5,-1) {};
						\draw (a) -- (b) -- (c) -- (d) -- (a) -- (c);
					\end{tikzpicture}
					\caption{Grafo con colorazione \textit{non} propria}
				\end{subfigure}%
				\begin{subfigure}{.5\textwidth}
					\centering
					\begin{tikzpicture}
						\node[draw, circle, fill=gray] (a) at (0,0) {};
						\node[draw, circle, fill=black] (b) at (1.5,1) {};
						\node[draw, circle] (c) at (3,0) {};
						\node[draw, circle, fill=black] (d) at (1.5,-1) {};
						\draw (a) -- (b) -- (c) -- (d) -- (a) -- (c);
					\end{tikzpicture}
					\caption{Grafo con colorazione propria}
				\end{subfigure}%
			\end{figure}
			
			\paragraph{Problema 2-Graph-Colouring.}
			Consiste nel trovare se esiste una 2 colorazione del grafo dato in input in modo tale che un arco non si trovi tra due vertici dello stesso colore. Questo problema corrisponde a dire se il grafo è \textbf{bipartito}, cioè se \textit{posso suddividere il grafo in due classi diverse}. \\
			Per vedere se è bipartito si effettua una \textbf{BFS}, cioè una visita in ampiezza, e si controlla se c'è un ciclo dispari. Se c'è allora non è bipartito e quindi nemmeno 2-colorabile.\\
			
			\noindent
			È 2-colorabile $ \Leftrightarrow $ è Bipartito $ \Leftrightarrow $ non contiene un ciclo dispari. La visita BFS ha una complessità pari a $ O(\vert E \vert + \vert V \vert) $, perciò il problema è risolvibile in tempo polinomiale, perciò possiamo concludere che 2-Graph-Colouring $ \in \p $.
			
			\paragraph{Problema 3-Graph Colouring}
			Il problema 3-Graph Colouring $ \in \p $? Non sappiamo rispondere a questa domanda, poiché non sappiamo se esiste un algoritmo che lo svolga in tempo polinomiale.\\
			Il problema 3-Graph Colouring $ \in \Exp $? Se consideriamo l'algoritmo che prova tutte le possibili colorazioni abbiamo che:
			\[
				3^n \text{ sono le colorazioni dei vertici, dove }\ n = \vert V(G) \vert 
			\]
			Bisogna vedere se ci sono archi monocolore e quindi la complessità diventa:
			\[
				O(3^n\cdot\vert E \vert) = O(3^{2n}) = O((2^{\log_2 3})^{2n}) = O(2^{2n\log_2 3})
			\]
			Perciò possiamo concludere che il problema 3-Graph Colouring $ \in \Exp $.
		
			\subsection{Classe Time(n)}
			
			\begin{definit}[Classe Time(n)]
				Definiamo la classe $ \tim $ come l'insieme dei problemi di complessità lineare, ovvero
				\[
					\tim = \big\lbrace \prob{A}\ \vert\ \exists \alg{B} \text{ per } \prob{A}\quad t.c.\quad
					\forall x \in \instance{A}\quad \compl{\alg{B}}{x} = O(n) = O(f(\vert x \vert))\ \big\rbrace  
				\]
			\end{definit}
			
			\begin{thm}
				$ \forall \alg{B}\quad t.c.\quad \alg{B}(x) = \prob{A}(x)\quad \compl{\alg{B}}{x} > \vert x \vert^c\quad \forall c\text{ costante} $
			\end{thm}
			
			\begin{thm}
				\label{thm:sort}
				Qualsiasi \textbf{algoritmo di ordinamento} che usa \textit{confronti} su $ n $ elementi ha tempo di esecuzione pari a
				\[
					\Omega(n\log n)
				\]
			\end{thm}
			
			\noindent
			Possiamo dire quindi che:
			\begin{itemize}
				\item \textbf{Eulerian Cycle} $ \in \tim $ perché esiste un problema che lo risolve in tempo lineare.
				\item \textbf{Sorting} $ \notin \tim $ per il teorema \ref{thm:sort}.
			\end{itemize}
			
			\begin{figure}[h]
				\centering\vspace{-.2cm}
				\begin{tikzpicture}[scale=.5,every node/.style={scale=0.8}]
					\draw (0,0) circle (3cm);
					\draw (-.5,0) circle (2cm);
					\draw (-1,0) circle (1cm);
					\node at (2.25,0) {$ \Exp $};
					\node at (.75,0) {$ \p $};
					\node at (-1,0) {$ \tim $};
				\end{tikzpicture}
			\end{figure}
			
			\newpage
			
			Possiamo riassumere quindi che:
			\begin{itemize}
				\item \textbf{Eulerian Cycle} $ \in \p $, \textbf{Eulerian Cycle} $ \in \tim $.
				\item \textbf{Hamiltonian Cycle} $ \in \Exp $
				\item \textbf{Hamiltonian Cycle} $ \in \p $ ? non lo sappiamo dire.
				\item \textbf{K-Colouring} $ \in \Exp $
				\item \textbf{K-Colouring} $ \in \p $? \\
				per $ k\geq 3 $ non lo sappiamo dire\\
				per $ k = 2 $ sì.
			\end{itemize}
			Inoltre, con la definizione della classe $ \tim $ si può dire che:
			\[
				\p = \bigcup_{k \geq 0} \mathbf{Time(n^k)}
			\]
			\[
				\Exp = \bigcup_{k\geq 0} \mathbf{Time(2^{n^k})}
			\]
			
		\subsection{Classe NP}
			La classe $ \np $ (\textit{non deterministic polinomial time}) è la classe di problemi tali che se la soluzione per un'istanza del problema è \textit{yes}, allora è facile verificarlo.
			
			\begin{definit}(Classe NP)
				\begin{align*}
					\np = \big\lbrace & \prob{A} \quad \big| \quad \exists \alg{B}(\stackrel{x}{\cdot}, \stackrel{w}{\cdot})\quad t.c.\quad 
					\compld{\alg{B}}{x}{w}= O((\vert x\vert + \vert w\vert)^c) \\
					& \forall x \in \instance{\prob{A}}\quad \prob{A}(x) = yes\ \Leftrightarrow\ \exists w\ t.c.\quad \vert w \vert = O(\vert x\vert^d)\ \text{ e }\ \alg{B}(x, w) = yes 
					\big\rbrace
				\end{align*}
					
				dove:
				\begin{itemize}
					\item $ \alg{B}(\stackrel{x}{\cdot}, \stackrel{w}{\cdot}) $ è detto \textbf{verificatore} per $ \prob{A} $. Se la risposta di $ \prob{A} $ esiste, allora $ \alg{B} $ dice \textit{yes}. Il verificatore impiega \textbf{tempo polinomiale} nella taglia dell'istanza per rispondere.
					\item $ x $ è l'istanza
					\item $ w $ è il certificato.
				\end{itemize}
				
			\end{definit}
			
			\paragraph{Hamiltonian Cycle $ \in $ NP ?} Per vedere se il problema Hamiltonian cycle appartiene alla classe $ \np $ dobbiamo costruire un verificatore $ \alg{B} $ che agisca in tempo polinomiale.
			
			\begin{lstlisting}[mathescape=true]
VerifyHamCycle(G = (V,E), C=$ x_1, \dots, x_n $)
	if r != |V|: return $ no $
	for each v$ \in $ V
		if v non appare in C: return $ no $
	for i=1 to n-1
		if $ ( x_i, x_{i+1} )\notin $ E: return $ no $
	if $ ( x_1, x_n )\notin $ E: return $ no $
	return $ yes $
			\end{lstlisting}
			
\end{document}
