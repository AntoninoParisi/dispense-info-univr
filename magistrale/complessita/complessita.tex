\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\renewcommand{\mkbegdispquote}[2]{\itshape}
\usepackage{palatino}
\usepackage{frontespizio}
\usepackage{mathtools, nccmath}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs,caption}
\usepackage{epigraph}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\lstset{language = C,
	basicstyle=\ttfamily ,
	tabsize = 4,
	showstringspaces=false}

\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\chead{}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\newtheorem{thm}{Teorema}[]
\theoremstyle{definition}
\newtheorem{esempio}{Esempio}

\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
	hidelinks, 
	colorlinks = true,
	linkcolor = black,
}
\usepackage[OT1]{eulervm}

\begin{document}
	\begin{frontespizio}
		\Universita{Verona}
		\Dipartimento{Informatica}
		\Scuola{Laurea Magistrale in Ingegneria e Scienze Informatiche}
		\Titoletto{Algoritmi}
		\Titolo{Complessità}
		\Sottotitolo{Riassunto dei principali argomenti}
		\Candidato{Davide Bianchi}
		\Candidato{Matteo Danzi}
		\Annoaccademico{2017/2018}
		\NCandidato{Autori}
	\end{frontespizio}
	
	\tableofcontents
	
	\newpage

	\section{Introduzione}
	
	\subsection{Cos'è la complessità computazionale}
		Nella teoria della complessità ci si pone la seguente domanda:
		
		\begin{displayquote}
		Come scalano le risorse necessarie per risolvere un problema all'aumentare delle dimensioni del problema?
		\end{displayquote} 

		La teoria della \textit{complessità computazionale} è una parte dell’informatica teorica che si
		occupa principalmente di classificare i problemi in base alla quantità di \textit{risorse computazionali} (come il tempo di calcolo e lo spazio di memoria) che essi richiedono per
		essere risolti. Tale quantità è detta anche \textit{costo computazionale} del problema.
		
	\subsection{Problemi \textit{facili} e \textit{difficili}}
		Vediamo quattro esempi di problemi che classificheremo come facili o difficili:
		\begin{enumerate}
			\item (\textbf{Eulerian Cycle}) Esiste un modo per attraversare ogni arco di un grafo una e una sola volta?
			
			\begin{itemize}
				\item Il problema si può vedere anche nella forma più piccola del problema dei \textit{sette ponti di Königsberg}:
			
				A Königsberg ci sono 7 ponti, esiste un percorso che attraversa tutti i ponti una e una sola volta per poi tornare al punto di partenza?
			
				Se avessi $ n $ ponti e su ogni riva partissero 2 ponti avrei $ 2^n $ possibili percorsi.
			
				\item La \textbf{soluzione di Eulero} dice che un grafo connesso non orientato ha un percorso che parte e inizia esattamente nello stesso vertice e attraversa ogni arco esattamente una volta se e solo se ogni vertice ha grado dispari (grado = numero di archi uscenti).
				
				Se ci sono esattamente due vertici $ v $ e $ u $, di grado dispari, allora esiste un percorso che parte da $ u $ e attraversa ogni arco esattamente una volta e finisce in $ v $.
				
				\item Seguendo quindi la soluzione di Eulero, \textit{quanto costa decidere} se un grafo G ha un tour Euleriano?
				\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
odd-vertex-num = 0;
For each vertex v of G
	if (deg(v) is odd)
		increment odd_vertex-num
If(odd-vertex-num is neither 0 nor 2)
	output no Eulerian tour
output Eulerian	
				\end{lstlisting}
				Questo algoritmo ha complessità: $ O(|E| + |V|) $
				
				Il costo e l'algoritmo sono gli stessi se vogliamo \textit{provare} che $ G $ \textit{non} ha un tour Euleriano.
				
			\end{itemize}
			
			\item (\textbf{Hamiltonian Cycle}) Esiste un modo per attraversare ogni nodo di un grafo una e una sola volta? 
			
			Esistono diverse soluzioni:
			\begin{itemize}
				\item Provo tutte le possibilità ogni volta, costo: $ O(2^n) $
				\item Provo tutte le possibili permutazioni, costo: $ O(n!) $
				\item La soluzione migliore ad oggi è: $ O(1.657^n) $
			\end{itemize}
			Alla domanda: \textit{Quanto costa decidere se un grafo ha un tour hamiltoniano?} Non sappiamo rispondere. Non sappiamo dire se il problema ha una soluzione non esponenziale. Per quanto ne sappiamo meglio di $ O(1.657^n) $ non sappiamo fare.
			
			Non sappiamo nemmeno dire se Hamiltonian Cycle è più difficile di Eulerian Cycle.
			\item N è un numero primo?
			
			Il migliore algoritmo conosciuto per decidere se N è un numero primo impiega $ O((\log N)^{6 + \epsilon}) $
			\item Quali sono i fattori primi di un numero?
			
			Ad oggi non conosciamo una procedure per fattorizzare un numero molto grande nei suoi divisori, che non sia provare tutte le possibilità.
		\end{enumerate}
		
		\subsection{Risolvere vs Verificare}
			La seguente tabella riassume in modo generico quanto detto nella sezione precedente riguardo alla difficoltà di risolvere problemi e verificare tali problemi su un istanza.
			
			\begin{table}[h]
				\centering
				\caption{Risolvere vs Verificare}
				\label{tab:intro}
				\begin{tabular}{lcc}
					\toprule
					\textbf{Problema} & \textbf{Risolvere} & \textbf{Verificare} \\
					\midrule
					Eulerian Cycle & \textit{facile} & \textit{facile} \\
					Hamiltonian Cycle & \textit{difficile?} & \textit{facile} \\
					N è primo? & \textit{facile} & \textit{facile} \\
					N ha un numero piccolo di fattori? & \textit{difficile?} & \textit{facile} \\
					\bottomrule
				\end{tabular}
			\end{table}
		
	\section{Problema computazionale}
		Un problema computazionale è una semplice relazione $ p $ che mappa l'insieme \textit{infinito} di possibili input (domande o istanze) con un insieme \textit{finito} (non vuoto) di output, cioè di risposte o soluzioni alle istanze.
		\[
			p\ \colon\ \text{istanze infinite}\ \mapsto\ \text{soluzioni finite alle istanze} 
		\]
		Un problema computazionale non è una singola domanda, ma è una \textbf{famiglia di domande}:
		\begin{itemize}
			\item Una domanda per ogni possibile istanza
			\item Ogni domanda è dello stesso tipo (appartiene alla stessa classe)
		\end{itemize}
		
		\begin{esempio}
			Il seguente esempio è un problema computazionale:
			\begin{itemize}
				\item Input: Qualsiasi grafo G
				\item Domanda: Il grafo G contiene un ciclo Euleriano?
			\end{itemize}
		\end{esempio}
		\begin{esempio}
			Il seguente esempio \textit{non} è un problema computazionale:
			\begin{itemize}
				\item Domanda: È vero che il bianco vince sempre a scacchi, sotto l'ipotesi della giocata perfetta?
			\end{itemize}
			Non è un problema computazionale perché non ho un insieme infinito di possibili partite in input.
		\end{esempio}
		
		\subsection{Risolvere un problema computazionale}
			Risolvere un problema computazionale significa trovare un \textbf{algoritmo}, cioè una procedura che risolve il problema matematico in un numero finito di passi (di computazione elementare), che solitamente include la ripetizione di un operazione. È un procedimento deterministico che mappa l'input sull'output.
			\epigraph{
				Un algoritmo è una procedura \textit{finita}, \textit{definita}, \textit{efficace} e con un input e un output.}{\textit{Donald Knuth -- The Art of Computer Programming }}
			
		\subsection{Complessità di un problema computazionale}
			Come misuro la complessità di un problema computazionale? Come faccio a dire quanto è facile rispetto ad altri problemi?
			\begin{itemize}
				\item Do un \textbf{upper bound}: trovo un algoritmo qualsiasi che risolve il problema in modo da calcolare qual è il suo costo.
				\item Do un \textbf{lower bound}: trovo la minima quantità di risorse che ogni algoritmo utilizza per risolvere il problema. Tutti gli algoritmi sono \textit{al minimo} complessi come il limite inferiore che abbiamo stabilito. Nessuno può fare di meglio.
			\end{itemize}
			
			\begin{figure}[h]
				\centering
				\begin{tikzpicture}
					\draw (0,0) -- (0,-3);
					\node[right, xshift=.1cm] at (0,-.5) {$ O(n^2) $};
					\node[right, xshift=.1cm] at (0,-2.5) {$ \Omega (n) $};
					\draw[ultra thick] (0,-.5) -- (0,-2.5);
					\draw (-.15,-.5) -- (.15,-.5); \draw (-.15,-2.5) -- (.15,-2.5);
				\end{tikzpicture}
			\end{figure}

\end{document}
