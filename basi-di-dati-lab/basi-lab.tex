\documentclass[a4paper, 10pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[makeroom]{cancel}
\usepackage{ulem}
\usepackage{parcolumns}
\usepackage{multicol}
\setlength{\columnseprule}{0.4pt}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{frontespizio}
\usepackage{hyperref}
\usepackage{enumitem}
\hypersetup{hidelinks,
	colorlinks = true,
	urlcolor = black, 
	linkcolor = black}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{listings}
\lstset{inputencoding=utf8,
	language = SQL,
	basicstyle=\ttfamily,
	tabsize=4,
	showstringspaces=false,
	keywordstyle=\color{blue}\bfseries,
	morekeywords={REFERENCES, BOOLEAN, REAL, DOUBLE, PRECISION, TEXT, VARBIT, SIMILAR, TO},
	stringstyle=\color{Purple},
	literate={à}{{\`a}}1
}
\usepackage{fancyvrb}
\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\newcommand{\mail}[1]{\href{mailto:#1}{\texttt{#1}}}

\begin{document}
	\begin{frontespizio}
		\Preambolo{\usepackage{datetime}}
		\Istituzione{Università degli Studi di Verona}
		\Divisione{Dipartimento di informatica}
		\Facolta{Scienze e Ingegneria}
		\Scuola{Laurea in Informatica}
		\Titolo{Basi di Dati}
		\Sottotitolo{Programma di laboratorio}
		\Candidato{Davide Bianchi}
		\Candidato{Matteo Danzi}
		\NCandidati{Autori}
		\Annoaccademico{2016/2017}
	\end{frontespizio}

	\tableofcontents
		
	\newpage
	
	\section{Gestione base di dati con Postgresql}
	Di seguito si trova una panoramica dei comandi Postgres più comuni per la gestione di una base di dati.
	
	\subsection{Comando CREATE TABLE}
	Il comando \lstinline{CREATE TABLE} è usato per creare tabelle nella base di dati.
	La sintassi generale è:
	\begin{lstlisting}
CREATE TABLE nomeTabella (
	nomeAttributo dominioAttributo vincoli,
	...
);
	\end{lstlisting}
	dove \lstinline|nomeAttributo| è il nome dell'attributo nella tabella, \lstinline|dominioAttributo| è il dominio dell'attributo da aggiungere alla tabella.
	
	\subsubsection{Domini elementari}
	I domini di default disponibili in Postgres sono:
	\begin{itemize}
		\item \lstinline|BOOLEAN|: valori booleani (true/false);
		\item \lstinline|INTEGER|: valori interi a 4 byte;
		\item \lstinline|SMALLINT|: valori interi a 2 bit;
		\item \lstinline|NUMERIC(p, s)|: valori decimali approssimati, dove \lstinline|p| è la precisione del numero (cifre a sinistra e a destra della virgola) e \lstinline|s| la scala (numero di cifre decimali dopo la virgola);
		\item \lstinline|DECIMAL(p, s)|: valori deciamli approssimati, con i parametri uguali a \lstinline|NUMERIC|.
		\item \lstinline|REAL|: valori in virgola mobile a 6 cifre decimali;
		\item \lstinline|DOUBLE PRECISION|: valori in virgola mobile approssimati a 15 cifre decimali;
	\end{itemize}
	\textbf{Nota:} Se si devono rappresentare importi di denaro che contengono anche
	decimali, \textbf{MAI} usare \lstinline|REAL| o \lstinline|DOUBLE PRECISION| ma usare \lstinline|NUMERIC|!

	\subsubsection{Domini di caratteri}
	\begin{itemize}
		\item \lstinline|CHARACTER|: singoli caratteri;
		\item \lstinline|CHARACTER(n)|:stringa di caratteri di lunghezza n;
		\item \lstinline|VARCHAR|: stringhe di caratteri di lunghezza variabile;
		\item \lstinline|TEXT|: testo libero (solo Postgres).
	\end{itemize}

	\subsubsection{Domini di bit/booleani}
	\begin{itemize}
		\item \lstinline|BIT|: singoli bit;
		\item \lstinline|VARBIT(n)|: stringa di bit di lunghezza fissa;
		\item \lstinline|VARBIT|: stringa di bit di lunghezza arbitraria.
		\item \lstinline|BOOLEAN|: valori booleani, possono essere solo singoli.
	\end{itemize}
	\textbf{Nota:} non sono ammesse stringhe di booleani.
	
	\subsubsection{Domini di tempo}
	\begin{itemize}
		\item \lstinline|DATE|: date rappresentate tra apici e nel formato \verb|YYYY-MM-DD|;
		\item \lstinline|TIME(precisione)|: misure di tempo nel formato \verb|hh:mm:ss:[precisione]|;
		\item \lstinline|INTERVAL|: intervalli di tempo.
		\item \lstinline|TIME/TIMESTAMP WITH TIME ZONE|: con tutti i dati per il tempo, con indicazioni sul fuso.
	\end{itemize}
	
	\subsection{Comando CREATE DOMAIN}
	Questo comando è usato per creare un dominio utente \textbf{invariabile nel tempo}.
	\begin{lstlisting}
CREATE DOMAIN nome AS tipoBase [default]
	[vincolo]
	\end{lstlisting}
	I valori di default e i vincoli sono opzionali.
	
	\textbf{Esempio:}
	\begin{lstlisting}
CREATE DOMAIN giorniSettimana AS CHAR(3)
	CHECK ( VALUE IN ('LUN', 'MAR', 'MER', 'GIO', 'VEN', 
	'SAB', 'DOM'));
	\end{lstlisting}

	\subsection{Vincoli di attributo e di tabella}
	Vincoli di attributo/intrarelazionali specificano proprietà che devono
	essere soddisfatte da ogni tupla di una singola relazione della base di
	dati.
	
	\begin{lstlisting}
[ CONSTRAINT vincolo ]
{ NOT NULL |
  CHECK ( espressione ) [ NO INHERIT ] |
  DEFAULT valore |
  UNIQUE |
  PRIMARY KEY |
  REFERENCES tabella [ ( attributo ) ]
    [ ON DELETE azione ] [ ON UPDATE azione ] }
	\end{lstlisting}
	
	Vincoli di tabella:
	\begin{lstlisting}
[ CONSTRAINT vincolo ]
{ CHECK ( espressione ) [ NO INHERIT ] |
  UNIQUE ( attributo [, ... ]) |
  PRIMARY KEY ( attributo [, ... ]) |
  FOREIGN KEY ( attributo [, ... ])
  REFERENCES reftable [ ( refcolumn [ , ... ]) ]
	[ ON DELETE azione ] [ ON UPDATE azione ] }
	\end{lstlisting}

	\begin{itemize}
		\item \lstinline|NOT NULL|: determina che il valore nullo non è ammesso come
		valore dell’attributo.
		\item \lstinline|DEFAULT valore|: specifica un valore di
		default per un attributo quando un comando di inserimento dati non
		specifica nessun valore per l’attributo.
		
	\textbf{Esempio:}
	\begin{lstlisting}
nome VARCHAR (20) NOT NULL,
cognome VARCHAR (20) NOT NULL DEFAULT ''
	\end{lstlisting}
		\item \lstinline|UNIQUE|: impone che i valori di un attributo (o di un insieme di
		attributi) siano una \textbf{superchiave}.
		\item \lstinline|PRIMARY KEY|: identifica l’attributo che rappresenta la chiave
		primaria della relazione:
		\begin{itemize}
			\item Si usa una sola volta per tabella.
			\item Implica il vincolo \lstinline|NOT NULL|.
		\end{itemize}
	
	\textbf{Esempio: }
	\begin{lstlisting}
matricola CHAR(6) PRIMARY KEY;
	\end{lstlisting}
	oppure su più attributi
	\begin{lstlisting}
nome VARCHAR(20),
cognome VARCHAR(20),
PRIMARY KEY(nome, cognome)
	\end{lstlisting}
	
	\item \lstinline|CHECK (vincolo)|: specifica un vincolo generico che devono soddisfare le
	tuple della tabella.
	\end{itemize}
	
	\subsubsection{Vincoli di integrità referenziale}
		Un vincolo di integrità referenziale si dichiara nella tabella interna e ha
		due possibili sintassi.
		\begin{itemize}
			\item \lstinline|REFERENCES|: \textbf{vincolo di attributo}, da usare quando il vincolo è su un
			singolo attributo della tabella interna, $ |A| = 1 $.
			\item \lstinline|FOREIGN KEY|: \textbf{vincolo di tabella} , da usare quando il vincolo coinvolge più attributi della tabella interna, $ |A| > 1 $.
		\end{itemize}
		\textbf{Esempio:}
		\begin{lstlisting}
CREATE TABLE Interna
...
attributo VARCHAR(15) REFERENCES TabellaEsterna (chiave)
...

...
piano VARCHAR (10),
stanza INTEGER,
FOREIGN KEY (piano, stanza) REFERENCES Ufficio (piano, nStanza)
		\end{lstlisting}
		
	\subsection{Comando ALTER TABLE}
		La struttura di una tabella si può modificare dopo la sua creazione con il
		comando \lstinline|ALTER TABLE|.
		\begin{itemize}
			\item Aggiunta di un nuovo attributo con \lstinline|ADD COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato ADD COLUMN stipendio NUMERIC(8,2);
			\end{lstlisting}
			\item Rimozione di un attributo con \lstinline|DROP COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato DROP COLUMN stipendio;
			\end{lstlisting}
			\item Modifica di un valore di default di un attributo con \lstinline|ALTER COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato ALTER COLUMN stipendio
	SET DEFAULT 1000.00;
			\end{lstlisting}			
		\end{itemize}
		
	\subsection{Comando INSERT INTO}
		Una tabella viene popolata con il comando \lstinline|INSERT INTO|:
		\begin{lstlisting}
INSERT INTO impiegato (matricola, nome, cognome)
	VALUES ('A00001', 'Mario', 'Rossi'),
	       ('A00002', 'Luca', 'Bianchi');
		\end{lstlisting}
	
	\subsection{Comando UPDATE}
		Una tupla di una tabella può essere modificata con il comando \lstinline|UPDATE|:
		\begin{lstlisting}
UPDATE tabella
	SET attributo = espressione [, ... ]
	[ WHERE condizione ];
		\end{lstlisting}
	\lstinline|condizione| è una espressione booleana che seleziona quali righe
	aggiornare. Se \lstinline|WHERE| non è presente, tutte le tuple saranno aggiornate.
	
	\textbf{Esempio: }
	\begin{lstlisting}
UPDATE impiegato
	SET stipendio = stipendio * 1.10
	WHERE nomeDipartimento = 'Vendite';
UPDATE impiegato
	SET telefono = '+39' || telefono;
	\end{lstlisting}
	\textbf{Nota:} L’operatore '||' concatena due espressioni e ritorna la stringa corrisp.
	
	\subsection{Comando DELETE}
		Le tuple di una tabella vengono cancellate con il comando \lstinline|DELETE|:
		\begin{lstlisting}
DELETE FROM impiegato WHERE matricola = 'A001';
		\end{lstlisting}
		Una tabella viene cancellata con il comando \lstinline|DROP TABLE|.
		
	\subsection{Politiche di reazione}
		In SQL si possono attivare diverse politiche di adeguamento della tabella
		interna
		\begin{lstlisting}
FOREIGN KEY ( column_name [ , ... ]) REFERENCES
	reftable [ ( refcolumn [ , ... ]) ]
   ON DELETE reazione ON UPDATE reazione
		\end{lstlisting}
		\begin{itemize}
			\item \lstinline|CASCADE|: la modifica del valore di un attributo riferito nella tabella master
			si propaga anche in tutte le righe corrispondenti nelle tabelle slave.

			\item \lstinline|SET NULL|: la modifica del valore di un attributo riferito nella tabella
			master determina che in tutte le righe corrispondenti nelle tabelle slave
			il valore dell’attributo referente è posto a \lstinline|NULL| (se ammesso).

			\item \lstinline|SET DEFAULT|: la modifica del valore di un attributo riferito nella tabella
			master determina che in tutte le righe corrispondenti nelle tabelle slave
			il valore dell’attributo referente è posto al valore di default (se esiste).

			\item \lstinline|NO ACTION|: indica che non si fa nessuna azione. Il vincolo però deve
			essere sempre valido. Quindi, la modifica del valore di un attributo
			riferito nella tabella master non viene effettuata.
		\end{itemize}
	\subsection{Query sul database}
		In SQL, esiste solo un comando per interrogare un base di dati: \lstinline|SELECT|.
		\begin{lstlisting}
SELECT [ DISTINCT ]
[ * | expression [[ AS ] output_name ] [ , ...] ]
[ FROM from_item [ , ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [ , ...] ]
[ HAVING condition [ , ...] ]
[ { UNION | INTERSECT | EXCEPT } [ DISTINCT ]
	other_select ]
[ ORDER BY expression [ ASC | DESC | USING operator ]]
...
		\end{lstlisting}
		dove
		\begin{itemize}
			\item \lstinline|*| è un’abbreviazione per indicare tutti gli attributi delle tabelle.
			\item \lstinline|expression| è un’espressione che determina un attributo.
			\item \lstinline|output_name| è il nome assegnato all’attributo che conterrà il risultato
			della valutazione dell’espressione \lstinline|expression| nella relazione risultato.
			\item \lstinline|from_item| è un’espressione che determina una sorgente per gli attributi.
			\item \lstinline|condition| è un’espressione booleana per selezionare i valori degli
			attributi.
			\item \lstinline|grouping_element| è un’espressione per poter eseguire operazioni su
			più valori di un attributo e considerare il risultato.
			\item \lstinline|DISTINCT| : se presente richiede l’eliminazione delle tuple duplicate.
		\end{itemize}
		
	\subsubsection{Operatore LIKE e SIMILAR TO}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|LIKE| per il confronto di
		stringhe. \lstinline|LIKE| è un operatore di pattern matching. I pattern si costruiscono
		con i caratteri speciali \lstinline|_| (1 carattere qualsiasi) e \lstinline|%| (0 o più caratteri qualsiasi):
		\begin{lstlisting}
WHERE attributo [ NOT ] LIKE 'pattern';
		\end{lstlisting}
		L’operatore \lstinline|SIMILAR TO| è un \lstinline|LIKE| più espressivo che accetta
		espressioni regolari (versione SQL) come pattern. Esempi di componenti di
		espressioni regolari:
		\begin{itemize}
			\item \lstinline|_| = 1 carattere qualsiasi. \lstinline|%| = 0 o più caratteri qualsiasi.
			\item \lstinline|*| = ripetizione del precedente match 0 o più volte. 
				\lstinline|+| = ripetizione del precedente match UNA o più volte.
			\item \lstinline|{n,m}| = ripetizione del precedente match almeno n e non più di m volte.
			\item \lstinline|[...]| = ... è un elenco di caratteri ammissibili
		\end{itemize}
		\textbf{Esempio:} Studenti con cognome che inizia con 'A' o 'B', o 'D', o 'N' e finisce con 'a':
		\begin{lstlisting}
SELECT cognome, nome, città FROM Studente
WHERE cognome SIMILAR TO '[ABDN]{1}%a';
		\end{lstlisting}
		
	\subsubsection{Operatore BETWEEN}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] BETWEEN| per testare
		l’appartenenza di un valore ad un intervallo. Gli estremi dell'intervallo sono \textbf{inclusi}.
		
		\noindent
		\textbf{Esempio:} Tutti gli studenti che hanno matricola tra 'IN0002' e 'IN0004'.
	\begin{lstlisting}
SELECT cognome, nome, matricola FROM Studente
WHERE matricola BETWEEN 'IN0002' AND 'IN0004';
	\end{lstlisting}
	
	\subsubsection{Operatore IN}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] IN| per testare
		l’appartenenza di un valore ad un insieme.
	
		\noindent
		\textbf{Esempio: }Tutti gli studenti che hanno matricola nell’elenco 'IN0001', 'IN0003' e
		'IN0005'.
		\begin{lstlisting}
SELECT cognome, nome, matricola FROM Studente
WHERE matricola IN ('IN0001', 'IN0003', 'IN0005');
		\end{lstlisting}
	
	\subsubsection{Operatore IS NULL}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] IS NULL| per testare
		se un valore è NOT KNOWN (==NULL) o no.
	
		\noindent
		\textbf{Esempio: }Tutti gli studenti che NON hanno una città.
\begin{lstlisting}
SELECT cognome, nome, città FROM Studente
WHERE città IS NULL;
\end{lstlisting}
	\textbf{Nota: }In SQL, \lstinline|NULL| non è uguale a \lstinline|NULL|.
	NON SI PUÒ usare \lstinline|'='| o \lstinline|'<>'| con il valore NULL!
	
	\subsubsection{Operatore ORDER BY}
		La clausola \lstinline|ORDER BY| ordina le tuple del risultato in ordine rispetto agli
		attributi specificati.
		
		\noindent
		\textbf{Esempio: }Tutti gli studenti in ordine decrescente rispetto al cognome e crescente
		(lessicografico) rispetto al nome.
		\begin{lstlisting}
SELECT cognome, nome
FROM Studente
ORDER BY cognome DESC, nome;
		\end{lstlisting}
		
	\subsubsection{Operatori di aggregazione}
		Sono operatori che permettono di determinare \textbf{un} valore considerando i
		valori ottenuti da una \lstinline|SELECT|.
		Due tipi principali:
		\begin{itemize}
			\item \lstinline|COUNT|
			\item \lstinline|MAX|, \lstinline|MIN|, \lstinline|AVG|, \lstinline|SUM|
		\end{itemize}
		Quando si usano gli operatori aggregati, dopo la \lstinline|SELECT| \textit{non} possono
		comparire espressioni che usano i valori presenti nelle singole tuple
		perché il risultato è sempre e solo una tupla.
		\\
		\lstinline|COUNT| restituisce il numero di tuple significative nel risultato dell’interrogazione:
		\begin{lstlisting}
COUNT ({ * | expr | ALL expr | DISTINCT expr }])
		\end{lstlisting}
		dove \lstinline|expr| è un’espressione che usa attributi e funzioni di attributi ma non
		operatori di aggregazione.\\
		Tre casi comuni:
		\begin{itemize}
			\item \lstinline|COUNT(*)| ritorna il numero di tuple nel risultato dell’interrogazione.
			\item \lstinline|COUNT(expr)| ritorna il numero di tuple in ciascuna delle quali il valore
			expr è non nullo.
			\item \lstinline|COUNT(ALL expr)| è un alias a \lstinline|COUNT(expr)| .
			\item \lstinline|COUNT(DISTINCT expr)| come con \lstinline|COUNT(expr)| ma con l’ulteriore
			condizione che i valori di \lstinline|expr| sono distinti.
		\end{itemize}
		\lstinline|MAX|, \lstinline|MIN|, \lstinline|AVG|, \lstinline|SUM| determinano un valore numerico (\lstinline|SUM|/\lstinline|AVG|) o alfanumerico (\lstinline|MAX|/\lstinline|MIN|)
		considerando le tuple significative nel risultato dell’interrogazione.
		
		\noindent
		\textbf{Esempi: }\\
		Calcola la media delle medie degli studenti.
		\begin{lstlisting}
SELECT AVG(media)::DECIMAL (5,2)
FROM Studente;
		\end{lstlisting}
		Calcola la media delle medie distinte degli studenti.
		\begin{lstlisting}
SELECT AVG(DISTINCT media)::DECIMAL(5,2)
FROM Studente;
		\end{lstlisting}
		
	\subsubsection{Interrogazioni con raggruppamento}
		Un raggruppamento è un insieme di tuple che hanno medesimi valori su
		uno o più attributi caratteristici del raggruppamento.
		
		\noindent
		La clausola \lstinline|GROUP BY attr [, ...]| permette di determinare tutti i
		raggruppamenti delle tuple della relazione risultato (tuple selezionate
		con la clausola \lstinline|WHERE| ) in funzione degli attributi dati.
		In una interrogazione che fa uso di \lstinline|GROUP BY| , possono comparire come
		argomento della \lstinline|SELECT| solamente gli attributi utilizzati per il
		raggruppamento e funzioni aggregate valutate sugli altri attributi.
		
		\noindent
		\textbf{Esempi: }\\		
		Visualizzare tutte le città raggruppate della tabella Studente.
		\begin{lstlisting}
SELECT città
FROM Studente
GROUP BY città;
		\end{lstlisting}
		Visualizzare tutte le città e i cognomi raggruppati.
		\begin{lstlisting}[mathescape]
SELECT cognome, LOWER(città)
FROM Studente
GROUP BY cognome, LOWER(città);
		\end{lstlisting}
		\textbf{Nota1: }NON SI POSSONO SPECIFICARE attributi che non sono raggruppati dopo il
		\lstinline|SELECT|.
		
		\lstset{moredelim=[is][\sout]{|}{|}}
		\begin{lstlisting}
SELECT |cognome|, città
FROM Studente
GROUP BY città;
		\end{lstlisting}
		
		\noindent
		\textbf{Nota2: }Si possono specificare espressioni con operatori di aggregazione su attributi
		non raggruppati.
		\begin{lstlisting}
SELECT LOWER(città) AS città,
  CAST(AVG(media) AS DECIMAL(5,2)) AS media
FROM Studente
GROUP BY LOWER(città);
		\end{lstlisting}
		
		\begin{itemize}
			\item La clausola \lstinline|WHERE| permette di selezionare le righe che devono far parte
			del risultato.
			\item La clausola \lstinline|HAVING| permette di selezionare i raggruppamenti che
			devono far parte del risultato.
			\item La sintassi è \lstinline|HAVING bool_expr| , dove \lstinline|bool_expr| è un'espressione
			booleana che può usare gli attributi usati nel \lstinline|GROUP BY| e/o gli altri
			attributi mediante operatori di aggregazione.
		\end{itemize}
		\textbf{Esempi: }\\
		Visualizzare tutte le città raggruppate che iniziano con ’V’ della tabella
		Studente.
		\begin{lstlisting}
SELECT città
FROM Studente
GROUP BY città
HAVING città LIKE 'V%';
		\end{lstlisting}
		Visualizzare tutte le città e i cognomi raggruppati con almeno due studenti
		con lo stesso cognome.
		\begin{lstlisting}
SELECT cognome, LOWER(città)
FROM Studente
GROUP BY cognome, LOWER(città)
HAVING COUNT(cognome)>1;
		\end{lstlisting}
		
		\subsubsection{Comando JOIN}
			Si è visto che se sono presenti due o più nomi di tabelle, si esegue il
			prodotto cartesiano tra tutte le tabelle e lo schema del risultato può
			contenere tutti gli attributi del prodotto cartesiano.
			Il prodotto cartesiano di due o più tabelle è un \lstinline|CROSS JOIN| .
			A partire da SQL-2, esistono altri tipi di \lstinline|JOIN| (\lstinline|join_type|):
			\lstinline|INNER JOIN|, \lstinline|LEFT OUTER JOIN| , \lstinline|RIGHT OUTER JOIN| e \lstinline|FULL OUTER JOIN|.
			
			\begin{lstlisting}
table_name [ NATURAL ] join_type table_name 
  [ ON join_condition [ , ...]]
			\end{lstlisting}
			dove \lstinline|join_condition| è un’espressione booleana che seleziona le tuple del join
			da aggiungere al risultato. Le tuple selezionate possono essere poi filtrate
			con la condizione della clausola \lstinline|WHERE|.
\subsubsection*{INNER JOIN}
			Rappresenta il tradizionale $ \Theta $ join dell’algebra relazionale.
			Combina ciascuna riga $ r_1 $ di $ table_1 $ con ciascuna riga di $ table_2 $ che
			soddisfa la condizione della clausola \lstinline|ON|.
			
			\bigskip
			\noindent
			\begin{minipage}{0.6\textwidth}
					\begin{lstlisting}
SELECT I.cognome, R.nomeRep, R.sede
FROM Impiegato I INNER JOIN Reparto R
     ON I.nomerep = R.nomerep;
				\end{lstlisting}
				\end{minipage}\hfilneg\vrule\hfill
			\begin{minipage}{0.33\textwidth}
				\begin{tabular}{ll}
						\toprule
						\textbf{cognome} & \textbf{nomerep} \\
						\midrule
						Rossi & Vendite \\
						Verdi & Acquisti \\
						\midrule
					\end{tabular}
				\end{minipage}
			
		\subsubsection*{LEFT OUTER JOIN}
			Si esegue un \lstinline|INNER JOIN|. Poi, per ciascuna riga $ r_1 $ di $ table_1 $ che non
			soddisfa la condizione con qualsiasi riga di $ table_2 $, si aggiunge una riga al
			risultato con i valori di $ r_1 $ e assegnando \lstinline|NULL| agli altri attributi.
			
			\bigskip
			\noindent
			\begin{minipage}{0.7\textwidth}
					\begin{lstlisting}
INSERT INTO Reparto (nomerep, sede, telefono)
   VALUES ('Finanza', 'Padova', '02 8028888');
SELECT R.nomeRep, I.cognome
FROM Reparto R LEFT OUTER JOIN Impiegato I 
     ON I.nomerep = R.nomerep;
				\end{lstlisting}
				\end{minipage}\hfilneg\vrule\hfill
			\begin{minipage}{.27\textwidth}
					\begin{tabular}{ll}
						\toprule
						\textbf{nomerep} & \textbf{cognome} \\
						\midrule
						Acquisti & Rossi \\
						Vendite & Verdi  \\
						Finanza &  \\
						\midrule
					\end{tabular}
				\end{minipage}
		
			\noindent
			\textbf{Nota: } Il \lstinline|LEFT OUTER JOIN| non è simmetrico! \\
			Con le medesime tabelle si possono avere risultati diversi invertendo l’ordine
			delle tabelle nel join!
		\subsubsection*{RIGHT OUTER JOIN}
			Si esegue un \lstinline|INNER JOIN|. Poi, per ciascuna riga $ r_2 $ di $ table_2 $ che non
			soddisfa la condizione con qualsiasi riga di $ table_1 $, si aggiunge una riga al
			risultato con i valori di $ r_2 $ e assegnando \lstinline|NULL| agli altri attributi.
			
			\bigskip
			\noindent
			\begin{minipage}{0.67\textwidth}
					\begin{lstlisting}
SELECT I.cognome, R.nomeRep
FROM Impiegato I RIGHT OUTER JOIN Reparto R 
     ON I.nomerep = R.nomerep;
					\end{lstlisting}
				\end{minipage}\hfilneg\vrule\hfill
			\begin{minipage}{.28\textwidth}
					\begin{tabular}{ll}
							\toprule
							\textbf{cognome} & \textbf{nomerep} \\
							\midrule
							Rossi & Vendite \\
							Verdi & Acquisti \\
							& Finanza \\
							\midrule
						\end{tabular}
					\end{minipage}
	
		\subsubsection*{FULL OUTER JOIN}
			È equivalente a: \lstinline|INNER JOIN + LEFT OUTER JOIN + RIGHT OUTER JOIN| .
			
			\noindent
			\textbf{Nota: }Non è equivalente a \lstinline|CROSS JOIN|!
			
	\subsubsection{Interrogazioni nidificate}
		SQL permette il confronto di un valore (ottenuto come risultato di una
		espressione valutata sulla singola riga) con il risultato dell’esecuzione di
		una interrogazione SQL. L’interrogazione che viene usata nel confronto viene definita
		direttamente nel predicato interno alla clausola \lstinline|WHERE|. \\
		\textbf{Attenzione: }il confronto è tra un valore di un attributo (valore singolo) e
		il risultato di una interrogazione (possibile insieme di valori). Quindi:
		\begin{itemize}
				\item Gli operatori di confronto tradizionali $ (<, >, <>, =, \dots) $ \textbf{NON} non possono	essere usati.
				\item Si devono usare dei nuovi operatori, \lstinline|EXISTS|, \lstinline|IN|, 
				\lstinline|NOT IN|, \lstinline|ALL|, \lstinline|ANY/SOME|, che estendono i tradizionali
				operatori a questo tipo di confronti.
			\end{itemize}
			
	\subsubsection{Operatore EXISTS}
		\begin{lstlisting}
EXISTS (subquery)
		\end{lstlisting}
			\noindent
			\lstinline|(subquery)| è una \lstinline|SELECT|.
			
			\noindent
			\lstinline|EXISTS| ritorna falso se \lstinline|(subquery)| non contiene righe; vero altrimenti.
			
			\noindent
			\lstinline|EXISTS| è significativo quando nella \lstinline|(subquery)| si selezionano righe
			usando i valori della riga corrente nella \lstinline|SELECT| principale: data binding.
			
			\noindent
			Determinare i nomi degli impiegati che sono diversi tra loro ma di pari lunghezza:
			\begin{lstlisting}[tabsize=4]
SELECT I.nome
FROM Impiegato I
WHERE EXISTS(
    SELECT 1 FROM Impiegato Ii WHERE I.nome <> Ii.nome
		AND CHAR_LENGTH(I.nome) = CHAR_LENGTH(Ii.nome)
);
			\end{lstlisting}
			\lstinline|I.nome| nella subquery è il valore di nome nella riga corrente della \lstinline|SELECT| principale.
			
			\noindent
			\textbf{Nota: } L’operatore \lstinline|NOT| può essere usato in coppia con \lstinline|EXISTS|.
			\bigskip
			
	\subsubsection{Operatore IN}
		\begin{lstlisting}
[ ROW ] (expr [ ,...]) IN (subquery)
		\end{lstlisting}
		
		\begin{itemize}
				\item \lstinline|expr| è un’espressione costruita con un attributo della query principale.
			Ci possono essere 1 o più espressioni.
			
				\item La \lstinline|(subquery)| deve restituire un numero di colonne pari al numero di
			espressioni in \lstinline|(expr [,...])|.
			
				\item I valori dell’espressioni vengono confrontati con i valori di ciascuna riga
			del risultato di \lstinline|(subquery)|.
			
				\item Il confronto ritorna vero se i valori sono uguali ai valori di almeno una
			riga della subquery.
			\end{itemize}
		\textbf{Esempio:} 
		\begin{lstlisting}
SELECT I.nome, I.cognome
FROM Impiegato I
WHERE ROW (I.nome, I.cognome ) IN (
    SELECT Ii.nome, Ii.cognome FROM ImpiegatoAltraAzienda Ii
);
		\end{lstlisting}
		
	\subsubsection{Operatore ANY/SOME}
		\begin{lstlisting}
expression operator ANY (subquery)
expression operator SOME (subquery)
		\end{lstlisting}
		\noindent
		\lstinline|(subquery)| è una \lstinline|SELECT| che deve restituire UNA sola colonna; \\
		\lstinline|expression| è un’espressione che coinvolge attributi della \lstinline|SELECT|
		principale.\\
		\lstinline|operator| è un operatore di confronto, come '\lstinline|=|' o '\lstinline|>=|'.\\
		\lstinline|ANY| : ritorna vero se \lstinline|expression| è \lstinline|operator| rispetto al valore di una qualsiasi riga del risultato di \lstinline|(subquery)|.\\
		\lstinline|SOME| è uno sinonimo di \lstinline|ANY|.
		
		Visualizzare il nome degli insegnamenti che hanno un numero di crediti
		inferiore alla media dell’ateneo di un qualsiasi anno accademico:
		\begin{lstlisting}
SELECT DISTINCT I.nomeins, IE.crediti
FROM Insegn I JOIN InsErogato IE ON I.id = IE.id_insegn
WHERE IE.crediti < ANY (
    SELECT AVG(crediti) FROM InsErogato
    GROUP BY annoaccademico
);
		\end{lstlisting}
		
	\subsubsection{Operatore ALL}
		\begin{lstlisting}
expression operator ALL (subquery)
		\end{lstlisting}
		\noindent
		\lstinline|(subquery)| è una \lstinline|SELECT| che deve restituire UNA sola colonna;\\
		\lstinline|expression| è un’espressione che coinvolge attributi della \lstinline|SELECT|
		principale.\\
		\lstinline|operator| è un operatore di confronto, come ’\lstinline|=|’ o ’\lstinline|>=|’.\\
		\lstinline|ALL| : ritorna vero se \lstinline|expression| è \lstinline|operator| rispetto al valore di ciascuna riga del risultato di \lstinline|(subquery)|.
		
		Trovare il nome degli insegnamenti (o moduli) con almeno un docente e
		crediti maggiori rispetto ai crediti di ciascun insegnamento del corso di laurea
		con id=6.
		\begin{lstlisting}
SELECT DISTINCT I.nomeins, IE.crediti
FROM Insegn I
JOIN InsErogato IE ON I.id = IE.id_insegn
JOIN Docenza D ON IE.id = D.id_inserogato
WHERE IE.crediti > ALL (
    SELECT crediti FROM InsErogato
    WHERE id_corsostudi = 6
);
		\end{lstlisting}
		
	\subsubsection{Operatori insiemistici UNION/INTERSECT/EXCEPT}
		Gli operatori insiemistici si possono utilizzare solo al livello più esterno
		di una query, operando sul risultato di due o più clausole \lstinline|SELECT|.\\
		Gli operatori insiemistici sono: \lstinline|UNION|, \lstinline|INTERSECT| e \lstinline|EXCEPT|.\\
		Si possono avere sequenze di \lstinline|UNION/INTERSECT/EXCEPT|
		\begin{lstlisting}[mathescape]
query$_1$ { UNION or INTERSECT or EXCEPT } [ ALL ] query$_2$
		\end{lstlisting}
		\begin{itemize}
				\item Gli operatori si possono applicare solo quando $ \textup{query}_1 $ e 
				$ \textup{query}_2 $ producono risultati con lo stesso numero di colonne e di tipo compatibile
				fra loro.
				\item Tutti gli operatori eliminano i duplicati dal risultato a meno che \lstinline|ALL| non
				sia stato specificato.
				\item \lstinline|UNION| aggiunge il risultato di $ \textup{query}_2 $ a quello di 
				$ \textup{query}_1 $ .
				\item \lstinline|INTERSECT| restituisce le righe che sono presenti sia nel risultato di
				$ \textup{query}_1 $ sia in quello di $ \textup{query}_2 $ .
				\item \lstinline|EXCEPT| restituisce le righe di $ \textup{query}_1 $ che non sono presenti nel risultato
				di $ \textup{query}_2 $ . In pratica esegue la differenza insiemistica.
			\end{itemize}
		\noindent
		\textbf{Esempi: }\\
		Visualizzare i nomi degli insegnamenti e i nomi dei corsi di laurea che non
		iniziano per ’A’ mantenendo i duplicati.
		\begin{lstlisting}
SELECT nomeins
FROM Insegn
WHERE NOT nomeins LIKE 'A%'

UNION ALL

SELECT nome
FROM CorsoStudi
WHERE NOT nome LIKE 'A%';
		\end{lstlisting}
		Visualizzare i nomi degli insegnamenti che sono anche nomi di corsi di
		laurea.
		\begin{lstlisting}
SELECT nomeins
FROM Insegn

INTERSECT ALL

SELECT nome
FROM CorsoStudi;
		\end{lstlisting}
		Visualizzare i nomi degli insegnamenti che NON sono anche nomi di corsi di
		laurea.
		\begin{lstlisting}
SELECT nomeins
FROM Insegn

EXCEPT

SELECT nome
FROM CorsoStudi ;
		\end{lstlisting}
	
	\subsubsection{Viste}
		\begin{itemize}
				\item Le viste sono tabelle "virtuali" il cui contenuto dipende dal contenuto
				delle altre tabelle della base di dati.
				\item In SQL le viste vengono definite associando un nome ed una lista di
				attributi al risultato dell’esecuzione di un’interrogazione.
				\item Ogni volta che si usa una vista, si esegue la query che la definisce.
				\item Nell’interrogazione che definisce la vista possono comparire anche altre
				viste.
				\item SQL non ammette però:
				\begin{itemize}
						\item dipendenze immediate (definire una vista in termini di se stessa) o
					ricorsive (definire una interrogazione di base e una interrogazione
					ricorsiva);
						\item dipendenze transitive circolari ($ V_1 $ definita usando $ V_2 $, $ V_2 $ usando $ V_3 $, $ \dots $, $ V_n $ usando $ V_1 $).
					\end{itemize}
			\end{itemize}
		\begin{lstlisting}
CREATE [ TEMP ] VIEW nome [ (col_name [ , ...]) ] AS query
		\end{lstlisting}
		\noindent
		\begin{itemize}
				\item \lstinline|TEMP| : la vista è temporanea. Quando ci si sconnette, la vista viene
			distrutta. È un’estensione di PostgreSQL. Nella base di dati \lstinline|did2014| si
			possono fare solo viste temporanee.
			\item \lstinline|column_name| : nomi delle colonne che compongono la vista. Se non si
			specificano, si ereditano dalla query.
			\item \lstinline|query| deve restituire un insieme di attributi pari e nel medesimo ordine
			a quello specificato con \lstinline|(column_name [, ...])| se presente.
			\end{itemize}
		
		
		\bigskip
		
		\textbf{Esempi: }\\
		Definire la vista che contiene gli insegnamenti erogati completi di
		nomeins e codiceins presi dalla tabella Insegn .
		\begin{lstlisting}
CREATE TEMP VIEW InsErogatiCompleti AS
SELECT I.nomeins, I.codiceins, IE.*
FROM InsErogato IE JOIN Insegn I 
     ON IE.id_insegn = I.id;
		\end{lstlisting}
		
		\noindent
		Si vuole determinare qual è il corso di studi con il massimo numero di
		insegnamenti (esclusi i moduli).
		Prima si crea una vista:
	\begin{lstlisting}
CREATE TEMP VIEW InsCorsoStudi(Nome, NumIns) AS
  SELECT CS.nome, COUNT(*)
  FROM CorsoStudi CS JOIN InsErogato IE 
       ON CS.id = IE.id_corsostudi
  WHERE IE.modulo = 0
  GROUP BY CS.nome;
	\end{lstlisting}
		Poi la si usa:
		\begin{lstlisting}
SELECT Nome, NumIns
FROM InsCorsoStudi
WHERE NumIns = ANY (
    SELECT MAX(NumIns) FROM InsCorsoStudi
);

		\end{lstlisting}
		
		\noindent
		\textbf{NOTA: } \textit{Non è possibile usare due operatori di aggregazione in cascata!}
	\newpage		
	\section{Indici}
	Gli indici sono strutture dati che permettono di accedere ad una tabella dati in maniera più efficiente. Dato che un indice è completamente scorrelato dalla tabella dati a cui si riferisce, deve sempre essere mantenuto aggiornato in base al contenuto della tabella cui si riferisce. Il costo dell'aggiornamento di un indice può essere significativo quando ci sono molti indici definiti sulla base di dati, per cui è bene usarli con saggezza ed applicarli nella maniera più efficiente possibile.
	
	Una buona regola pratica per l'uso di indici, dal momento che costano tempo e memoria, è di applicarli in base alle query eseguite più frequentemente, tenendo anche presente che il sistema deve aggiornare l'indice per ogni operazione \lstinline|INSERT, DELETE| e \lstinline|UPDATE|.
	
	\subsection{Comando timing}
	Il comando \lstinline|\timing| da un 'idea del tempo necessario all'esecuzione di una query.
	In un prompt di \verb|psql| basta eseguire:
	\begin{lstlisting}
=> \timing
=> select * from tabella;
	\end{lstlisting}

	\subsection{Comando CREATE INDEX} \label{createindex}
	\begin{lstlisting}[escapeinside={(*}{*)}]
CREATE [ UNIQUE ] INDEX [nome]
ON tabella [ USING method ]
({ nomeAttr (*| (expression) } [ ASC | DESC ] [ , ...])
	\end{lstlisting}
	dove:
	\begin{itemize}
		\item \verb|method| è il tipo di indice;
		\item \verb|nomeAttr| o \verb|expression| indicano su quali colonne o espressioni con colonne si deve creare l'indice;
		\item \lstinline|ASC/DESC| indica se l'attributo è ascendente o discendente;
		\item \lstinline|ALTER INDEX| e \lstinline|DROP INDEX| permettono di modificare o rimuovere gli indici.
	\end{itemize}

	Una volta creato, l'indice è usato dal sistema ogni volta che l'ottimizzatore di query lo ritiene opportuno, ovvero solo quando il vantaggio derivato è di una certa consistenza. Un indice può anche essere utilizzato per ottimizzare l'esecuzione di \lstinline|UPDATE| e \lstinline|DELETE|, se nella clausola \lstinline|WHERE| ci sono attributi indicizzati.
	
	\noindent
	\textbf{Nota: PostgreSQL crea in automatico indici per gli attributi dichiarati come chiave primaria, quindi è inutile indicizzarli.}
	
	\subsection{Comando ANALYZE}
	Il comando \lstinline|ANALYZE| è usato per forzare l'aggiornamento delle statistiche di esecuzione delle query quando uno o più nuovi indici sono creati.
	\begin{lstlisting}
CREATE INDEX ie_id_corsostudi ON Inserogato (id_corsostudi) ;
CREATE INDEX ie_id_insegn ON Inserogato (id_insegn);
CREATE INDEX ie_aa_C ON Inserogato (annoaccademico);
CREATE INDEX ie_aa_IT ON Inserogato (annoaccademico varchar_pattern_ops);
CREATE INDEX cs_nome ON Corsostudi (nome varchar_pattern_ops);
ANALYZE;
	\end{lstlisting}
	
	\subsection{Tipi di indici}
	PostgreSQL ammette molti tipi di indice, tra i quali: \textbf{B-tree, hash, GiST, SP-GiST, Gin, Brin}.
	Ognuno di questi tipi usa una tecnica algoritmica diversa e risulta migliore di altri in alcune situazioni (vedi \ref{createindex} per la specifica del tipo di indice da creare).
	Se il tipo di indice non è specificato, viene creato un indice di tipo B-tree.
	
	 Nello specifico caso dell'indice B-tree, questo viene utilizzato quando l'attributo coinvolto è usato con gli operatori di confronto di valore o con i comandi \lstinline|BETWEEN, IN, IS NULL, IS NOT NULL | e \lstinline|LIKE|.
	 La keyword \textbf{varchar\_pattern\_ops} è inserita quando si vuole che l'indice consideri anche i pattern del tipo \lstinline|LIKE 'stringa%'|.
	 
	 \subsection{Indici multi-attributo}
	 Se si hanno query con condizioni su coppie o terne, a volte può essere più efficiente l'uso di un indice dichiarato su due attributi rispetto a due indici mono-attributo.
	 

	 
	 Ad esempio, con una query come:
	 \begin{lstlisting}
SELECT I.nomeins, I.codiceins
FROM Insegn I
JOIN InsErogato IE ON I.id = IE.id_insegn
WHERE IE.annoaccademico = '2006/2007'
	AND IE.id_corsostudi = 4;
	 \end{lstlisting}
	 che controlla gli attributi \verb|annoaccademico| e \verb|id_corsostudi|, è utile usare un indice multi-attributo che indicizzi i due campi:
	 \begin{lstlisting}
CREATE INDEX ie_aa_idcs ON Inserogato (annoaccademico, id_corsostudi);
	 \end{lstlisting}
	 Non sempre gli indici multi-attributo possono essere usati, come nel caso di espressioni con \lstinline|OR|.
	 
 	\subsection{Comando EXPLAIN}
	Ogni DBMS ha un ottimizzatore di query che determina un piano di esecuzione per ogni query. Il comando \lstinline|EXPLAIN [query]| permette di vedere il piano di esecuzione della query, facilitando l'analisi dei colli di bottiglia e l'ottimizzazione.
	
	Un piano di esecuzione di una query è un albero di nodi di esecuzione, dove le foglie sono \textbf{nodi di scansione}, che restituiscono gli indirizzi di righe della tabella. I possibili tipi di scansione sono 3: sequenziali, indicizzate e bit-mapped. Se una query contiene \lstinline|JOIN, GROUP BY, ORDER BY| o altre operazioni sulle righe, allora ci saranno altri nodi di esecuzione sopra i nodi foglia.
	
	L'output del comando ha una riga per ogni nodo dell'albero di esecuzione dove viene indicato il tipo di operazione e una stima del costo di esecuzione. La prima riga contiene il costo complessivo della query.
	
	\paragraph{Esempio 1.}
	Considerare questa query:
	\begin{lstlisting}
EXPLAIN SELECT * FROM Insegn ;
	\end{lstlisting}
	Il piano corrispondente è:
	\begin{lstlisting}
Seq Scan ON insegn (cost=0.0..185.69 ROWS=8169 width=63)
	\end{lstlisting}
	ed ha un costo di 185.69 (in termini di accesso a disco), con un risultato stimato di 8169 righe (il numero potrebbe non essere assolutamente preciso).
	
	\paragraph{Esempio 2.} 
	Considerare questa query:
	\begin{lstlisting}
EXPLAIN SELECT * FROM Insegn WHERE id < 1000;
	\end{lstlisting}
	Il piano corrispondente è:
	\begin{lstlisting}
Bitmap Heap Scan ON insegn ( cost=18. 60..13 2.79 ROWS=815...)
Recheck Cond : ( id < 1000)
-> Bitmap INDEX Scan ON insegn_pkey(cost=0..18.39 ROWS=815 width=0)
	INDEX Cond : ( id < 1000)
	\end{lstlisting}
	Prima viene eseguito il nodo foglia \lstinline|Bitmap Index Scan| che, grazie all'indice, permette di ritornare un vettore di bit che marca le righe da considerare. Il vettore viene poi passato al nodo padre \lstinline|Bitmap Heap Scan|, che esegue la selezione delle righe che hanno $id < 1000$.
	
	\paragraph{Esempio 3.}
		Considerare questa query:
	\begin{lstlisting}
EXPLAIN SELECT *
FROM t1, t2
WHERE t1.unique1 < 100 
	AND t1.unique2 = t2.unique2 ;
	\end{lstlisting}
	Il piano corrispondente è:
	\begin{lstlisting}
Merge JOIN (cost=198.11..268.19 ROWS=10 width=488)
	Merge Cond : ( t1.unique2 = t2.unique2 )
	-> INDEX Scan USING t1_unique2 ON t1 (cost=0..656 ROWS=101..)
		Filter : (unique1 < 100)
	-> Sort (cost=197.83..200.33 ROWS=1000..)
	Sort KEY : t2.unique2
		-> Seq Scan ON t2 (cost=0.00..148.00 ROWS=1000..)
	\end{lstlisting}
	\lstinline|Merge JOIN| esegue il join ordinando le due tabelle rispetto agli attributi di join. \\
	
	Esiste una variante estesa di \lstinline|EXPLAIN|, \lstinline|EXPAIN ANALYZE|, che esegue la query senza registrare le modifiche e mostra una stima verosimile dei tempi di esecuzione.

	\newpage
	
		\section{Transazioni concorrenti}
	Una transazione SQL è una sequenza di istruzioni ed è eseguita in maniera atomica.
	Gli stati intermedi della base di dati durante l'esecuzione della serie di istruzioni della transazione non sono visibili al di fuori della transazione stessa.
	Se una transazione termina senza errori, le modifiche vengono salvate, in caso contrario lo stato della base di dati rimane quello presente prima dell'inizio della transazione e non viene salvata nessuna modifica.
	
	A volte può capitare che le transazioni accedano in modo concorrente alle stesse informazioni nella base di dati, e può non essere garantito il corretto svolgimento delle operazioni; in questo caso vengono impostati dei livelli di isolamento della transazione rispetto alle altre, con diversi effetti sull'accesso concorrente ai dati.
	
	In PostgreSQL i livelli di isolamento sono 4:
		\begin{itemize}
			\item Read Committed
			\item Repeatable Read
			\item Serializable
			\item Read Uncommitted
		\end{itemize}
		Prendiamo come esempio la seguente tabella:
		\lstinline|Web|:
		\begin{tabular}{cc}
			\toprule
			\lstinline|id| & \lstinline|hits| \\
			\midrule
			1 & 9 \\
			2 & 10 \\
			\midrule
		\end{tabular}
		
		\subsection{Read Committed}
			È il \textbf{livello di default}, basta scrivere \lstinline|BEGIN;|
			\begin{itemize}
				\item \lstinline|SELECT| vede solo i dati registrati (\lstinline|COMMITTED|) in altre transazioni e quelli modificati da comandi precedenti nella stessa transazione.
				\item \lstinline|UPDATE| e \lstinline|DELETE| vedono i dati come \lstinline|SELECT|
				\item Se i dati da aggiornare sono stati modificati ma \textbf{non registrati} in transazioni concorrenti, il comando deve:
				\begin{itemize}
					\item Attendere il \lstinline|COMMIT| o \lstinline|ROLLBACK| della transazione concorrente.
					\item Riesaminare le righe per verificare che soddisfano ancora i criteri del comando.
				\end{itemize}
			\end{itemize}
			\textbf{Esempio: Non-repeatable reads}
			\begin{multicols}{2}
				\noindent
				$ T_1 $:
				\begin{lstlisting}
BEGIN;
UPDATE Web SET hits=hits+1;

COMMIT;
				\end{lstlisting}
				\columnbreak
				$ T_2 $:
				\begin{lstlisting}
BEGIN;

DELETE FROM Web WHERE hits=10;

				\end{lstlisting}
			\end{multicols}
			\lstinline|DELETE| non riesce a cancellare: la riga è quella con \lstinline|id = 2|, che viene aggiornata da \lstinline|UPDATE| il quale sblocca \lstinline|DELETE| fino al \lstinline|COMMIT|. \lstinline|DELETE| riesamina la riga e trova che il criterio non è più soddisfatto.
			
		\subsection{Repeatable Read}
			Differisce da Read Committed per il fatto che i comando di una transazione \textbf{vedono sempre gli stessi dati}. Due \lstinline|SELECT| identiche vedono sempre gli stessi dati.
			\begin{itemize}
				\item \lstinline|UPDATE| e \lstinline|DELETE| vedono i dati come \lstinline|SELECT|.
				\item Se i dati da aggiornare sono stati modificati ma \textbf{non registrati} in transazioni concorrenti, il comando deve attendere: 
				\begin{itemize}
					\item il \lstinline|COMMIT| e quindi i dati vengono cambiati e \lstinline|UPDATE| e \lstinline|DELETE| vengono bloccate con errore.
					\item il \lstinline|ROLLBACK| e quindi \lstinline|UPDATE| e \lstinline|DELETE| possono procedere.
				\end{itemize}
			\end{itemize}
			
			\noindent
			\textbf{Esempio1: Cattura l'anomalia Non-repeatable reads}
			\begin{multicols}{2}
			\noindent
			$ T_1 $:
			\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  REPEATABLE READ;

UPDATE Web SET hits=hits+1;

COMMIT;
			\end{lstlisting}
			\columnbreak
			$ T_2 $:
			\begin{lstlisting}
BEGIN;

DELETE FROM Web WHERE hits=10;

ERROR: could NOT serialize 
access due to concurrent UPDATE.
			\end{lstlisting}
			\end{multicols}
			\noindent
			\textbf{Esempio2: Phantom Reads}
			\begin{multicols}{2}
			\noindent
			$ T_1 $:
			\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  REPEATABLE READ;
 
INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;
  
COMMIT;
			\end{lstlisting}
			\columnbreak
			$ T_2 $:
			\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  REPEATABLE READ;

INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;

COMMIT;
			\end{lstlisting}
			\end{multicols}
		La tabella finale contiene due valori 11 e non 11 e 12 (inserimento fantasma).
		
	\subsection{Serializable}
		È \textbf{il più restrittivo} e garantisce che le transazioni siano eseguite \textbf{come se fossero sequenziali tra loro} (in un ordine non prestabilito). Si deve però prevedere la possibilità di transazioni abortite più frequenti per gli aggiornamenti concorrenti tipo Repeatable Read.\\
		\textbf{Esempio:}
		\begin{multicols}{2}
		\noindent
		$ T_1 $:
		\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  SERIALIZABLE;
  
INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;

COMMIT;
		\end{lstlisting}
		\columnbreak
		$ T_2 $:
		\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  SERIALIZABLE;

INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;

COMMIT;
		\end{lstlisting}
		\end{multicols}
		
		La $ T_2 $ riporta il seguente errore:
		\begin{lstlisting}
ERROR: could not serialize access due to READ/WRITE dependencies 
       among transactions
DETAIL: reason code: canceled ON identification AS a pivot, 
        during COMMIT attempt
HINT: the TRANSACTION might succeed if retried.
		\end{lstlisting}
	
	
	
	\section{Psycopg2}
	\textit{psycopg2} è una libreria Python che consente di collegarsi a database SQL ed eseguire statement di vario genere, il tutto da codice Python ad alto livello.
	
	Le operazioni da svolgere per collegarsi ed effettuare le operazioni sono:
	\begin{itemize}
		\item Collegarsi al database:
		\begin{lstlisting}[frame=tb]
def connect():
	conn = psycopg2.connect(host=[host],
		database=[db-name], user=[username], password=[password])
	return conn
		\end{lstlisting}
		\lstinline|conn| è un'istanza della classe \lstinline|Connection|.
		
		\item Ottenere un cursore dalla connessione: un cursore è come un buffer che contiene temporaneamente i dati delle operazioni svolte e da svolgere
		\begin{lstlisting}[frame=tb]
cursor=conn.cursor()
		\end{lstlisting}
		
		\item Eseguire le operazioni da svolgere con le seguenti chiamate:
		\begin{lstlisting}[frame=tb]
cursor.execute([statement],[params])
conn.commit()
		\end{lstlisting}
		dove \lstinline|statement| è lo statement da eseguire sulla base di dati, mentre \lstinline|commit()| esegue effettivamente l'operazione. \lstinline|params| è una o più tuple (o dizionario) che contengono i dati da inserire. Nella stringa dello statement i parametri da sostituire vanno rimpiazzati con dei segnaposto \lstinline|%s|. La libreria si occuperà di fare tutte le conversioni, quindi non servono cast.
		
		\item Ottenere i risultati da elaborare con la chiamata di:
		\begin{lstlisting}[frame=tb]
conn.fetchone() # legge una sola riga
conn.fetchmany([numero]) # legge [numero] righe
conn.fetchall() # legge tutte le righe
		\end{lstlisting}
		Se non ci sono tuple, viene ritornato \lstinline|None|  nei primi due casi (\lstinline|numero| è il numero di tuple da leggere dal risultato), una lista vuota nel terzo caso.
		
		\item Chiudere le risorse con \lstinline|conn.close()| e \lstinline|cursor.close()|.
	\end{itemize}
	
	In alternativa alla procedura appena illustrata si può usare il costrutto \verb|with| con la seguente sintassi:
	\begin{lstlisting}[frame=tb]
with conn.cursor() as cur:
	cur.execute([statement],[params])
	...
	\end{lstlisting}
	In questo modo \textbf{non serve il commit}, in quanto viene fatto automaticamente al termine dell'esecuzione del corpo del \verb|with|, la connessione invece va chiusa manualmente.
	
	Un esempio di come venga usata questa liberia si può trovare nella sezione dedicata a Flask.
	\newpage
	
			
		
	\section{Flask}
	\lstset{language=Python}
		\subsection{HTTP requests:}
			\begin{itemize}
				\item \lstinline|GET|: serve ad un client per \textbf{recuperare} una risorsa dal server (come la richiesta di una pagin web). Eventuali parametri da inviare al server sono specificati nella \textbf{query string} dell'URL.
				\item \lstinline|POST|: serve ad un client per \textbf{inviare} informazioni al server. La maggior parte dei browser usa post per \textbf{inviare dati delle form ai server}. I dati sono specificati nel corpo della richiesta.
			\end{itemize}
		\subsection{Accesso ai parametri della query string di una richiesta GET}
		\textbf{Query String} rappresentata dalla variabile \lstinline|request.args| di tipo \lstinline|dict|, accessibile direttamente dal metodo associato all'URL:
		\begin{lstlisting}[frame=tb]
from flask import Flask, request
app = Flask(__name__)

@app.route('/login')
def login():
	user = request.args['user']
	role = request.args['role']
	return ...
		\end{lstlisting}
		\subsection{Accesso ai parametri della query string di una richiesta POST}
		\lstset{language=HTML}
		\begin{lstlisting}[frame=tb, caption={esempio di form html5}]
<form action="http://localhost:5000/login" method="post">
	<label> Name: <input type="text" name="user"/> </label><br>
	<label> Role: <input type="text" name="role"/> </label><br>
	<input type="submit" value="Invia">
</form>
		\end{lstlisting}
		\lstset{language=Python}
		I dati di un \lstinline|POST| sono nel dict \lstinline|request.form|
		\begin{lstlisting}[frame=tb]
@app.route('/login')
def login():
	user = request.form['user']
	role = request.form['role']
	return ...
		\end{lstlisting}
		Il metodo \lstinline|route()| associa un metodo a un URL in modalità \lstinline|GET|, per usare lo stesso sistema in modalità \lstinline|POST|, è necessario specificare esplicitamente i metodi che vengono utilizzati:
		\begin{lstlisting}
@app.route('/',method=['GET','POST'])
		\end{lstlisting}
		
		\newpage
		
		\subsection{Esempio esercizio d'esame con integrazione HTML}
			Dall'esame del 04/07/2017:\\		
			Assumendo di avere una base di dati PostgreSQL che contenga le tabelle di questo tema d'esame, scrivere:
			\begin{enumerate}[label=(\alph*)]
				\item Un template JINJA2 per una form HTML 5 che: (1) permetta di acquisire un codice fiscale (controllando il formato), (2) di selezionare una biblioteca dalla lista \lstinline|biblioteche| passata come parametro al template e (3) invii i dati all'URL \lstinline|/prestitiUtente| in modalità GET. Il formato di \lstinline|biblioteche| è \lstinline|[{id, nome}, ...]|.\\
				Scrivere solo la parte della FORM, non tutto il documento HTML. 
				
				\item Un metodo Python che, associato all'URL \lstinline|/prestitiUtente| secondo il framework Flask, (1) legga i parametri codice fiscale e identificatore biblioteca, (2) si connetta alla base di dati 'X' (si assuma di dover specificare solo il nome della base di dati) e recuperi tutti i prestiti (idRisorsa, dataInizio, durata) associati al codice fiscale e biblioteca dati come parametri (scrivere la query!), (3) usi il metodo \lstinline|render_template('view.html', ...)| per pubblicare il risultato passando la lista del risultato. Se il  risultato dell'interrogazione è vuoto, il metodo deve passare il controllo a \lstinline|render_template('nessunPrestito0Errore.html')|.\\
				Scrivere solo il metodo.
			\end{enumerate}
			Soluzione (a):
			\lstset{language=HTML}
			\begin{lstlisting}[frame=tb, tabsize=2]
<form action="/prestitiUtente" method="get">
	<label for="codicef">Codice fiscale: </label>
		<input id="codicef" name="cf" type="text" pattern="[A-Z]...">
	<br>
	<label for="biblioteca">Biblioteca: </label>
		<select id="biblioteca" name="biblio">
			{% for b in biblio %}
			<option value="{{b.id}}"> {{b.nome}} </option>
			{% endfor %}
		</select>
	<input type="submit" value="Invia">
</form>
			\end{lstlisting}
			Soluzione (b):
			\lstset{language=Python}
			\begin{lstlisting}[frame=tb, tabsize=2]
@app.route('/prestitiUtente', methods= ['GET'])
def getPrestiti():
	cf = request.args['cf']
	biblio = request.args['biblio']
	
	with psycopg2.connect(database='X') as conn:
		with conn.cursor as cur:
			cur.execute("SELECT P.idRisorsa, P.dataInizio, P.durata\
				FROM Prestito P WHERE P.idUtente = %s AND\
				P.idBiblioteca = %s", cf, int(biblio))
			prestiti = cur.fetchall()
			
			if not prestiti:
				return render_template('nessunPrestito0Errore.html')
				
			return render_template('view.html', prestiti=prestiti, 
				cf=cf, biblio=biblio)
			\end{lstlisting}
			
		\subsection{Un altro esempio}
		Qui di seguito un altro esempio di applicazione scritta con Flask, pensata per la gestione delle spese. \\
		File \verb|controller.py|:
		\lstset{language=Python}

		\begin{lstlisting}[frame=tb,tabsize=2]
from datetime import datetime, date
from decimal import Decimal
from flask import *
import psycopg2

app = Flask(__name__)

HOST = [nome-host]
DATABASE = [nome-db]
USER =[username]


def connect():
	connection = psycopg2.connect(host=HOST, database=DATABASE, 
		user=USER, password=[password])
	return connection


def get_cursor(connection):
	return connection.cursor()


def insert_data(tup):
	conn = connect()
	cursor = conn.cursor()
	cursor.execute('insert into Spese(date, description, import) values 
		(%s, %s, %s)', tup)
	conn.commit()
	conn.close()

def remove_data(tup):
	conn = connect()
	cursor = conn.cursor()
	cursor.execute('delete from Spese where date=%s and description=%s
		 and import=%s ', tup)
	conn.commit()
	conn.close()


@app.route('/', methods=['POST', 'GET'])
def fill_table():
	connection = connect()
	cursor = get_cursor(connection)
	cursor.execute('select date, description, import from Spese')
	connection.commit()
	table = cursor.fetchall()
	connection.close()

	if request.method == 'POST':
		if request.form['submit'] == 'Add entry':
			return redirect(url_for('new_entry'))
		elif request.form['submit'] == 'Remove entry':
			return redirect(url_for('remove_entry'))

	return render_template('main_table.html', table=table)


@app.route('/new_entry', methods=['POST', 'GET'])
def new_entry():
	if request.method == 'POST':
		if request.form['submit'] == 'Confirm':
			purchase_date = datetime.strptime(request.form['date'],
				 '%d/%m/%Y')
			price = float(request.form['cost'])
			descr = request.form['descr']
			insert_data((date(purchase_date.year, 
				purchase_date.month, purchase_date.day), descr,
				 Decimal(price)))
			return redirect(url_for('fill_table'))
	
	return render_template('new_entry.html')


@app.route('/remove_entry', methods=['POST', 'GET'])
def remove_entry():
	if request.method == 'POST':
		if request.form['submit'] == 'Delete':
			purchase_date = datetime.strptime(request.form['date'],
				 '%d/%m/%Y')
			price = float(request.form['cost'])
			descr = request.form['descr']
			remove_data((date(purchase_date.year, 
				purchase_date.month, purchase_date.day), descr,
				 Decimal(price)))
			return redirect(url_for('fill_table'))
	
	return render_template('remove_entry.html')


if __name__ == '__main__':
app.run()
		\end{lstlisting}
		Qui di seguito le pagine html create e utilizzate (puramente funzionali, non hanno nulla di estetico!). \\
		File \verb|main_table.html|:
		\lstset{language=HTML}
		\begin{lstlisting}[frame=tb,tabsize=4]
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<h1>Gestione spese</h1>
</head>
<body>
<table border="1" cellpadding="5" cellspacing="5" width="500">
	<tr>
	<th>Data</th>
	<th>Descrizione</th>
	<th>Importo</th>
	</tr>
	{% for entry in table %}
		<tr>
		<td>{{entry[0]}}</td>
		<td>{{entry[1]}}</td>
		<td>{{entry[2]}}</td>
		</tr>
	{% endfor %}
</table>

<form method="post">
<input type="submit" name="submit" value="Add entry"/>
<input type="submit" name="submit" value="Remove entry"/>
</form>
</body>
</html>
		\end{lstlisting}
		
		File \verb|new_entry.html|:
		\begin{lstlisting}[frame=tb,tabsize=4]
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<h1>Add new entry</h1>
</head>
<body>
<form method="post">
	Data:<input name="date" pattern="[0-9]{2}/[0-9]{2}/[0-9]{4}"/> <br>
	Importo:<input name="cost"/> <br>
	Descrizione:<input name="descr"/> <br>
	
	<input type="submit" name="submit" value="Confirm">
</form>
</body>
</html>
		\end{lstlisting}
		
	File \verb|remove_entry.html|
	\begin{lstlisting}[frame=tb,tabsize=4]
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<h1>Remove entry</h1>
</head>
<body>
<form method="post">
	Data:<input name="date" pattern="[0-9]{2}/[0-9]{2}/[0-9]{4}"/> <br>
	Importo:<input name="cost"/> <br>
	Descrizione:<input name="descr"/> <br>
	
	<input type="submit" name="submit" value="Delete">
</form>
</body>
</html>
	\end{lstlisting}
	\newpage
\section{JDBC}
JDBC è una libreria di funzioni Java che consente di collegarsi ad un database ed eseguire operazioni.
Le fasi principali per eseguire una qualsiasi operazione sono:

\begin{enumerate}
	\item Caricare il driver \lstinline|org.postgresql.Driver|;
	
	\item Collegarsi al database sul quale si intende operare;
	
	\item Creare gli statement da eseguire;
	
	\item Eseguire gli statement e il commit;
	
	\item Chiudere le risorse utilizzate.
\end{enumerate}

\subsection{Caricamento del driver}
Questa fase consente di caricare i moduli che servono per collegarsi al database. Si effettua eseguendo l'opportuna chiamata:
\lstset{language=Java}
\begin{lstlisting}
Class.forName("org.postgresql.Driver");
\end{lstlisting}

\subsection{Collegamento al database}
Per collegarsi al database si effettua una chiamata che, passando gli opportuni parametri, ritorna un oggetto di tipo \lstinline|Connection|, che verrà usato per eseguire gli statement nelle prossime fasi.

\begin{lstlisting}
try {
	Connection connection = DriverManager.getConnection(
		[url], [utente], [password]);
} catch (SQLException e) {
	System.out.println(e.getMessage());
}
\end{lstlisting}

\subsection{Creazione ed esecuzione di statement}
Gli statement sono le istruzioni SQL da eseguire sul database. Per statement semplici si può usare questo snippet:
\begin{lstlisting}
try {
	Statement ps = connection.createStatement();
	ResultSet rs = ps.executeQuery("select * from Spese");
} catch (SQLException e) {
	e.printStackTrace();
}
\end{lstlisting}
dove \lstinline|connection| è un'istanza della classe \lstinline|Connection|. Se lo statement è un comando di aggiornamento (\lstinline|insert|, \lstinline|update|) si usa il metodo \lstinline|executeUpdate| o \lstinline|executeLargeUpdate| il quale \textit{ritorna il \textbf{numero di righe che sono state modificate}}.

Se gli statement sono complessi e hanno magari una clausola \lstinline|where| con vari confronti, bisogna prima creare un oggetto \lstinline|PreparedStatement|, con la seguente sintassi:

\begin{lstlisting}
try {
	PreparedStatement ps = connection.prepareStatement(
		"insert into Spese(data, voce, importo) values(?, ?, ?)");
	ps.setDate(1, date);
	ps.setString(2, descr);
	ps.setFloat(3, price);
	ps.executeUpdate();
} catch (SQLException e) {
	e.printStackTrace();
}
\end{lstlisting}
dove \lstinline|connection| è un'istanza della classe \lstinline|Connection|. I punti interrogativi sono usati come segnaposto da rimpiazzare con con i metodi \lstinline|setDate()|, \lstinline|setString()| ecc.
I metodi set funzionano passando come parametro un indice (da 1), e il valore che si vuole sostituire nella query. In questo modo i punti interrogativi saranno rimpiazzati dai campi passati nei metodi set. \\

\noindent
\textbf{Nota: le connessioni sono auto-commit, il commit viene eseguito al termine dell'esecuzione di ogni comando.}

\subsection{Accesso ai campi e chiusura risorse}
\paragraph{Accesso ai dati.}
La query viene eseguita con il metodo \lstinline|executeQuery()| che ritorna un oggetto di tipo \lstinline|ResultSet| il quale contiene lo stato e l'eventuale tabella risultato, alla quale si può accedere tramite metodi get.
Supponendo di aver eseguito la query:
\begin{lstlisting}
...
ResultSet rs = ps.executeQuery("select * from Spese");
...
\end{lstlisting}
si accede ai dati contenuti in \lstinline|rs| tramite chiamate del tipo:
\begin{lstlisting}
rs.get[tipoDato]([nomeCampo]);
\end{lstlisting}

Ad esempio, avendo l'attributo \lstinline|Descrizione| nella tabella \lstinline|Spese| di tipo \lstinline|varchar|:
\begin{lstlisting}
rs.getString("descrizione");
\end{lstlisting}

\paragraph{Chiusura risorse.}
Quando gli statement da eseguire sono terminati, va chiusa la connessione utilizzata con:
\begin{lstlisting}
connection.close();
\end{lstlisting}

\subsection{Modulo JDBC completo}
Qui di seguito viene inserito un modulo jdbc per il controllo della tabella \lstinline|Spese| utilizzata negli esempi precedenti.

\begin{lstlisting}[tabsize=2]
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		printMenu();
		callFunction();

	}

	private static void displayData() {
		Connection connection = getConnection();
		try {
			Statement ps = connection.createStatement();
			ResultSet rs = ps.executeQuery("select * from Spese");
		printData(rs);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
	private static void insertData() {
		Connection connection = getConnection();
		Scanner scan = new Scanner(System.in);
		System.out.print("Data:");
		String dateString = scan.next();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
		Date date = null;
		try {
			date = new Date(format.parse(dateString).getTime());
		} catch (ParseException e) {
			System.out.println(e.getMessage());
		}
		System.out.print("Prezzo:");
		float price = Float.parseFloat(scan.next());
		
		System.out.print("Descrizione:");
		String descr = scan.next();
		
		try {
			PreparedStatement ps = connection.prepareStatement(
			"insert into Spese(data, voce, importo) values(?, ?, ?)");
			ps.setDate(1, date);
			ps.setString(2, descr);
			ps.setFloat(3, price);
			ps.executeUpdate();
			System.out.println("Update completed.");
		} catch (SQLException e) {
			e.printStackTrace();
		}	
	}
	
	private static void removeData() {
		Connection connection = getConnection();
		Scanner scan = new Scanner(System.in);
		System.out.print("Data:");
		String dateString = scan.next();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
		Date date = null;
		try {
			date = new Date(format.parse(dateString).getTime());
		} catch (ParseException e) {
			System.out.println(e.getMessage());
		}
		System.out.print("Prezzo:");
		float price = Float.parseFloat(scan.next());
		
		System.out.print("Descrizione:");
		String descr = scan.next();
		
		try {
			PreparedStatement ps = connection.prepareStatement(
			"delete from Spese where data=? and voce=? and importo=?");
			ps.setDate(1, date);
			ps.setString(2, descr);
			ps.setFloat(3, price);
			ps.executeUpdate();
			System.out.println("Update completed.");
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
	private static void printData(ResultSet rs) {
		try {
			System.out.println(
			String.join("", Collections.nCopies(50, "=")));
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			while (rs.next()) {
				System.out.println(
				String.format("| %2s | %10s | %-20s | %10.2f |",
				 rs.getInt("id"), sdf.format(rs.getDate("data")), 
				 rs.getString("voce"), rs.getFloat("importo")));
			}
			System.out.println(String.join("", 
					Collections.nCopies(50, "=")));
		
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
	private static void printMenu() {
		System.out.println(String.join("", Collections.nCopies(50, "=")));
		System.out.println("1. Display data");
		System.out.println("2. Insert new outlay");
		System.out.println("3. Remove outlay");
		System.out.println(String.join("", Collections.nCopies(50, "=")));
	}
	
	private static Connection getConnection() {
		try {
			Class.forName("org.postgresql.Driver");
			return DriverManager.getConnection(
			"jdbc:postgresql://dbserver.scienze.univr.it:5432/id864ghl",
			"id864ghl", "perzona-falza");
		} catch (ClassNotFoundException | SQLException e) {
			System.out.println(e.getMessage());
		}
	
	return null;
	}
	
	private static void callFunction() {
		Scanner scan = new Scanner(System.in);
		System.out.print("Choose action:");
		int option = Integer.parseInt(scan.next());
		if (option == 0) {
			System.exit(0);
		} else if (option == 1) {
			displayData();
		} else if (option == 2) {
			insertData();
		} else if (option == 3) {
			removeData();
		} else {
			System.out.println("Invalid option");
		}
  }
}
\end{lstlisting}


\section{Credits}
Davide Bianchi (mail: \mail{davideb1912@gmail.com}) \\
Matteo Danzi (mail: \mail{matteodanziguitarman@hotmail.it})


			
\end{document}