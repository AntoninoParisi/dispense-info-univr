\documentclass[a4paper, 10pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[makeroom]{cancel}
\usepackage{ulem}
\usepackage{multicol}
\setlength{\columnseprule}{0.4pt}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{frontespizio}
\usepackage{hyperref}
\usepackage{enumitem}
\hypersetup{hidelinks,
	colorlinks = true,
	urlcolor = black, 
	linkcolor = black}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{listings}
\lstset{inputencoding=utf8,
	language = SQL,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{blue}\bfseries,
	morekeywords={REFERENCES, BOOLEAN, REAL, DOUBLE, PRECISION, TEXT, VARBIT, SIMILAR, TO},
	stringstyle=\color{Purple},
	literate={à}{{\`a}}1
}
\usepackage{fancyvrb}
\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}

\begin{document}
	\begin{frontespizio}
		\Preambolo{\usepackage{datetime}}
		\Istituzione{Università degli Studi di Verona}
		\Divisione{Dipartimento di informatica}
		\Facolta{Scienze e Ingegneria}
		\Scuola{Laurea in Informatica}
		\Titolo{Basi di Dati}
		\Sottotitolo{Programma di laboratorio}
		\Candidato{Davide Bianchi}
		\Candidato{Matteo Danzi}
		\NCandidato{Autori}
		\Annoaccademico{2016/2017}
	\end{frontespizio}

	\tableofcontents
		
	\newpage
	
	\section{Gestione base di dati con Postgresql}
	Di seguito si trova una panoramica dei comandi Postgres più comuni per la gestione di una base di dati.
	
	\subsection{Comando CREATE TABLE}
	Il comando \lstinline{CREATE TABLE} è usato per creare tabelle nella base di dati.
	La sintassi generale è:
	\begin{lstlisting}
CREATE TABLE nomeTabella (
	nomeAttributo dominioAttributo vincoli,
	...
);
	\end{lstlisting}
	dove \lstinline|nomeAttributo| è il nome dell'attributo nella tabella, \lstinline|dominioAttributo| è il dominio dell'attributo da aggiungere alla tabella.
	
	\subsubsection{Domini elementari}
	I domini di default disponibili in Postgres sono:
	\begin{itemize}
		\item \lstinline|BOOLEAN|: valori booleani (true/false);
		\item \lstinline|INTEGER|: valori interi a 4 byte;
		\item \lstinline|SMALLINT|: valori interi a 2 bit;
		\item \lstinline|NUMERIC(p, s)|: valori decimali approssimati, dove \lstinline|p| è la precisione del numero (cifre a sinistra e a destra della virgola) e \lstinline|s| la scala (numero di cifre decimali dopo la virgola);
		\item \lstinline|DECIMAL(p, s)|: valori deciamli approssimati, con i parametri uguali a \lstinline|NUMERIC|.
		\item \lstinline|REAL|: valori in virgola mobile a 6 cifre decimali;
		\item \lstinline|DOUBLE PRECISION|: valori in virgola mobile approssimati a 15 cifre decimali;
	\end{itemize}
	\textbf{Nota:} Se si devono rappresentare importi di denaro che contengono anche
	decimali, \textbf{MAI} usare \lstinline|REAL| o \lstinline|DOUBLE PRECISION| ma usare \lstinline|NUMERIC|!

	\subsubsection{Domini di caratteri}
	\begin{itemize}
		\item \lstinline|CHARACTER|: singoli caratteri;
		\item \lstinline|CHARACTER(n)|:stringa di caratteri di lunghezza n;
		\item \lstinline|VARCHAR|: stringhe di caratteri di lunghezza variabile;
		\item \lstinline|TEXT|: testo libero (solo Postgres).
	\end{itemize}

	\subsubsection{Domini di bit/booleani}
	\begin{itemize}
		\item \lstinline|BIT|: singoli bit;
		\item \lstinline|VARBIT(n)|: stringa di bit di lunghezza fissa;
		\item \lstinline|VARBIT|: stringa di bit di lunghezza arbitraria.
		\item \lstinline|BOOLEAN|: valori booleani, possono essere solo singoli.
	\end{itemize}
	\textbf{Nota:} non sono ammesse stringhe di booleani.
	
	\subsubsection{Domini di tempo}
	\begin{itemize}
		\item \lstinline|DATE|: date rappresentate tra apici e nel formato \verb|YYYY-MM-DD|;
		\item \lstinline|TIME(precisione)|: misure di tempo nel formato \verb|hh:mm:ss:[precisione]|;
		\item \lstinline|INTERVAL|: intervalli di tempo.
		\item \lstinline|TIME/TIMESTAMP WITH TIME ZONE|: con tutti i dati per il tempo, con indicazioni sul fuso.
	\end{itemize}
	
	\subsection{Comando CREATE DOMAIN}
	Questo comando è usato per creare un dominio utente \textbf{invariabile nel tempo}.
	\begin{lstlisting}
CREATE DOMAIN nome AS tipoBase [default]
	[vincolo]
	\end{lstlisting}
	I valori di default e i vincoli sono opzionali.
	
	\textbf{Esempio:}
	\begin{lstlisting}
CREATE DOMAIN giorniSettimana AS CHAR(3)
	CHECK ( VALUE IN ('LUN', 'MAR', 'MER', 'GIO', 'VEN', 
	'SAB', 'DOM'));
	\end{lstlisting}

	\subsection{Vincoli di attributo e di tabella}
	Vincoli di attributo/intrarelazionali specificano proprietà che devono
	essere soddisfatte da ogni tupla di una singola relazione della base di
	dati.
	
	\begin{lstlisting}
[ CONSTRAINT vincolo ]
{ NOT NULL |
  CHECK ( espressione ) [ NO INHERIT ] |
  DEFAULT valore |
  UNIQUE |
  PRIMARY KEY |
  REFERENCES tabella [ ( attributo ) ]
    [ ON DELETE azione ] [ ON UPDATE azione ] }
	\end{lstlisting}
	
	Vincoli di tabella:
	\begin{lstlisting}
[ CONSTRAINT vincolo ]
{ CHECK ( espressione ) [ NO INHERIT ] |
  UNIQUE ( attributo [, ... ]) |
  PRIMARY KEY ( attributo [, ... ]) |
  FOREIGN KEY ( attributo [, ... ])
  REFERENCES reftable [ ( refcolumn [ , ... ]) ]
	[ ON DELETE azione ] [ ON UPDATE azione ] }
	\end{lstlisting}

	\begin{itemize}
		\item \lstinline|NOT NULL|: determina che il valore nullo non è ammesso come
		valore dell’attributo.
		\item \lstinline|DEFAULT valore|: specifica un valore di
		default per un attributo quando un comando di inserimento dati non
		specifica nessun valore per l’attributo.
		
	\textbf{Esempio:}
	\begin{lstlisting}
nome VARCHAR (20) NOT NULL,
cognome VARCHAR (20) NOT NULL DEFAULT ''
	\end{lstlisting}
		\item \lstinline|UNIQUE|: impone che i valori di un attributo (o di un insieme di
		attributi) siano una \textbf{superchiave}.
		\item \lstinline|PRIMARY KEY|: identifica l’attributo che rappresenta la chiave
		primaria della relazione:
		\begin{itemize}
			\item Si usa una sola volta per tabella.
			\item Implica il vincolo \lstinline|NOT NULL|.
		\end{itemize}
	
	\textbf{Esempio: }
	\begin{lstlisting}
matricola CHAR(6) PRIMARY KEY;
	\end{lstlisting}
	oppure su più attributi
	\begin{lstlisting}
nome VARCHAR(20),
cognome VARCHAR(20),
PRIMARY KEY(nome, cognome)
	\end{lstlisting}
	
	\item \lstinline|CHECK (vincolo)|: specifica un vincolo generico che devono soddisfare le
	tuple della tabella.
	\end{itemize}
	
	\subsubsection{Vincoli di integrità referenziale}
		Un vincolo di integrità referenziale si dichiara nella tabella interna e ha
		due possibili sintassi.
		\begin{itemize}
			\item \lstinline|REFERENCES|: \textbf{vincolo di attributo}, da usare quando il vincolo è su un
			singolo attributo della tabella interna, $ |A| = 1 $.
			\item \lstinline|FOREIGN KEY|: \textbf{vincolo di tabella} , da usare quando il vincolo coinvolge più attributi della tabella interna, $ |A| > 1 $.
		\end{itemize}
		\textbf{Esempio:}
		\begin{lstlisting}
CREATE TABLE Interna
...
attributo VARCHAR(15) REFERENCES TabellaEsterna (chiave)
...

...
piano VARCHAR (10),
stanza INTEGER,
FOREIGN KEY (piano, stanza) REFERENCES Ufficio (piano, nStanza)
		\end{lstlisting}
		
	\subsection{Comando ALTER TABLE}
		La struttura di una tabella si può modificare dopo la sua creazione con il
		comando \lstinline|ALTER TABLE|.
		\begin{itemize}
			\item Aggiunta di un nuovo attributo con \lstinline|ADD COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato ADD COLUMN stipendio NUMERIC(8,2);
			\end{lstlisting}
			\item Rimozione di un attributo con \lstinline|DROP COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato DROP COLUMN stipendio;
			\end{lstlisting}
			\item Modifica di un valore di default di un attributo con \lstinline|ALTER COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato ALTER COLUMN stipendio
	SET DEFAULT 1000.00;
			\end{lstlisting}			
		\end{itemize}
		
	\subsection{Comando INSERT INTO}
		Una tabella viene popolata con il comando \lstinline|INSERT INTO|:
		\begin{lstlisting}
INSERT INTO impiegato (matricola, nome, cognome)
	VALUES ('A00001', 'Mario', 'Rossi'),
	       ('A00002', 'Luca', 'Bianchi');
		\end{lstlisting}
	
	\subsection{Comando UPDATE}
		Una tupla di una tabella può essere modificata con il comando \lstinline|UPDATE|:
		\begin{lstlisting}
UPDATE tabella
	SET attributo = espressione [, ... ]
	[ WHERE condizione ];
		\end{lstlisting}
	\lstinline|condizione| è una espressione booleana che seleziona quali righe
	aggiornare. Se \lstinline|WHERE| non è presente, tutte le tuple saranno aggiornate.
	
	\textbf{Esempio: }
	\begin{lstlisting}
UPDATE impiegato
	SET stipendio = stipendio * 1.10
	WHERE nomeDipartimento = 'Vendite';
UPDATE impiegato
	SET telefono = '+39' || telefono;
	\end{lstlisting}
	\textbf{Nota:} L’operatore '||' concatena due espressioni e ritorna la stringa corrisp.
	
	\subsection{Comando DELETE}
		Le tuple di una tabella vengono cancellate con il comando \lstinline|DELETE|:
		\begin{lstlisting}
DELETE FROM impiegato WHERE matricola = 'A001';
		\end{lstlisting}
		Una tabella viene cancellata con il comando \lstinline|DROP TABLE|.
		
	\subsection{Politiche di reazione}
		In SQL si possono attivare diverse politiche di adeguamento della tabella
		interna
		\begin{lstlisting}
FOREIGN KEY ( column_name [ , ... ]) REFERENCES
	reftable [ ( refcolumn [ , ... ]) ]
   ON DELETE reazione ON UPDATE reazione
		\end{lstlisting}
		\begin{itemize}
			\item \lstinline|CASCADE|: la modifica del valore di un attributo riferito nella tabella master
			si propaga anche in tutte le righe corrispondenti nelle tabelle slave.

			\item \lstinline|SET NULL|: la modifica del valore di un attributo riferito nella tabella
			master determina che in tutte le righe corrispondenti nelle tabelle slave
			il valore dell’attributo referente è posto a \lstinline|NULL| (se ammesso).

			\item \lstinline|SET DEFAULT|: la modifica del valore di un attributo riferito nella tabella
			master determina che in tutte le righe corrispondenti nelle tabelle slave
			il valore dell’attributo referente è posto al valore di default (se esiste).

			\item \lstinline|NO ACTION|: indica che non si fa nessuna azione. Il vincolo però deve
			essere sempre valido. Quindi, la modifica del valore di un attributo
			riferito nella tabella master non viene effettuata.
		\end{itemize}
	\subsection{Query sul database}
		In SQL, esiste solo un comando per interrogare un base di dati: \lstinline|SELECT|.
		\begin{lstlisting}
SELECT [ DISTINCT ]
[ * | expression [[ AS ] output_name ] [ , ...] ]
[ FROM from_item [ , ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [ , ...] ]
[ HAVING condition [ , ...] ]
[ { UNION | INTERSECT | EXCEPT } [ DISTINCT ]
	other_select ]
[ ORDER BY expression [ ASC | DESC | USING operator ]]
...
		\end{lstlisting}
		dove
		\begin{itemize}
			\item \lstinline|*| è un’abbreviazione per indicare tutti gli attributi delle tabelle.
			\item \lstinline|expression| è un’espressione che determina un attributo.
			\item \lstinline|output_name| è il nome assegnato all’attributo che conterrà il risultato
			della valutazione dell’espressione \lstinline|expression| nella relazione risultato.
			\item \lstinline|from_item| è un’espressione che determina una sorgente per gli attributi.
			\item \lstinline|condition| è un’espressione booleana per selezionare i valori degli
			attributi.
			\item \lstinline|grouping_element| è un’espressione per poter eseguire operazioni su
			più valori di un attributo e considerare il risultato.
			\item \lstinline|DISTINCT| : se presente richiede l’eliminazione delle tuple duplicate.
		\end{itemize}
		
	\subsubsection{Operatore LIKE e SIMILAR TO}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|LIKE| per il confronto di
		stringhe. \lstinline|LIKE| è un operatore di pattern matching. I pattern si costruiscono
		con i caratteri speciali \lstinline|_| (1 carattere qualsiasi) e \lstinline|%| (0 o più caratteri qualsiasi):
		\begin{lstlisting}
WHERE attributo [ NOT ] LIKE 'pattern';
		\end{lstlisting}
		L’operatore \lstinline|SIMILAR TO| è un \lstinline|LIKE| più espressivo che accetta
		espressioni regolari (versione SQL) come pattern. Esempi di componenti di
		espressioni regolari:
		\begin{itemize}
			\item \lstinline|_| = 1 carattere qualsiasi. \lstinline|%| = 0 o più caratteri qualsiasi.
			\item \lstinline|*| = ripetizione del precedente match 0 o più volte. 
				\lstinline|+| = ripetizione del precedente match UNA o più volte.
			\item \lstinline|{n,m}| = ripetizione del precedente match almeno n e non più di m volte.
			\item \lstinline|[...]| = ... è un elenco di caratteri ammissibili
		\end{itemize}
		\textbf{Esempio:} Studenti con cognome che inizia con 'A' o 'B', o 'D', o 'N' e finisce con 'a':
		\begin{lstlisting}
SELECT cognome, nome, città FROM Studente
WHERE cognome SIMILAR TO '[ABDN]{1}%a';
		\end{lstlisting}
		
	\subsubsection{Operatore BETWEEN}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] BETWEEN| per testare
		l’appartenenza di un valore ad un intervallo.
		
		\noindent
		\textbf{Esempio:} Tutti gli studenti che hanno matricola tra 'IN0002' e 'IN0004'.
	\begin{lstlisting}
SELECT cognome, nome, matricola FROM Studente
WHERE matricola BETWEEN 'IN0002' AND 'IN0004';
	\end{lstlisting}
	
	\subsubsection{Operatore IN}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] IN| per testare
		l’appartenenza di un valore ad un insieme.
	
		\noindent
		\textbf{Esempio: }Tutti gli studenti che hanno matricola nell’elenco 'IN0001', 'IN0003' e
		'IN0005'.
		\begin{lstlisting}
SELECT cognome, nome, matricola FROM Studente
WHERE matricola IN ('IN0001', 'IN0003', 'IN0005');
		\end{lstlisting}
	
	\subsubsection{Operatore IS NULL}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] IS NULL| per testare
		se un valore è NOT KNOWN (==NULL) o no.
	
		\noindent
		\textbf{Esempio: }Tutti gli studenti che NON hanno una città.
\begin{lstlisting}
SELECT cognome, nome, città FROM Studente
WHERE città IS NULL;
\end{lstlisting}
	\textbf{Nota: }In SQL, \lstinline|NULL| non è uguale a \lstinline|NULL|.
	NON SI PUÒ usare \lstinline|'='| o \lstinline|'<>'| con il valore NULL!
	
	\subsubsection{Operatore ORDER BY}
		La clausola \lstinline|ORDER BY| ordina le tuple del risultato in ordine rispetto agli
		attributi specificati.
		
		\noindent
		\textbf{Esempio: }Tutti gli studenti in ordine decrescente rispetto al cognome e crescente
		(lessicografico) rispetto al nome.
		\begin{lstlisting}
SELECT cognome, nome
FROM Studente
ORDER BY cognome DESC, nome;
		\end{lstlisting}
		
	\subsubsection{Operatori di aggregazione}
		Sono operatori che permettono di determinare \textbf{un} valore considerando i
		valori ottenuti da una \lstinline|SELECT|.
		Due tipi principali:
		\begin{itemize}
			\item \lstinline|COUNT|
			\item \lstinline|MAX|, \lstinline|MIN|, \lstinline|AVG|, \lstinline|SUM|
		\end{itemize}
		Quando si usano gli operatori aggregati, dopo la \lstinline|SELECT| \textit{non} possono
		comparire espressioni che usano i valori presenti nelle singole tuple
		perché il risultato è sempre e solo una tupla.
		\\
		\lstinline|COUNT| restituisce il numero di tuple significative nel risultato dell’interrogazione:
		\begin{lstlisting}
COUNT ({ * | expr | ALL expr | DISTINCT expr }])
		\end{lstlisting}
		dove \lstinline|expr| è un’espressione che usa attributi e funzioni di attributi ma non
		operatori di aggregazione.\\
		Tre casi comuni:
		\begin{itemize}
			\item \lstinline|COUNT(*)| ritorna il numero di tuple nel risultato dell’interrogazione.
			\item \lstinline|COUNT(expr)| ritorna il numero di tuple in ciascuna delle quali il valore
			expr è non nullo.
			\item \lstinline|COUNT(ALL expr)| è un alias a \lstinline|COUNT(expr)| .
			\item \lstinline|COUNT(DISTINCT expr)| come con \lstinline|COUNT(expr)| ma con l’ulteriore
			condizione che i valori di \lstinline|expr| sono distinti.
		\end{itemize}
		\lstinline|MAX|, \lstinline|MIN|, \lstinline|AVG|, \lstinline|SUM| determinano un valore numerico (\lstinline|SUM|/\lstinline|AVG|) o alfanumerico (\lstinline|MAX|/\lstinline|MIN|)
		considerando le tuple significative nel risultato dell’interrogazione.
		
		\noindent
		\textbf{Esempi: }\\
		Calcola la media delle medie degli studenti.
		\begin{lstlisting}
SELECT AVG(media)::DECIMAL (5,2)
FROM Studente;
		\end{lstlisting}
		Calcola la media delle medie distinte degli studenti.
		\begin{lstlisting}
SELECT AVG(DISTINCT media)::DECIMAL(5,2)
FROM Studente;
		\end{lstlisting}
		
	\subsubsection{Interrogazioni con raggruppamento}
		Un raggruppamento è un insieme di tuple che hanno medesimi valori su
		uno o più attributi caratteristici del raggruppamento.
		
		\noindent
		La clausola \lstinline|GROUP BY attr [, ...]| permette di determinare tutti i
		raggruppamenti delle tuple della relazione risultato (tuple selezionate
		con la clausola \lstinline|WHERE| ) in funzione degli attributi dati.
		In una interrogazione che fa uso di \lstinline|GROUP BY| , possono comparire come
		argomento della \lstinline|SELECT| solamente gli attributi utilizzati per il
		raggruppamento e funzioni aggregate valutate sugli altri attributi.
		
		\noindent
		\textbf{Esempi: }\\		
		Visualizzare tutte le città raggruppate della tabella Studente.
		\begin{lstlisting}
SELECT città
FROM Studente
GROUP BY città;
		\end{lstlisting}
		Visualizzare tutte le città e i cognomi raggruppati.
		\begin{lstlisting}[mathescape]
SELECT cognome, LOWER(città)
FROM Studente
GROUP BY cognome, LOWER(città);
		\end{lstlisting}
		\textbf{Nota1: }NON SI POSSONO SPECIFICARE attributi che non sono raggruppati dopo il
		\lstinline|SELECT|.
		
		\lstset{moredelim=[is][\sout]{|}{|}}
		\begin{lstlisting}
SELECT |cognome|, città
FROM Studente
GROUP BY città;
		\end{lstlisting}
		
		\noindent
		\textbf{Nota2: }Si possono specificare espressioni con operatori di aggregazione su attributi
		non raggruppati.
		\begin{lstlisting}
SELECT LOWER(città) AS città,
  CAST(AVG(media) AS DECIMAL(5,2)) AS media
FROM Studente
GROUP BY LOWER(città);
		\end{lstlisting}
		
		\begin{itemize}
			\item La clausola \lstinline|WHERE| permette di selezionare le righe che devono far parte
			del risultato.
			\item La clausola \lstinline|HAVING| permette di selezionare i raggruppamenti che
			devono far parte del risultato.
			\item La sintassi è \lstinline|HAVING bool_expr| , dove \lstinline|bool_expr| è un'espressione
			booleana che può usare gli attributi usati nel \lstinline|GROUP BY| e/o gli altri
			attributi mediante operatori di aggregazione.
		\end{itemize}
		\textbf{Esempi: }\\
		Visualizzare tutte le città raggruppate che iniziano con ’V’ della tabella
		Studente.
		\begin{lstlisting}
SELECT città
FROM Studente
GROUP BY città
HAVING città LIKE 'V%';
		\end{lstlisting}
		Visualizzare tutte le città e i cognomi raggruppati con almeno due studenti
		con lo stesso cognome.
		\begin{lstlisting}
SELECT cognome, LOWER(città)
FROM Studente
GROUP BY cognome, LOWER(città)
HAVING COUNT(cognome)>1;
		\end{lstlisting}
		
		\subsubsection{Comando JOIN}
			Si è visto che se sono presenti due o più nomi di tabelle, si esegue il
			prodotto cartesiano tra tutte le tabelle e lo schema del risultato può
			contenere tutti gli attributi del prodotto cartesiano.
			Il prodotto cartesiano di due o più tabelle è un \lstinline|CROSS JOIN| .
			A partire da SQL-2, esistono altri tipi di \lstinline|JOIN| (\lstinline|join_type|):
			\lstinline|INNER JOIN|, \lstinline|LEFT OUTER JOIN| , \lstinline|RIGHT OUTER JOIN| e \lstinline|FULL OUTER JOIN|.
			
			\begin{lstlisting}
table_name [ NATURAL ] join_type table_name 
  [ ON join_condition [ , ...]]
			\end{lstlisting}
			dove \lstinline|join_condition| è un’espressione booleana che seleziona le tuple del join
			da aggiungere al risultato. Le tuple selezionate possono essere poi filtrate
			con la condizione della clausola \lstinline|WHERE|.
		
	\section{Livelli di isolamento}
		In SQL esistono 4 livelli di isolamento per transazioni concorrenti:
		\begin{itemize}
			\item Read Committed
			\item Repeatable Read
			\item Serializable
			\item Read Uncommitted
		\end{itemize}
		Prendiamo come esempio la seguente tabella:
		\lstinline|Web|:
		\begin{tabular}{cc}
			\toprule
			\lstinline|id| & \lstinline|hits| \\
			\midrule
			1 & 9 \\
			2 & 10 \\
			\midrule
		\end{tabular}
		
		\subsection{Read Committed}
			È il \textbf{livello di default}, basta scrivere \lstinline|BEGIN;|
			\begin{itemize}
				\item \lstinline|SELECT| vede solo i dati registrati (\lstinline|COMMITTED|) in altre transazioni e quelli modificati da comandi precedenti nella stessa transazione.
				\item \lstinline|UPDATE| e \lstinline|DELETE| vedono i dati come \lstinline|SELECT|
				\item Se i dati da aggiornare sono stati modificati ma \textbf{non registrati} in transazioni concorrenti, il comando deve:
				\begin{itemize}
					\item Attendere il \lstinline|COMMIT| o \lstinline|ROLLBACK| della transazione concorrente.
					\item Riesaminare le righe per verificare che soddisfano ancora i criteri del comando.
				\end{itemize}
			\end{itemize}
			\textbf{Esempio: Non-repeatable reads}
			\begin{multicols}{2}
				\noindent
				$ T_1 $:
				\begin{lstlisting}
BEGIN;
UPDATE Web SET hits=hits+1;

COMMIT;
				\end{lstlisting}
				\columnbreak
				$ T_2 $:
				\begin{lstlisting}
BEGIN;

DELETE FROM Web WHERE hits=10;

				\end{lstlisting}
			\end{multicols}
			\lstinline|DELETE| non riesce a cancellare: la riga è quella con \lstinline|id = 2|, che viene aggiornata da \lstinline|UPDATE| il quale sblocca \lstinline|DELETE| fino al \lstinline|COMMIT|. \lstinline|DELETE| riesamina la riga e trova che il criterio non è più soddisfatto.
			
		\subsection{Repeatable Read}
			Differisce da Read Committed per il fatto che i comando di una transazione \textbf{vedono sempre gli stessi dati}. Due \lstinline|SELECT| identiche vedono sempre gli stessi dati.
			\begin{itemize}
				\item \lstinline|UPDATE| e \lstinline|DELETE| vedono i dati come \lstinline|SELECT|.
				\item Se i dati da aggiornare sono stati modificati ma \textbf{non registrati} in transazioni concorrenti, il comando deve attendere: 
				\begin{itemize}
					\item il \lstinline|COMMIT| e quindi i dati vengono cambiati e \lstinline|UPDATE| e \lstinline|DELETE| vengono bloccate con errore.
					\item il \lstinline|ROLLBACK| e quidni \lstinline|UPDATE| e \lstinline|DELETE| possono procedere.
				\end{itemize}
			\end{itemize}
			\textbf{Esempio1: Cattura l'anomalia Non-repeatable reads}
			\begin{multicols}{2}
			\noindent
			$ T_1 $:
			\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  REPEATABLE READ;

UPDATE Web SET hits=hits+1;

COMMIT;
			\end{lstlisting}
			\columnbreak
			$ T_2 $:
			\begin{lstlisting}
BEGIN;

DELETE FROM Web WHERE hits=10;

ERROR: could NOT serialize 
access due to concurrent UPDATE.
			\end{lstlisting}
			\end{multicols}
			\noindent
			\textbf{Esempio2: Phantom Reads}
			\begin{multicols}{2}
			\noindent
			$ T_1 $:
			\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  REPEATABLE READ;
 
INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;
  
COMMIT;
			\end{lstlisting}
			\columnbreak
			$ T_2 $:
			\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  REPEATABLE READ;

INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;

COMMIT;
			\end{lstlisting}
			\end{multicols}
		La tabella finale contiene due valori 11 e non 11 e 12 (inserimento fantasma).
		
	\subsection{Serializable}
		È \textbf{il più restrittivo} e garantisce che le transazioni siano eseguite \textbf{come se fossero sequenziali tra loro} (in un ordine non prestabilito). Si deve però prevedere la possibilità di transazioni abortite più frequenti per gli aggiornamenti concorrenti tipo Repeatable Read.\\
		\textbf{Esempio:}
		\begin{multicols}{2}
		\noindent
		$ T_1 $:
		\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  SERIALIZABLE;
  
INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;

COMMIT;
		\end{lstlisting}
		\columnbreak
		$ T_2 $:
		\begin{lstlisting}
BEGIN TRANSACTION ISOLATION LEVEL
  SERIALIZABLE;

INSERT INTO Web SELECT
  MAX(hits)+1 FROM Web;

COMMIT;
		\end{lstlisting}
		\end{multicols}
		
		\newpage
		
		La $ T_2 $ riporta il seguente errore:
		\begin{lstlisting}
ERROR: could not serialize access due to READ/WRITE dependencies 
       among transactions
DETAIL: reason code: canceled ON identification AS a pivot, 
        during COMMIT attempt
HINT: the TRANSACTION might succeed if retried.
		\end{lstlisting}
	\newpage		
			
			
		
	\section{Flask}
	\lstset{language=Python}
		\subsection{HTTP requests:}
			\begin{itemize}
				\item \lstinline|GET|: serve ad un client per \textbf{recuperare} una risorsa dal server (come la richiesta di una pagin web). Eventuali parametri da inviare al server sono specificati nella \textbf{query string} dell'URL.
				\item \lstinline|POST|: serve ad un client per \textbf{inviare} informazioni al server. La maggior parte dei browser usa post per \textbf{inviare dati delle form ai server}. I dati sono specificati nel corpo della richiesta.
			\end{itemize}
		\subsection{Accesso ai parametri della query string di una richiesta GET}
		\textbf{Query String} rappresentata dalla variabile \lstinline|request.args| di tipo \lstinline|dict|, accessibile direttamente dal metodo associato all'URL:
		\begin{lstlisting}[frame=tb]
from flask import Flask, request
app = Flask(__name__)

@app.route('/login')
def login():
	user = request.args['user']
	role = request.args['role']
	return ...
		\end{lstlisting}
		\subsection{Accesso ai parametri della query string di una richiesta POST}
		\lstset{language=HTML}
		\begin{lstlisting}[frame=tb, caption={esempio di form html5}]
<form action="http://localhost:5000/login" method="post">
	<label> Name: <input type="text" name="user"/> </label><br>
	<label> Role: <input type="text" name="role"/> </label><br>
	<input type="submit" value="Invia">
</form>
		\end{lstlisting}
		\lstset{language=Python}
		I dati di un \lstinline|POST| sono nel dict \lstinline|request.form|
		\begin{lstlisting}[frame=tb]
@app.route('/login')
def login():
	user = request.form['user']
	role = request.form['role']
	return ...
		\end{lstlisting}
		
		\newpage
		
		\subsection{Esempio esercizio d'esame con integrazione HTML}
			Assumendo di avere una base di dati PostgreSQL che contenga le tabelle di questo tema d'esame, scrivere:
			\begin{enumerate}[label=(\alph*)]
				\item Un template JINJA2 per una form HTML 5 che: (1) permetta di acquisire un codice fiscale (controllando il formato), (2) di selezionare una biblioteca dalla lista \lstinline|biblioteche| passata come parametro al template e (3) invii i dati all'URL \lstinline|/prestitiUtente| in modalità GET. Il formato di \lstinline|biblioteche| è \lstinline|[{id, nome}, ...]|.\\
				Scrivere solo la parte della FORM, non tutto il documento HTML. 
				
				\item Un metodo Python che, associato all'URL \lstinline|/prestitiUtente| secondo il framework Flask, (1) legga i parametri codice fiscale e identificatore biblioteca, (2) si connetta alla base di dati 'X' (si assuma di dover specificare solo il nome della base di dati) e recuperi tutti i prestiti (idRisorsa, dataInizio, durata) associati al codice fiscale e biblioteca dati come parametri (scrivere la query!), (3) usi il metodo \lstinline|render_template('view.html', ...)| per pubblicare il risultato passando la lista del risultato. Se il  risultato dell'interrogazione è vuoto, il metodo deve passare il controllo a \lstinline|render_template('nessunPrestito0Errore.html')|.\\
				Scrivere solo il metodo.
			\end{enumerate}
			Soluzione (a):
			\lstset{language=HTML}
			\begin{lstlisting}[frame=tb, tabsize=2]
<form action="/prestitiUtente" method="get">
	<label for="codicef">Codice fiscale: </label>
		<input id="codicef" name="cf" type="text" pattern="[A-Z]...">
	<br>
	<label for="biblioteca">Biblioteca: </label>
		<select id="biblioteca" name="biblio">
			{% for b in biblioteche %}
			<option value="{{b.id}}"> {{b.nome}} </option>
			{% endfor %}
		</select>
	<input type="submit" value="Invia">
</form>
			\end{lstlisting}
			Soluzione (b):
			\lstset{language=Python}
			\begin{lstlisting}[frame=tb, tabsize=2]
@app.route('/prestitiUtente', methods= ['GET'])
def getPrestiti():
	cf = request.args['cf']
	biblio = request.args['biblio']
	
	with psycopg2.connect(database='X') as conn:
		with conn.cursor as cur:
			cur.execute("SELECT P.idRisorsa, P.dataInizio, P.durata\
				FROM Prestito P WHERE P.idUtente = %s AND\
				P.idBiblioteca = %s", cf, int(biblio))
			prestiti = cur.fetchall()
			
			if not prestiti:
				return render_template('nessunPrestito0Errore.html')
				
			return render_template('view.html', prestiti, cf, biblio)
			\end{lstlisting}
			
\newpage
\section{JDBC}
JDBC è una libreria di funzioni Java che consente di collegarsi ad un database ed eseguire operazioni.
Le fasi principali per eseguire una qualsiasi operazione sono:

\begin{enumerate}
	\item Caricare il driver \textit{org.postgresql.Driver};
	
	\item Collegarsi al database sul quale si intende operare;
	
	\item Creare gli statement da eseguire;
	
	\item Eseguire gli statement e il commit;
	
	\item Chiudere le risorse utilizzate.
\end{enumerate}

			
\end{document}