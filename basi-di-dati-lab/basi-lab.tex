\documentclass[a4paper, 10pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[makeroom]{cancel}
\usepackage{ulem}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{frontespizio}
\usepackage{hyperref}
\hypersetup{hidelinks,
	colorlinks = true,
	urlcolor = black, 
	linkcolor = black}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{listings}
\lstset{inputencoding=utf8,
	language = SQL,
	basicstyle=\ttfamily,
	showstringspaces=false,
	keywordstyle=\color{blue}\bfseries,
	morekeywords={REFERENCES, BOOLEAN, REAL, DOUBLE, PRECISION, TEXT, VARBIT, SIMILAR, TO},
	stringstyle=\color{Purple},
	literate={à}{{\`a}}1
}
\usepackage{fancyvrb}
\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}

\begin{document}
	\begin{frontespizio}
		\Preambolo{\usepackage{datetime}}
		\Istituzione{Università degli Studi di Verona}
		\Divisione{Dipartimento di informatica}
		\Facolta{Scienze e Ingegneria}
		\Scuola{Laurea in Informatica}
		\Titolo{Basi di Dati}
		\Sottotitolo{Programma di laboratorio}
		\Candidato{Davide Bianchi}
		\Candidato{Matteo Danzi}
		\NCandidato{Autori}
		\Annoaccademico{2016/2017}
	\end{frontespizio}

	\tableofcontents
		
	\newpage
	
	\section{Gestione base di dati con Postgresql}
	Di seguito si trova una panoramica dei comandi Postgres più comuni per la gestione di una base di dati.
	
	\subsection{Comando CREATE TABLE}
	Il comando \lstinline{CREATE TABLE} è usato per creare tabelle nella base di dati.
	La sintassi generale è:
	\begin{lstlisting}
CREATE TABLE nomeTabella (
	nomeAttributo dominioAttributo vincoli,
	...
);
	\end{lstlisting}
	dove \lstinline|nomeAttributo| è il nome dell'attributo nella tabella, \lstinline|dominioAttributo| è il dominio dell'attributo da aggiungere alla tabella.
	
	\subsubsection{Domini elementari}
	I domini di default disponibili in Postgres sono:
	\begin{itemize}
		\item \lstinline|BOOLEAN|: valori booleani (true/false);
		\item \lstinline|INTEGER|: valori interi a 4 byte;
		\item \lstinline|SMALLINT|: valori interi a 2 bit;
		\item \lstinline|NUMERIC(p, s)|: valori decimali approssimati, dove \lstinline|p| è la precisione del numero (cifre a sinistra e a destra della virgola) e \lstinline|s| la scala (numero di cifre decimali dopo la virgola);
		\item \lstinline|DECIMAL(p, s)|: valori deciamli approssimati, con i parametri uguali a \lstinline|NUMERIC|.
		\item \lstinline|REAL|: valori in virgola mobile a 6 cifre decimali;
		\item \lstinline|DOUBLE PRECISION|: valori in virgola mobile approssimati a 15 cifre decimali;
	\end{itemize}
	\textbf{Nota:} Se si devono rappresentare importi di denaro che contengono anche
	decimali, \textbf{MAI} usare \lstinline|REAL| o \lstinline|DOUBLE PRECISION| ma usare \lstinline|NUMERIC|!

	\subsubsection{Domini di caratteri}
	\begin{itemize}
		\item \lstinline|CHARACTER|: singoli caratteri;
		\item \lstinline|CHARACTER(n)|:stringa di caratteri di lunghezza n;
		\item \lstinline|VARCHAR|: stringhe di caratteri di lunghezza variabile;
		\item \lstinline|TEXT|: testo libero (solo Postgres).
	\end{itemize}

	\subsubsection{Domini di bit/booleani}
	\begin{itemize}
		\item \lstinline|BIT|: singoli bit;
		\item \lstinline|VARBIT(n)|: stringa di bit di lunghezza fissa;
		\item \lstinline|VARBIT|: stringa di bit di lunghezza arbitraria.
		\item \lstinline|BOOLEAN|: valori booleani, possono essere solo singoli.
	\end{itemize}
	\textbf{Nota:} non sono ammesse stringhe di booleani.
	
	\subsubsection{Domini di tempo}
	\begin{itemize}
		\item \lstinline|DATE|: date rappresentate tra apici e nel formato \verb|YYYY-MM-DD|;
		\item \lstinline|TIME(precisione)|: misure di tempo nel formato \verb|hh:mm:ss:[precisione]|;
		\item \lstinline|INTERVAL|: intervalli di tempo.
		\item \lstinline|TIME/TIMESTAMP WITH TIME ZONE|: con tutti i dati per il tempo, con indicazioni sul fuso.
	\end{itemize}
	
	\subsection{Comando CREATE DOMAIN}
	Questo comando è usato per creare un dominio utente \textbf{invariabile nel tempo}.
	\begin{lstlisting}
CREATE DOMAIN nome AS tipoBase [default]
	[vincolo]
	\end{lstlisting}
	I valori di default e i vincoli sono opzionali.
	
	\textbf{Esempio:}
	\begin{lstlisting}
CREATE DOMAIN giorniSettimana AS CHAR(3)
	CHECK ( VALUE IN ('LUN', 'MAR', 'MER', 'GIO', 'VEN', 
	'SAB', 'DOM'));
	\end{lstlisting}

	\subsection{Vincoli di attributo e di tabella}
	Vincoli di attributo/intrarelazionali specificano proprietà che devono
	essere soddisfatte da ogni tupla di una singola relazione della base di
	dati.
	
	\begin{lstlisting}
[ CONSTRAINT vincolo ]
{ NOT NULL |
  CHECK ( espressione ) [ NO INHERIT ] |
  DEFAULT valore |
  UNIQUE |
  PRIMARY KEY |
  REFERENCES tabella [ ( attributo ) ]
    [ ON DELETE azione ] [ ON UPDATE azione ] }
	\end{lstlisting}
	
	Vincoli di tabella:
	\begin{lstlisting}
[ CONSTRAINT vincolo ]
{ CHECK ( espressione ) [ NO INHERIT ] |
  UNIQUE ( attributo [, ... ]) |
  PRIMARY KEY ( attributo [, ... ]) |
  FOREIGN KEY ( attributo [, ... ])
  REFERENCES reftable [ ( refcolumn [ , ... ]) ]
	[ ON DELETE azione ] [ ON UPDATE azione ] }
	\end{lstlisting}

	\begin{itemize}
		\item \lstinline|NOT NULL|: determina che il valore nullo non è ammesso come
		valore dell’attributo.
		\item \lstinline|DEFAULT valore|: specifica un valore di
		default per un attributo quando un comando di inserimento dati non
		specifica nessun valore per l’attributo.
		
	\textbf{Esempio:}
	\begin{lstlisting}
nome VARCHAR (20) NOT NULL,
cognome VARCHAR (20) NOT NULL DEFAULT ''
	\end{lstlisting}
		\item \lstinline|UNIQUE|: impone che i valori di un attributo (o di un insieme di
		attributi) siano una \textbf{superchiave}.
		\item \lstinline|PRIMARY KEY|: identifica l’attributo che rappresenta la chiave
		primaria della relazione:
		\begin{itemize}
			\item Si usa una sola volta per tabella.
			\item Implica il vincolo \lstinline|NOT NULL|.
		\end{itemize}
	
	\textbf{Esempio: }
	\begin{lstlisting}
matricola CHAR(6) PRIMARY KEY;
	\end{lstlisting}
	oppure su più attributi
	\begin{lstlisting}
nome VARCHAR(20),
cognome VARCHAR(20),
PRIMARY KEY(nome, cognome)
	\end{lstlisting}
	
	\item \lstinline|CHECK (vincolo)|: specifica un vincolo generico che devono soddisfare le
	tuple della tabella.
	\end{itemize}
	
	\subsubsection{Vincoli di integrità referenziale}
		Un vincolo di integrità referenziale si dichiara nella tabella interna e ha
		due possibili sintassi.
		\begin{itemize}
			\item \lstinline|REFERENCES|: \textbf{vincolo di attributo}, da usare quando il vincolo è su un
			singolo attributo della tabella interna, $ |A| = 1 $.
			\item \lstinline|FOREIGN KEY|: \textbf{vincolo di tabella} , da usare quando il vincolo coinvolge più attributi della tabella interna, $ |A| > 1 $.
		\end{itemize}
		\textbf{Esempio:}
		\begin{lstlisting}
CREATE TABLE Interna
...
attributo VARCHAR(15) REFERENCES TabellaEsterna (chiave)
...

...
piano VARCHAR (10),
stanza INTEGER,
FOREIGN KEY (piano, stanza) REFERENCES Ufficio (piano, nStanza)
		\end{lstlisting}
		
	\subsection{Comando ALTER TABLE}
		La struttura di una tabella si può modificare dopo la sua creazione con il
		comando \lstinline|ALTER TABLE|.
		\begin{itemize}
			\item Aggiunta di un nuovo attributo con \lstinline|ADD COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato ADD COLUMN stipendio NUMERIC(8,2);
			\end{lstlisting}
			\item Rimozione di un attributo con \lstinline|DROP COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato DROP COLUMN stipendio;
			\end{lstlisting}
			\item Modifica di un valore di default di un attributo con \lstinline|ALTER COLUMN|:
			\begin{lstlisting}
ALTER TABLE impiegato ALTER COLUMN stipendio
	SET DEFAULT 1000.00;
			\end{lstlisting}			
		\end{itemize}
		
	\subsection{Comando INSERT INTO}
		Una tabella viene popolata con il comando \lstinline|INSERT INTO|:
		\begin{lstlisting}
INSERT INTO impiegato (matricola, nome, cognome)
	VALUES ('A00001', 'Mario', 'Rossi'),
	       ('A00002', 'Luca', 'Bianchi');
		\end{lstlisting}
	
	\subsection{Comando UPDATE}
		Una tupla di una tabella può essere modificata con il comando \lstinline|UPDATE|:
		\begin{lstlisting}
UPDATE tabella
	SET attributo = espressione [, ... ]
	[ WHERE condizione ];
		\end{lstlisting}
	\lstinline|condizione| è una espressione booleana che seleziona quali righe
	aggiornare. Se \lstinline|WHERE| non è presente, tutte le tuple saranno aggiornate.
	
	\textbf{Esempio: }
	\begin{lstlisting}
UPDATE impiegato
	SET stipendio = stipendio * 1.10
	WHERE nomeDipartimento = 'Vendite';
UPDATE impiegato
	SET telefono = '+39' || telefono;
	\end{lstlisting}
	\textbf{Nota:} L’operatore '||' concatena due espressioni e ritorna la stringa corrisp.
	
	\subsection{Comando DELETE}
		Le tuple di una tabella vengono cancellate con il comando \lstinline|DELETE|:
		\begin{lstlisting}
DELETE FROM impiegato WHERE matricola = 'A001';
		\end{lstlisting}
		Una tabella viene cancellata con il comando \lstinline|DROP TABLE|.
		
	\subsection{Politiche di reazione}
		In SQL si possono attivare diverse politiche di adeguamento della tabella
		interna
		\begin{lstlisting}
FOREIGN KEY ( column_name [ , ... ]) REFERENCES
	reftable [ ( refcolumn [ , ... ]) ]
   ON DELETE reazione ON UPDATE reazione
		\end{lstlisting}
		\begin{itemize}
			\item \lstinline|CASCADE|: la modifica del valore di un attributo riferito nella tabella master
			si propaga anche in tutte le righe corrispondenti nelle tabelle slave.

			\item \lstinline|SET NULL|: la modifica del valore di un attributo riferito nella tabella
			master determina che in tutte le righe corrispondenti nelle tabelle slave
			il valore dell’attributo referente è posto a \lstinline|NULL| (se ammesso).

			\item \lstinline|SET DEFAULT|: la modifica del valore di un attributo riferito nella tabella
			master determina che in tutte le righe corrispondenti nelle tabelle slave
			il valore dell’attributo referente è posto al valore di default (se esiste).

			\item \lstinline|NO ACTION|: indica che non si fa nessuna azione. Il vincolo però deve
			essere sempre valido. Quindi, la modifica del valore di un attributo
			riferito nella tabella master non viene effettuata.
		\end{itemize}
	\subsection{Query sul database}
		In SQL, esiste solo un comando per interrogare un base di dati: \lstinline|SELECT|.
		\begin{lstlisting}
SELECT [ DISTINCT ]
[ * | expression [[ AS ] output_name ] [ , ...] ]
[ FROM from_item [ , ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [ , ...] ]
[ HAVING condition [ , ...] ]
[ { UNION | INTERSECT | EXCEPT } [ DISTINCT ]
	other_select ]
[ ORDER BY expression [ ASC | DESC | USING operator ]]
...
		\end{lstlisting}
		dove
		\begin{itemize}
			\item \lstinline|*| è un’abbreviazione per indicare tutti gli attributi delle tabelle.
			\item \lstinline|expression| è un’espressione che determina un attributo.
			\item \lstinline|output_name| è il nome assegnato all’attributo che conterrà il risultato
			della valutazione dell’espressione \lstinline|expression| nella relazione risultato.
			\item \lstinline|from_item| è un’espressione che determina una sorgente per gli attributi.
			\item \lstinline|condition| è un’espressione booleana per selezionare i valori degli
			attributi.
			\item \lstinline|grouping_element| è un’espressione per poter eseguire operazioni su
			più valori di un attributo e considerare il risultato.
			\item \lstinline|DISTINCT| : se presente richiede l’eliminazione delle tuple duplicate.
		\end{itemize}
		
	\subsubsection{Operatore LIKE e SIMILAR TO}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|LIKE| per il confronto di
		stringhe. \lstinline|LIKE| è un operatore di pattern matching. I pattern si costruiscono
		con i caratteri speciali \lstinline|_| (1 carattere qualsiasi) e \lstinline|%| (0 o più caratteri qualsiasi):
		\begin{lstlisting}
WHERE attributo [ NOT ] LIKE 'pattern';
		\end{lstlisting}
		L’operatore \lstinline|SIMILAR TO| è un \lstinline|LIKE| più espressivo che accetta
		espressioni regolari (versione SQL) come pattern. Esempi di componenti di
		espressioni regolari:
		\begin{itemize}
			\item \lstinline|_| = 1 carattere qualsiasi. \lstinline|%| = 0 o più caratteri qualsiasi.
			\item \lstinline|*| = ripetizione del precedente match 0 o più volte. 
				\lstinline|+| = ripetizione del precedente match UNA o più volte.
			\item \lstinline|{n,m}| = ripetizione del precedente match almeno n e non più di m volte.
			\item \lstinline|[...]| = ... è un elenco di caratteri ammissibili
		\end{itemize}
		\textbf{Esempio:} Studenti con cognome che inizia con 'A' o 'B', o 'D', o 'N' e finisce con 'a':
		\begin{lstlisting}
SELECT cognome, nome, città FROM Studente
WHERE cognome SIMILAR TO '[ABDN]{1}%a';
		\end{lstlisting}
		
	\subsubsection{Operatore BETWEEN}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] BETWEEN| per testare
		l’appartenenza di un valore ad un intervallo.
		
		\noindent
		\textbf{Esempio:} Tutti gli studenti che hanno matricola tra 'IN0002' e 'IN0004'.
	\begin{lstlisting}
SELECT cognome, nome, matricola FROM Studente
WHERE matricola BETWEEN 'IN0002' AND 'IN0004';
	\end{lstlisting}
	
	\subsubsection{Operatore IN}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] IN| per testare
		l’appartenenza di un valore ad un insieme.
	
		\noindent
		\textbf{Esempio: }Tutti gli studenti che hanno matricola nell’elenco 'IN0001', 'IN0003' e
		'IN0005'.
		\begin{lstlisting}
SELECT cognome, nome, matricola FROM Studente
WHERE matricola IN ('IN0001', 'IN0003', 'IN0005');
		\end{lstlisting}
	
	\subsubsection{Operatore IS NULL}
		Nella clausola \lstinline|WHERE| può apparire l’operatore \lstinline|[ NOT ] IS NULL| per testare
		se un valore è NOT KNOWN (==NULL) o no.
	
		\noindent
		\textbf{Esempio: }Tutti gli studenti che NON hanno una città.
\begin{lstlisting}
SELECT cognome, nome, città FROM Studente
WHERE città IS NULL;
\end{lstlisting}
	\textbf{Nota: }In SQL, \lstinline|NULL| non è uguale a \lstinline|NULL|.
	NON SI PUÒ usare \lstinline|'='| o \lstinline|'<>'| con il valore NULL!
	
	\subsubsection{Operatore ORDER BY}
		La clausola \lstinline|ORDER BY| ordina le tuple del risultato in ordine rispetto agli
		attributi specificati.
		
		\noindent
		\textbf{Esempio: }Tutti gli studenti in ordine decrescente rispetto al cognome e crescente
		(lessicografico) rispetto al nome.
		\begin{lstlisting}
SELECT cognome, nome
FROM Studente
ORDER BY cognome DESC, nome;
		\end{lstlisting}
		
	\subsubsection{Operatori di aggregazione}
		Sono operatori che permettono di determinare \textbf{un} valore considerando i
		valori ottenuti da una \lstinline|SELECT|.
		Due tipi principali:
		\begin{itemize}
			\item \lstinline|COUNT|
			\item \lstinline|MAX|, \lstinline|MIN|, \lstinline|AVG|, \lstinline|SUM|
		\end{itemize}
		Quando si usano gli operatori aggregati, dopo la \lstinline|SELECT| \textit{non} possono
		comparire espressioni che usano i valori presenti nelle singole tuple
		perché il risultato è sempre e solo una tupla.
		\\
		\lstinline|COUNT| restituisce il numero di tuple significative nel risultato dell’interrogazione:
		\begin{lstlisting}
COUNT ({ * | expr | ALL expr | DISTINCT expr }])
		\end{lstlisting}
		dove \lstinline|expr| è un’espressione che usa attributi e funzioni di attributi ma non
		operatori di aggregazione.\\
		Tre casi comuni:
		\begin{itemize}
			\item \lstinline|COUNT(*)| ritorna il numero di tuple nel risultato dell’interrogazione.
			\item \lstinline|COUNT(expr)| ritorna il numero di tuple in ciascuna delle quali il valore
			expr è non nullo.
			\item \lstinline|COUNT(ALL expr)| è un alias a \lstinline|COUNT(expr)| .
			\item \lstinline|COUNT(DISTINCT expr)| come con \lstinline|COUNT(expr)| ma con l’ulteriore
			condizione che i valori di \lstinline|expr| sono distinti.
		\end{itemize}
		\lstinline|MAX|, \lstinline|MIN|, \lstinline|AVG|, \lstinline|SUM| determinano un valore numerico (\lstinline|SUM|/\lstinline|AVG|) o alfanumerico (\lstinline|MAX|/\lstinline|MIN|)
		considerando le tuple significative nel risultato dell’interrogazione.
		
		\noindent
		\textbf{Esempi: }\\
		Calcola la media delle medie degli studenti.
		\begin{lstlisting}
SELECT AVG(media)::DECIMAL (5,2)
FROM Studente;
		\end{lstlisting}
		Calcola la media delle medie distinte degli studenti.
		\begin{lstlisting}
SELECT AVG(DISTINCT media)::DECIMAL(5,2)
FROM Studente;
		\end{lstlisting}
		
	\subsubsection{Interrogazioni con raggruppamento}
		Un raggruppamento è un insieme di tuple che hanno medesimi valori su
		uno o più attributi caratteristici del raggruppamento.
		
		\noindent
		La clausola \lstinline|GROUP BY attr [, ...]| permette di determinare tutti i
		raggruppamenti delle tuple della relazione risultato (tuple selezionate
		con la clausola \lstinline|WHERE| ) in funzione degli attributi dati.
		In una interrogazione che fa uso di \lstinline|GROUP BY| , possono comparire come
		argomento della \lstinline|SELECT| solamente gli attributi utilizzati per il
		raggruppamento e funzioni aggregate valutate sugli altri attributi.
		
		\noindent
		\textbf{Esempi: }\\		
		Visualizzare tutte le città raggruppate della tabella Studente.
		\begin{lstlisting}
SELECT città
FROM Studente
GROUP BY città;
		\end{lstlisting}
		Visualizzare tutte le città e i cognomi raggruppati.
		\begin{lstlisting}[mathescape]
SELECT cognome, LOWER (città)
FROM Studente
GROUP BY cognome, LOWER (città);
		\end{lstlisting}
		\textbf{Nota1: }NON SI POSSONO SPECIFICARE attributi che non sono raggruppati dopo il
		\lstinline|SELECT|.
		
		\lstset{moredelim=[is][\sout]{|}{|}}
		\begin{lstlisting}
SELECT |cognome|, città
FROM Studente
GROUP BY città;
		\end{lstlisting}
		
		\noindent
		\textbf{Nota2: }Si possono specificare espressioni con operatori di aggregazione su attributi
		non raggruppati.
		\begin{lstlisting}
SELECT LOWER(città) AS città,
  CAST (AVG(media) AS DECIMAL(5,2)) AS media
FROM Studente
GROUP BY LOWER(città);
		\end{lstlisting}
		
		\begin{itemize}
			\item La clausola \lstinline|WHERE| permette di selezionare le righe che devono far parte
			del risultato.
			\item La clausola \lstinline|HAVING| permette di selezionare i raggruppamenti che
			devono far parte del risultato.
			\item La sintassi è \lstinline|HAVING bool_expr| , dove \lstinline|bool_expr| è un'espressione
			booleana che può usare gli attributi usati nel \lstinline|GROUP BY| e/o gli altri
			attributi mediante operatori di aggregazione.
		\end{itemize}
		\textbf{Esempi: }\\
		Visualizzare tutte le città raggruppate che iniziano con ’V’ della tabella
		Studente.
		\begin{lstlisting}
SELECT città
FROM Studente
GROUP BY città
HAVING città LIKE 'V%';
		\end{lstlisting}
		Visualizzare tutte le città e i cognomi raggruppati con almeno due studenti
		con lo stesso cognome.
		\begin{lstlisting}
SELECT cognome, LOWER (città)
FROM Studente
GROUP BY cognome, LOWER(città)
HAVING COUNT(cognome)>1;
		\end{lstlisting}
		
		\subsubsection{Comando JOIN}
			Si è visto che se sono presenti due o più nomi di tabelle, si esegue il
			prodotto cartesiano tra tutte le tabelle e lo schema del risultato può
			contenere tutti gli attributi del prodotto cartesiano.
			Il prodotto cartesiano di due o più tabelle è un \lstinline|CROSS JOIN| .
			A partire da SQL-2, esistono altri tipi di \lstinline|JOIN| (\lstinline|join_type|):
			\lstinline|INNER JOIN|, \lstinline|LEFT OUTER JOIN| , \lstinline|RIGHT OUTER JOIN| e \lstinline|FULL OUTER JOIN|.
			
			\begin{lstlisting}
table_name [ NATURAL ] join_type table_name 
  [ ON join_condition [ , ...]]
			\end{lstlisting}
			dove \lstinline|join_condition| è un’espressione booleana che seleziona le tuple del join
			da aggiungere al risultato. Le tuple selezionate possono essere poi filtrate
			con la condizione della clausola \lstinline|WHERE|.
\end{document}